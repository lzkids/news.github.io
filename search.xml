<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Cmder配置WSL</title>
      <link href="/2021/01/29/Cmder%E9%85%8D%E7%BD%AEWSL/"/>
      <url>/2021/01/29/Cmder%E9%85%8D%E7%BD%AEWSL/</url>
      
        <content type="html"><![CDATA[<h3 id="在Windows下安装Linux子系统">          <a href="#在Windows下安装Linux子系统" class="heading-link"><i class="fas fa-link"></i></a><a href="#在Windows下安装Linux子系统" class="headerlink" title="在Windows下安装Linux子系统"></a><strong>在Windows下安装Linux子系统</strong></h3>      <p>使用Windows搜索打开控制面板–&gt;程序和功能–&gt;启用或关闭Windows功能–&gt;找到适用于Linux的Windows子系统打上√（等系统下载重新启动）如图</p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF_2021-01-29_19-32-18.png" alt=""></p><p>ps:如果找不到程序和功能，把右上角的查看方式换成大图标<a id="more"></a></p>        <h3 id="在Windows的应用商店下载你喜欢的Linux">          <a href="#在Windows的应用商店下载你喜欢的Linux" class="heading-link"><i class="fas fa-link"></i></a><a href="#在Windows的应用商店下载你喜欢的Linux" class="headerlink" title="在Windows的应用商店下载你喜欢的Linux"></a><strong>在Windows的应用商店下载你喜欢的Linux</strong></h3>      <p>（LTS表示长期支持版本）我选的是Ubuntu 20.04 LTS如图</p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/Linux_2021-01-29_19-39-42.png" alt=""></p><p>安装完之后，打开Ubuntu会让你输入name（必须英文）然后是密码（在输入密码的时候并不显示）和核对密码。输入完之后就成功了</p>        <h3 id="在Cmder关联WSL（关联子系统）">          <a href="#在Cmder关联WSL（关联子系统）" class="heading-link"><i class="fas fa-link"></i></a><a href="#在Cmder关联WSL（关联子系统）" class="headerlink" title="在Cmder关联WSL（关联子系统）"></a><strong>在Cmder关联WSL（关联子系统）</strong></h3>      <p>需要下载并安装好<span class="exturl"><a class="exturl__link" href="https://cmder.net/" target="_blank" rel="noopener">Cmder</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> ps：下载完整版Download Full</p><p>打开Cmder–&gt;右下角的三（或者win+Alt+p）–&gt;settings(第一次安装是英文版)–&gt;Interface language(切换中文)–&gt;启动–&gt;选择命令行（找到Ubuntu）如图</p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E9%85%8D%E7%BD%AEcmder_2021-01-29_20-04-13.png" alt=""></p><p>如果手动找不到，在文件管理搜索Ubuntu2004.exe（WindowsApp下的）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DeepLTranslate翻译</title>
      <link href="/2021/01/29/DeepLTranslate%E7%BF%BB%E8%AF%91/"/>
      <url>/2021/01/29/DeepLTranslate%E7%BF%BB%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/deelp_2021-01-29%20185315.png" alt=""></p><p> <span class="exturl"><a class="exturl__link" href="https://www.deepl.com/translator" target="_blank" rel="noopener">DeepL</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>是人工智能语言辅助，训练人工智能来理解和翻译文本。系统能快速、自动地识别语言，将单词转化为你想要的语言，并尝试添加特殊的语言细微差别和表达方式。拥有神经性网络。官网支持中文。支持网页翻译和客户端翻译<span class="exturl"><a class="exturl__link" href="https://www.deepl.com/app" target="_blank" rel="noopener">下载地址</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 应用与插件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>推荐RSS网站</title>
      <link href="/2021/01/29/%E6%8E%A8%E8%8D%90RSS%E7%BD%91%E7%AB%99/"/>
      <url>/2021/01/29/%E6%8E%A8%E8%8D%90RSS%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<p>游戏时光头条：<span class="exturl"><a class="exturl__link" href="https://www.vgtime.com/rss.jhtml" target="_blank" rel="noopener">https://www.vgtime.com/rss.jhtml</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>青柠学术：<span class="exturl"><a class="exturl__link" href="https://iseex.github.io/feed.xml" target="_blank" rel="noopener">https://iseex.github.io/feed.xml</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>少数派：<span class="exturl"><a class="exturl__link" href="https://sspai.com/feed" target="_blank" rel="noopener">https://sspai.com/feed</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>森林集：<span class="exturl"><a class="exturl__link" href="https://senlinjimore.com/archives/category/%e8%bd%af%e4%bb%b6/%e7%94%b5%e8%84%91/feed" target="_blank" rel="noopener">https://senlinjimore.com/archives/category/%25e8%25bd%25af%25e4%25bb%25b6/%25e7%2594%25b5%25e8%2584%2591/feed</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>数码荔枝：<span class="exturl"><a class="exturl__link" href="https://www.lizhi.io/feed/" target="_blank" rel="noopener">https://www.lizhi.io/feed/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>小众软件：<span class="exturl"><a class="exturl__link" href="https://www.appinn.com/feed/" target="_blank" rel="noopener">https://www.appinn.com/feed/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>知乎日报：<span class="exturl"><a class="exturl__link" href="http://feedmaker.kindle4rss.com/feeds/zhihu-daily.xml" target="_blank" rel="noopener">http://feedmaker.kindle4rss.com/feeds/zhihu-daily.xml</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>178动漫频道：<span class="exturl"><a class="exturl__link" href="http://acg.178.com/s/rss.xml" target="_blank" rel="noopener">http://acg.178.com/s/rss.xml</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>反斗软件：<span class="exturl"><a class="exturl__link" href="http://www.apprcn.com/feed" target="_blank" rel="noopener">http://www.apprcn.com/feed</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>更新中……</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 应用与插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何删除鼠标右键的cmder</title>
      <link href="/2021/01/29/%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE%E7%9A%84cmder/"/>
      <url>/2021/01/29/%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE%E7%9A%84cmder/</url>
      
        <content type="html"><![CDATA[<p><strong>如何删除鼠标右键选项的cmder（或其他添加到文件目录中的应用）</strong></p><p>1.打开注册表设置（打开方式：直接搜索“注册表”或者win + r → regedit） <a id="more"></a></p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E6%89%93%E5%BC%80%E6%B3%A8%E5%86%8C%E8%A1%A8%202021-01-29%20114632.png" alt=""></p><p>2.找到HKEY_CLASSES_ROOT → Directory → Background → cmder（删除选项）</p><p>或者打开注册表之后，编辑 –&gt;查找 –&gt;输入cmder进行查找</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门oh-my-zsh</title>
      <link href="/2021/01/28/%E5%85%A5%E9%97%A8oh-my-zsh/"/>
      <url>/2021/01/28/%E5%85%A5%E9%97%A8oh-my-zsh/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Oh-my-zsh是一个开源的、社区驱动的管理zsh的框架，它是免费的。它有超过180个可选的插件（rails、git……），超过120个主题和一个自动更新工具来保持oh-my-zsh的最新状态。</p></blockquote><p>在本教程中，我将指导你在你的PC/笔记本电脑上安装它。最大的好处是你可以自定义你的Shell和添加插件。不像老式的Bash shell，它看起来并不吸引人，当你大量使用命令行工作时，会让你很难使用。</p>        <h4 id="前提条件">          <a href="#前提条件" class="heading-link"><i class="fas fa-link"></i></a><a href="#前提条件" class="headerlink" title="前提条件"></a><strong>前提条件</strong></h4>      <ul><li>Linux 和 macOS，因为 oh-my-zsh 在基于 Unix 的操作系统上工作得最好。</li><li>WSL(Windows Subsystem for Linux)也可以和oh-my-zsh一起工作。<a id="more"></a></li><li>zsh必须是预装的，在OSX中，它已经被预装了。在OSX中，它已经被预装了。在 Linux 中，你需要在终端中输入命令来安装。</li><li>curl或wget必须安装.</li><li>对于Debian/Ubuntu，你需要在终端输入命令：必须安装curl或wget。</li></ul><pre><code class="shell">sudo apt-get installl zsh</code></pre><ul><li><p>对于Fedora：</p><pre><code class="shell">sudo yum install zsh</code></pre><p>下载oh-my-zsh</p><p>通过curl</p><pre><code class="shell">curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh</code></pre><p>通过wget</p><pre><code class="shell">wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O - | sh</code></pre><p>更改默认shell</p><pre><code class="shell">chsh -s /bin/zsh</code></pre><p>对于某些操作系统，可能需要重新启动计算机才能生效。</p></li></ul>        <h4 id="更换终端主题">          <a href="#更换终端主题" class="heading-link"><i class="fas fa-link"></i></a><a href="#更换终端主题" class="headerlink" title="更换终端主题"></a><strong>更换终端主题</strong></h4>      <p>现在你已经成功安装了 oh-my-zsh。你需要改变适合你的主题，而不是使用默认的。要改变它，你需要修改<code>.zshrc</code>文件:</p><pre><code class="shell">vim ~/.zshrc</code></pre><p>在本教程中，我使用的是vim文本编辑器，如果你喜欢可以使用其他的文本编辑器。接下来，在文件中找到这一行:</p><pre><code class="shell">ZSH_THEME="robbyrussell"</code></pre><p>把名字 “robbyrussell “改为另一个主题的名字。你可以看看这个网站上的所有可用的<span class="exturl"><a class="exturl__link" href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes" target="_blank" rel="noopener">主题</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p><p>最后，只要重启终端，你就会看到不同的效果。</p>        <h4 id="添加插件">          <a href="#添加插件" class="heading-link"><i class="fas fa-link"></i></a><a href="#添加插件" class="headerlink" title="添加插件"></a><strong>添加插件</strong></h4>      <p>在.zshrc文件中，你需要编辑以 “plugins “字样开头的一行:</p><pre><code class="shell">plugins=(git bundler osx rake ruby)</code></pre><p>如果你喜欢，你可以添加更多或删除插件。要使用这些插件，大多数插件都有README文件，其中记录了如何使用它们。</p>        <h4 id="自动补全与⬆">          <a href="#自动补全与⬆" class="heading-link"><i class="fas fa-link"></i></a><a href="#自动补全与⬆" class="headerlink" title="自动补全与⬆"></a><strong>自动补全与⬆</strong></h4>      <p>在Bash shell中，你可以使用Ctrl + R和⬆来自动填写最近的和匹配的命令。</p><p>使用 oh-my-zsh，还有另一种方法：你可以输入你想要的命令的起始词，然后按 ⬆来循环浏览历史记录。</p>        <h4 id="用Tab键自动完成">          <a href="#用Tab键自动完成" class="heading-link"><i class="fas fa-link"></i></a><a href="#用Tab键自动完成" class="headerlink" title="用Tab键自动完成"></a><strong>用Tab键自动完成</strong></h4>      <p>在Bash shell中，你可以输入关键字，然后按Tab键显示匹配命令列表，但是你需要在列表中循环并记住你想要的名称，并手动进一步输入以完成。</p><p>有了oh-my-zsh，事情就好办了，第一次按Tab键后，可以按第二次，允许在列表中循环，选择你想要的命令，然后它会自动填入剩下的单词，最后只要按Enter键就可以了。比如说：</p><ol><li>第一次输入并按Tab键<code>doc</code></li></ol><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/apt_2021-01-29%20105236.png" alt=""></p><p>  2.第二次按Tab键，然后按Tab键进行上、下、左、右循环。</p>        <h4 id="更新-oh-my-zsh">          <a href="#更新-oh-my-zsh" class="heading-link"><i class="fas fa-link"></i></a><a href="#更新-oh-my-zsh" class="headerlink" title="更新 oh-my-zsh"></a><strong>更新 oh-my-zsh</strong></h4>      <p>它会自动更新，但如果你想手动更新，只需在终端机上输入以下命令即可。</p><pre><code class="shell">omz update</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> omz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux入门指南-一</title>
      <link href="/2021/01/28/Linux%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E4%B8%80/"/>
      <url>/2021/01/28/Linux%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h3 id="Linux-是什么？">          <a href="#Linux-是什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#Linux-是什么？" class="headerlink" title="Linux 是什么？"></a><strong>Linux 是什么？</strong></h3>      <p>Linux 是一个开源操作系统和 IT 基础架构平台。它由 Linus Torvalds 于 1991 年构思设计而成，</p>        <h3 id="Linux-的优点">          <a href="#Linux-的优点" class="heading-link"><i class="fas fa-link"></i></a><a href="#Linux-的优点" class="headerlink" title="Linux 的优点"></a>Linux 的优点</h3>      <p>跨平台的硬件支持</p><p>低资源占用下良好的稳定性</p><p>高效的文件系统</p><p>可靠的安全性 <a id="more"></a></p><p>完善纯净的软件包管理机制</p><p>随心所欲定制 UI</p><p>社区的支持</p><p>开源</p>        <h3 id="哪些大众用户比较适合-Linux-桌面版？">          <a href="#哪些大众用户比较适合-Linux-桌面版？" class="heading-link"><i class="fas fa-link"></i></a><a href="#哪些大众用户比较适合-Linux-桌面版？" class="headerlink" title="哪些大众用户比较适合 Linux 桌面版？"></a>哪些大众用户比较适合 Linux 桌面版？</h3>      <p>学习和探索</p><p>业余个人内容创作</p><p>极度重视安全和隐私</p><p>机器已经跑不动 Windows / macOS</p>        <h3 id="Linux-上软件有多少？">          <a href="#Linux-上软件有多少？" class="heading-link"><i class="fas fa-link"></i></a><a href="#Linux-上软件有多少？" class="headerlink" title="Linux 上软件有多少？"></a>Linux 上软件有多少？</h3>      <p>网页版应用</p><p>支持同类网络传输协议的客户端</p><p>任务自动化服务</p><p>即时通讯软件内置的聊天机器人</p><p>Wine 兼容运行 Windows 应用</p><p>模拟器兼容运行 Android 应用</p><p>虚拟机软件模拟运行 macOS 或 Windows 系统</p>        <h3 id="总结">          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <p>Linux 因为其完全模块化的基理，干净得像水一样。水本身无固定的形态，它可以随环境而作出适应，让自己变成外物的形态。</p><p>所以，朋友，像水一样吧！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 语言与Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hyper终端简单配置</title>
      <link href="/2021/01/28/Hyper%E7%BB%88%E7%AB%AF%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/01/28/Hyper%E7%BB%88%E7%AB%AF%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>  <span class="exturl"><a class="exturl__link" href="https://hyper.is/" target="_blank" rel="noopener">Hyper</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 是一个开源的、全平台适用的、有着丰富主题和插件的现代化终端。</p><p>打开之后是默认的cmd，更改顺序是左上角Edit—&gt;Preferences如图</p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/komi_2021-01-28_13-37-46.png" alt=""></p><p>打开之后是一个.hyper.js的文件找到shell，在引号内写入<code>C:\\Windows\\System32\\bash.exe</code> 如图 <a id="more"></a></p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/shell_2021-01-28_13-44-18.png" alt=""></p><p>当然前提是有子系统，更改主题找到<code>plugins</code>(在.hyper.js里) 填入你喜欢的<span class="exturl"><a class="exturl__link" href="https://hyper.is/themes" target="_blank" rel="noopener">主题</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> （hyperterm-monokai）</p><p>如果要切换zsh则需要在Preferences的shell在引号内写入<code>C:\\Windows\\System32\\wsl.exe</code> 和<code>shellArgs: ['~']</code>如图</p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-01-28%20192821.png" alt=""></p><p><strong>下载插件</strong> </p><p>推荐这两个插件，<span class="exturl"><a class="exturl__link" href="https://hyper.is/plugins" target="_blank" rel="noopener">其它插件</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><pre><code class="bash"> # hyper-opacity,解决windows下hyper原生不支持的窗口透明化 hyper i hyper-opacity # Hyper的扩展，可以打开电源模式，并有额外的哇模式。 hyper i hyperpower # 在 Hyper 终端启动之前和之后初始化命令的终极和最完整的扩展 hyper i hyper-init</code></pre><p>在Hyper安装会报错，需要在管理员Windows PowerShell中下载或者管理员cmd中下载</p><p>安装成功如下图</p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-01-28%20194803.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 应用与插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 终端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子系统下不识别u盘</title>
      <link href="/2021/01/28/%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%B8%8B%E4%B8%8D%E8%AF%86%E5%88%ABu%E7%9B%98/"/>
      <url>/2021/01/28/%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%B8%8B%E4%B8%8D%E8%AF%86%E5%88%ABu%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows下Linux不识别U盘的解决办法">          <a href="#Windows下Linux不识别U盘的解决办法" class="heading-link"><i class="fas fa-link"></i></a><a href="#Windows下Linux不识别U盘的解决办法" class="headerlink" title="Windows下Linux不识别U盘的解决办法"></a>Windows下Linux不识别U盘的解决办法</h1>      <p>在终端进入<code>/mnt/</code> 在终端输入<code>sudo mkdir /mnt/d</code>然后紧接输入<code>sudo mount -t drvfs D: /mnt/d</code></p><p>现在，能够访问D：驱动器的文件。如果卸载驱动器以便安全地将其卸载下时，运行以下命令：<code>sudo umount /mnt/d</code></p><p>具体的内容请访问<span class="exturl"><a class="exturl__link" href="https://docs.microsoft.com/zh-cn/archive/blogs/wsl/file-system-improvements-to-the-windows-subsystem-for-linux" target="_blank" rel="noopener">微软文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>windows10中的剪切版</title>
      <link href="/2021/01/27/windows10%E4%B8%AD%E7%9A%84%E5%89%AA%E5%88%87%E7%89%88/"/>
      <url>/2021/01/27/windows10%E4%B8%AD%E7%9A%84%E5%89%AA%E5%88%87%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p>Windows中的剪切板使用基于云的剪贴板从一台电脑上复制图像和文本并粘贴到另一台电脑上。你不仅可以重剪贴板历史记录中粘贴，还可以固定发现自己经常使用的项目。</p><ol><li>若要随时访问剪贴板历史记录，请按 Windows 徽标键 + V。你还可以从剪贴板菜单中选择单个项来“粘贴”和“固定”常用的项。</li><li>若要在你的 Windows 10 设备之间共享剪贴板项目，请依次选择“开始”菜单 &gt;“设置” &gt;“系统”&gt;“剪贴板”。选择“跨设备同步”下的“自动同步我复制的文本”。同步功能与你的 Microsoft 帐户或工作帐户绑定，因此请记得在所有设备上使用相同的登录信息。</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活与话 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DirectoryOpus文件管理</title>
      <link href="/2021/01/27/DirectoryOpus%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
      <url>/2021/01/27/DirectoryOpus%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="DirectoryOpus">          <a href="#DirectoryOpus" class="heading-link"><i class="fas fa-link"></i></a><a href="#DirectoryOpus" class="headerlink" title="DirectoryOpus"></a>DirectoryOpus</h1>      <p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/header.png" alt=""></p><p><span class="exturl"><a class="exturl__link" href="https://www.gpsoft.com.au/" target="_blank" rel="noopener">DirectoryOpus</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 是 Win 平台上de1资源管理器，功能最完全、可定制化程度高。可以通过 DO 完成几乎所有操作，包括查看图片元信息、预览图片、阅读文本文件内容、批量重命名、操作压缩文件以及 FTP 同步请求等</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 应用与插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小技巧</title>
      <link href="/2021/01/27/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2021/01/27/%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="小技巧">          <a href="#小技巧" class="heading-link"><i class="fas fa-link"></i></a><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1>      <ul><li>☺笑容会给你带来一整天的灿烂。</li><li>别犹豫别放弃，保持速度，不要慢下来。</li><li>没有必要为了别人而改变，别人总有离开的时候。改变应该是自发而主动的。</li><li>改变你的思考模式。</li><li>变是为了让自己快乐，为了别人而改变，不会长久的。</li><li>改变外在是改变内心的途径之一。</li><li>别人的想法不重要，要尊重你自己的想法。</li><li>有意识的去改变，要知道自己在做什么。</li><li>可以改变很多次，一切都处于运动变化中。</li><li>坚持。养成一个新习惯至少需要21天。第一天非常难，后来就会越来越简单。</li><li>一个人都有缺点，请做独一无二的你。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活与话 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何改变自己(一)</title>
      <link href="/2021/01/27/%E5%A6%82%E4%BD%95%E6%94%B9%E5%8F%98%E8%87%AA%E5%B7%B1-%E4%B8%80/"/>
      <url>/2021/01/27/%E5%A6%82%E4%BD%95%E6%94%B9%E5%8F%98%E8%87%AA%E5%B7%B1-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="如何改变自己">          <a href="#如何改变自己" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何改变自己" class="headerlink" title="如何改变自己"></a>如何改变自己</h1>              <h3 id="前言">          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3>      <p>大多数人会在某些时刻对自己的人生或者自我感到不满足。如果你意识到自己需要做出很大改变，那么你是幸运的。因为你有了这样的意识，就能够改变。重大的改变虽然令人望而生畏，但只要你目标明确、计划清晰就可以做到。行为上的改变，最终会带来对自身整体看法的改变。</p>        <h3 id="一-评估你的需求。">          <a href="#一-评估你的需求。" class="heading-link"><i class="fas fa-link"></i></a><a href="#一-评估你的需求。" class="headerlink" title="一.评估你的需求。"></a>一<strong>.评估你的需求</strong>。</h3>      <p><strong>1.发现问题。</strong>你决定要改变，原因和具体措施是什么？看清引起你改变的那个问题，分析问题是解决问题的必要前提。你要知道改变会带来哪些好处。</p><ul><li>态度积极。列出你身上能被自我欣赏的优点，如果你觉得这很难，那就想想别人对你的评价，在改正坏习惯的过程中，你可以拿你的优点作为参照。<a id="more"></a></li><li>简单来说，就是得明确你想要什么，别人对你的期待不等同于你自己的追求，假如你本身不渴望改变，那改变自然也不会发生。</li><li>然后，列出你之所以想改变的原因，把原因写在纸上，当你看见时就会有动力，这能够让你坚持下去。</li></ul><p><strong>2.自我肯定</strong>。认可自己的积极面，以此强化你的核心价值观，你就可以不断靠近理想中的自己，当然盲目的自我肯定并没有用，因为这种盲目无法激发你的潜能，而切合实际的肯定，可以让你保持积极心态，进而促使你更好的解决问题，有效的自我肯定。有效的自我肯定示例： </p><ul><li>用“我是”句式</li><li>用“我能”句式</li><li>用“我会”句式</li></ul><p><strong>3.将改变后的未来可视化。</strong>可视化是一种心理预演，帮助你设想一个不同的情景。抽象的可视化在脑海中进行，具体的可视化即收集一些和你的目标相关的图片。有效的可视化，帮你细化目标和调整目标。可视化还能培养你对环境和人生的控制力。操作步骤：</p><ul><li>闭上眼睛。</li><li>想象理想中未来的自己，你在哪？在做什么？环境发生了什么变化？那时的你什么样？哪些变化让你感到快乐？</li><li>试着探索理想中未来的细节。动用视觉，听觉，嗅觉，味觉去想象。细节具体化能够让可视化，更为真实。</li><li>运用积极的可视化帮你设立切实可行的阶段性目标。</li></ul><p><strong>4.好遇到障碍的准备。</strong>人生有很多事情无法预料，每一条改变之路都充斥着困难和别人的阻挠，那些困难和最终的成功相比都是小事，而且也终将被克服，你要坚信这一点，才能够成功。</p><ul><li>切合实际是应对任何困难的最佳途径，遇到障碍时不要责怪别人或他人，因为阻碍是正常的，而且必然会发生。</li></ul><p><strong>5.表面的失败中学习。</strong>很多时候你会觉得自己失败了，你没有达成目标，你遭遇坎坷，你不得不改变目标，但请你记住，失败只是表面的，实际上失败意义的新机遇，从失败中学得宝贵的经验，学会灵活的调整目标，这样你会更快乐。</p><p>6.耐心。要是改变是轻而易举就能做到的，那就没有什么价值了，成果比你预想中来的慢，有时候旁人能够一眼看到你的改变和成果，只是你自己还不知道而已，你每天都有细微的改变，所以自己无法察觉，但改变的确发生了。</p><ul><li>大目标分成小目标有益于对自己进行阶段性评估，每当达成一个小目标适当的奖励自己，这样你就可以保持前进的动力。</li></ul>        <h3 id="二-设立合理的目标。">          <a href="#二-设立合理的目标。" class="heading-link"><i class="fas fa-link"></i></a><a href="#二-设立合理的目标。" class="headerlink" title="二.设立合理的目标。"></a><strong>二.设立合理的目标。</strong></h3>      <p>1.在SMART法则指导下设立目标。定目标也是门艺术。目标定得好，才能够确保实现。SMART是5个英文单词首字母的集合，该法则是一个用于衡量目标的合理程度的有效工具。</p><ul><li>具体（Specific）／重要（Significant）</li><li>可衡量（Measurable）／有意义（Meaningful）</li><li>可达成（Achievable）／基于行动（Action-oriented）</li><li>相关（Relevant）／基于成果（Results-oriented）</li><li>有时限（Time-bound）／可追踪（Trackable）</li></ul><p><strong>2.制定具体的目标。</strong> 也就是说目标要有针对性。假如目标过于宽泛，就难以据此制定实现目标的行动方案。</p><p><strong>3.确保目标是可衡量的。</strong> 你得知道怎样算达成目标。要是无法判断目标实现与否，离现实还有多少距离，那样的目标是不可衡量的。</p><p><strong>4.确保目标可达成。</strong>根据每个人的能力不同，因人而异。判断一个目标是否可达成，要考虑很多因素。有些因素是人为不可控的。需要考虑的是自己是否有足够的知识与技能去实现目标。判断该目标实现的可能性。</p><p><strong>5.评估目标的相关性。</strong>这个标准对于阶段性目标来说，尤为重要。你的阶段性目标必须和总目标相关，并且逐步促进最终目标达成。不相关的目标对成功没有帮助。</p><p><strong>6.设定达成目标的时间</strong>。 有效的目标应当有时限，否则努力就没有意义。</p>        <h3 id="三-付诸行动。">          <a href="#三-付诸行动。" class="heading-link"><i class="fas fa-link"></i></a><a href="#三-付诸行动。" class="headerlink" title="三.付诸行动。"></a><strong>三.付诸行动。</strong></h3>      <p><strong>1.从现在开始。</strong> 别总想着明天再说，而明天又拖到后天。停止拖延是改变的第一步。如果你战胜不了拖延，那就不会有所成。</p><p><strong>2.把大目标分解为小目标。</strong> 总目标分解成阶段性目标，因为阶段性目标容易实现，带来的成就感使你继续努力的动力。</p><ul><li>永远的目标让人望而怯步，你先不要想的太过遥远，专注于第1个阶段性目标。</li><li>尝试定制倒推式日程。从总目标的实现日期往前推算各阶段目标的达成日期，直到推及现在，在总时间既定的情况下，你可能需要调整几次日程安排或者必要时调整总时间。</li><li>用倒推的办法安排日程，能够帮你推算出第1步该做什么，万事开头难知道第1步做什么，以后就会越来越顺利。</li></ul><p><strong>3.奖励自己</strong>。 积极的看待自己的进步给予合理的奖励，这对于实现长远目标也很有帮助，放松一下。</p><ul><li>但是奖励不该和目标相违背。</li></ul><p><strong>4.恰当运用情绪。</strong> 实现目标的过程中，你会有各种各样的情绪，这很正常，你需要学会借助这些情绪来促进目标的实现。</p><ul><li>当你实现一个阶段性目标，你应该开心开心，会让你更有动力继续努力。</li><li>当你遇到困难你会感到沮丧，沮丧会让你更专注目标。</li><li>当你接近目标时突然遇到阻碍，你会愤怒，把愤怒转化为最后一搏的动力。</li></ul><p><strong>5.走出自己的舒适区。</strong> 多数人喜欢做自己喜欢的事，然而如果你想做出一个重大改变，你必须走出自身的舒适区，但是不要担心，不适感会给你带来新视角，助你成长。</p><ul><li>我们要再次提及分解目标的好处。你觉得目标让人望而怯步时，你就先专注于实现第1个阶段性目标，这样能够减少畏惧。</li><li>向目标努力的过程中，试着走出自己的舒适区，这会让你开拓视野、增长经验、变得更积极。</li></ul>        <h3 id="四-回顾成绩">          <a href="#四-回顾成绩" class="heading-link"><i class="fas fa-link"></i></a><a href="#四-回顾成绩" class="headerlink" title="四.回顾成绩"></a><strong>四.回顾成绩</strong></h3>      <p><strong>1.保持动力。</strong>在改变自我的过程中，你会遇到意料之外的阻碍，这些时刻要尤为小心恰当的应对，让自己保持正确的方向。</p><ul><li>言出必行。</li><li>别让自己过于疲惫。</li><li>留意心理暗示。</li><li>找到志同道合的朋友。</li></ul><p><strong>2.记录并追踪感受。</strong> 记录自己的行为从中发现规律，以找到最有效的途径。</p><ul><li>你发现自己总是退回老习惯，无法改变时，写下时间、原因和细节。分析可能的因素。</li><li>记录你的进步。如果这天你表现不错，写下来回顾自己的进步，会让你保持前进的动力。</li></ul><p><strong>3.保持健康。</strong>身体健康什么事都变得更容易，身体健康，不仅提高生活质量，而且有助于保持积极的心态。</p><ul><li>合理饮食保证充足的睡眠，这是最基本的要求，毕竟改变自己和实现目标是很难的事情，你得用最佳的心理和身体状态来迎接挑战。</li><li>身体不好的时候先调整好自身的状态。健康快乐是第1位，其次才是想法和目标。</li></ul><p><strong>4.调整目标。</strong> 当你不断进步，在接近目标的过程中要不断调试，记录你的进步，据此调整计划，使它更适合你。</p><ul><li>当你进步飞速时，可以制定更有挑战性的新目标。</li><li>如果你没有达到预期的成绩，不要自责，把目标调整的更为合理，别因挫败而放弃。</li></ul><p><strong>5.坚持。</strong> 当你实现了预期的结果，不要停止努力，新的习惯需要花时间来保持，让自己慢慢适应新状态。</p><ul><li>让改变持续一生。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活与话 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>知识点（一）</title>
      <link href="/2021/01/26/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2021/01/26/%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="知识点">          <a href="#知识点" class="heading-link"><i class="fas fa-link"></i></a><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2>      <p>​          1.display:none *与visitibility:hidden  前者不保留位置,后者保留位置</p><p>​          2.额外标签法 overflow  伪元素法</p><p>​          3.css3盒子模型border-box中,盒子的width包含了conter+border+padding(实际宽高)</p><p>​         4.vertical-align:middle            vertical-align:top       vertical-align:bottom  </p><p>​         5.绝对定位元素可以配合除静态定位之外的所有定位属性使用。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点（一） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我遇到的问题</title>
      <link href="/2021/01/26/%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98/"/>
      <url>/2021/01/26/%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="问题">          <a href="#问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#问题" class="headerlink" title="问题"></a>问题</h2>      <ol><li><p>什么是行内块元素()?</p></li><li><p>什么是块元素 (占一整行)? </p></li><li><p>什么是行内元素(一行内显示的)</p></li><li><p>阴影的设置   box-shadow  :x轴 y轴  阴影大小 模糊程度  颜色 内阴影inset/外阴影(默认)   如果一分为二,需要设置模糊成度</p></li><li><p>权重问题 —- !&gt;行内式&gt;id选择器&gt;类选择器&gt;标签选择器&gt;通配符选择器&gt;浏览器默认&gt;继承选择<a id="more"></a></p></li><li><p>定位 ?  </p><p>绝对定位([absolute]不占位置) </p><p>相对定位(relative永远参照自身定位)</p><p>固定定位([fixed]浏览器的可是区域移动)</p></li><li><p>双伪元素的写法   (伪元素清除浮动)—(               )</p><pre><code class="css">①                                                 ②.clearfix:after{                           .clearfix:before, content:"";                                  .clearfix:after{  display:block;                                contrnt:"";    height:0;                                        display:table;visibitility:hidden;(隐藏)               } clear: both;                                   }.clearfix{*zoom:1;}</code></pre></li></ol><p>   ​      *zoom:1(ps:应该是这个)</p><ol start="8"><li><p>overflow的用法</p></li><li><p>相对路径和绝对路径</p></li><li><p>按钮部分</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三方评论Gittalk</title>
      <link href="/2021/01/26/%E7%AC%AC%E4%B8%89%E6%96%B9%E8%AF%84%E8%AE%BA/"/>
      <url>/2021/01/26/%E7%AC%AC%E4%B8%89%E6%96%B9%E8%AF%84%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p> <strong>前言</strong></p><p>如何给博客集成Gittalk。Gittalk是基于GitHub Issue开发的评论插件，它是把GitHub 的issue集成在hexo博客中。</p><p>首先你的hexo主题支持Gittalk。然后就是有个GitHub账号。</p><p><strong>配置Gittalk</strong></p>        <h3 id="Register-Application">          <a href="#Register-Application" class="heading-link"><i class="fas fa-link"></i></a><a href="#Register-Application" class="headerlink" title="Register Application"></a>Register Application</h3>      <p>在GitHub注册新应用<br>登录GitHub-&gt;点击头像-&gt;Setting-&gt;Developer settings-&gt;OAuth Apps-&gt;New OAuth App<br>顺序如图<a id="more"></a></p><p>1.</p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/Developer%20settings.png" style="zoom: 67%;"><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/OAuth%20apps_2021-01-26_21-36-28.png" alt=""></p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E6%96%B0%E5%BB%BAOAuth_2021-01-26_21-37-58.png" alt=""></p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/michi_2021-01-26_21-58-01.png" alt=""></p>        <h3 id="config-yml">          <a href="#config-yml" class="heading-link"><i class="fas fa-link"></i></a><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3>      <p>在主题配置文件<code>xxx/_config.yml</code>中按需添加内容：</p><pre><code class="yml">gitalk:  enable: true  githubID: github帐号  # 例：xxx    repo: 仓库名称   # 例：xxxx.github.io  ClientID: Client ID  ClientSecret: Client Secret  adminUser: github帐号 #指定可初始化评论账户  labels: 'gitalk' #GitHub issues的标签  distractionFreeMode: true</code></pre><p>以上就是添加gitalk评论的配置，博客上传到GitHub上后，打开页面进入某一博客内容下，就可看到评论处。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gittalk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简悦插件</title>
      <link href="/2021/01/25/%E7%AE%80%E6%82%A6%E6%8F%92%E4%BB%B6/"/>
      <url>/2021/01/25/%E7%AE%80%E6%82%A6%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>简于型 · 悦于心</p><p> <span class="exturl"><a class="exturl__link" href="https://simpread.pro/" target="_blank" rel="noopener">简悦</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> - 为你提供「如杂志般沉浸式阅读体验」的扩展,免费使用，但是有些功能需要高级会员才能使用</p><p>阅读模式</p><p>独有功能，通过提取 标题 · 描述 ·正文 · 媒体 图片 / 视频 等资源<br>生成符合中文阅读习惯的页面，具有零干扰 · 沉浸式特点，适合深入阅读</p><p>聚焦模式</p><p>不改变当前页面的结构，仅仅高亮需要阅读的部分<br>适合临时阅读或者未适配阅读模式的网站</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 应用与插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notion笔记软件</title>
      <link href="/2021/01/23/Notion%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/"/>
      <url>/2021/01/23/Notion%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Notion">          <a href="#Notion" class="heading-link"><i class="fas fa-link"></i></a><a href="#Notion" class="headerlink" title="Notion"></a>Notion</h1>      <p><a href="https://www.notion.so" target="_blank" rel="noopener"><strong>Notion</strong></a>是一款提供笔记、任务、数据库、看板、维基、日历和提醒等组件的应用程序。用户可以将这些组件连接起来，来创建自己的系统，用于知识管理、笔记记录、数据管理、项目管理等。这些组件和系统可以单独使用，也可以与他人进行跨平台协作。支持英语和韩语。官方消息说马上支持中文（还在本地化翻译）<a id="more"></a></p><p>支持 谷歌插件 </p><p>IOS &amp; Android谷歌插件 </p><p>Mac &amp; Windows</p><p>Web Clipper</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 应用与插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH的建立</title>
      <link href="/2020/09/22/SSH%E7%9A%84%E5%BB%BA%E7%AB%8B/"/>
      <url>/2020/09/22/SSH%E7%9A%84%E5%BB%BA%E7%AB%8B/</url>
      
        <content type="html"><![CDATA[<pre><code class="bash">ssh-keygen -t rsa -C "youremail"</code></pre><p>然后一路回车，生成了<code>.ssh</code>的文件夹。在你的电脑中找到这个文件夹。</p><pre><code class="bash">~/.ssh/id_rsa.pub</code></pre><p>打开<span class="exturl"><a class="exturl__link" href="https://github.com/" target="_blank" rel="noopener">github</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个<code>SSH</code>，名字随便取一个都可以，把你的<code>id_rsa.pub</code>里面的信息复制进去。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS通用初始化</title>
      <link href="/2020/09/12/CSS%E9%80%9A%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2020/09/12/CSS%E9%80%9A%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p> 通用的CSS初始化（也许有用）</p><p><strong>什么是css初始化？</strong></p><p>CSS初始化是指重设浏览器的样式。不同的浏览器默认的样式可能不尽相同，所以开发时的第一件事可能就是如何把它们统一。如果没对CSS初始化往往会出现浏览器之间的页面差异。</p><p><strong>为什么要初始化css？</strong></p><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。<a id="more"></a></p><pre><code class="css">/*css reset*/    /*清除内外边距*/    body, h1, h2, h3, h4, h5, h6, p, hr, /*结构元素*/    ul, ol, li, dl, dt, dd, /*列表元素*/    form, fieldset, legend, input, button, select, textarea, /*表单元素*/    th, td, /*表格元素*/    pre {        padding: 0;        margin: 0;    }    /*重置默认样式*/    body, button, input, select, textarea {        /*font: 12px/1 微软雅黑, Tahoma, Helvetica, Arial, 宋体, sans-serif;*/        color: #333;        font: 12px/1 "Microsoft YaHei", Tahoma, Helvetica, Arial, SimSun, sans-serif;    }    h1, h2, h3, h4, h5, h6 {        font-size: 100%;        font-weight: normal;    }    em, i {        font-style: normal;    }    a {        text-decoration: none;    }    li {        list-style-type: none;        vertical-align: top;    }    img {        border: none;        /*display: block;*/        vertical-align: top;    }    textarea {        overflow: auto;        resize: none;    }    table {        border-spacing: 0;        border-collapse: collapse;    }/*常用公共样式*/    .fl {        float: left;        display: inline;    }    .fr {        float: right;        display: inline;    }    .cf:before,    .cf:after {        content: " ";        display: table;    }    .cf:after {        clear: both;    }    .cf {        *zoom: 1;    }</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue完整框架大建</title>
      <link href="/2020/09/08/vue%E5%AE%8C%E6%95%B4%E6%A1%86%E6%9E%B6%E5%A4%A7%E5%BB%BA/"/>
      <url>/2020/09/08/vue%E5%AE%8C%E6%95%B4%E6%A1%86%E6%9E%B6%E5%A4%A7%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="1-用vue-cli生成项目">          <a href="#1-用vue-cli生成项目" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-用vue-cli生成项目" class="headerlink" title="1.用vue-cli生成项目"></a><strong>1.用<code>vue-cli</code>生成项目</strong></h2>      <p>​     1.1 使用 vue create 创建一个项目</p><p>​          1.1.1在终端/cmd输入 vue create 项目名</p><p>​           1.1.2按下下方向键选择自定义配置    回车（Enter）</p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/vue%E9%85%8D%E7%BD%AE.png" alt=""></p><p>   按 空格键 选择  <code>Router</code>、<code>Vuex</code>、<code>CSS Pre-processors</code>、<code>Linter / Formatter</code> 其它按照默认即可 。选好后  回车 <a id="more"></a></p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E9%85%8D%E7%BD%AE1.png" alt=""></p><p>​            选择2.x版本（或按需选择）回车</p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/vue%E9%A1%B9%E7%9B%AE2.png" alt=""></p><p>输入y 回车</p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E9%A1%B9%E7%9B%AE4.png" alt=""></p><p> 选择 Less 作为css预处理器</p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E9%A2%84%E7%BC%96%E8%AF%91less.png" alt=""></p><p>选择 Standard 代码风格</p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC.png" alt=""></p><p>检查代码风格的时机：保存代码，提交代码 去做检查。</p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E6%A3%80%E6%9F%A5%E4%BB%A3%E7%A0%81%E6%97%B6%E6%9C%BA.png" alt=""></p><p>依赖的工具，每一个工具对应生成一个配置文件。而不是统一写在package.json中。</p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E4%BE%9D%E8%B5%96%E5%B7%A5%E5%85%B7.png" alt=""></p><p>是否记录以上选择操作，方便下次快速创建。不记录，因为每次都不一样。</p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E8%AE%B0%E5%BD%95%E6%93%8D%E4%BD%9C.png" alt=""></p><p>创建成功</p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E5%88%9B%E5%BB%BA%E6%88%90%E5%8A%9F.png" alt=""></p>        <h2 id="2-了解结构目录">          <a href="#2-了解结构目录" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-了解结构目录" class="headerlink" title="2.了解结构目录"></a><strong>2.了解结构目录</strong></h2>      <p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E7%BB%93%E6%9E%84%E7%9B%AE%E5%BD%95.png" alt=""></p>        <h2 id="3-调整目录结构">          <a href="#3-调整目录结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-调整目录结构" class="headerlink" title="3.调整目录结构"></a><strong>3.调整目录结构</strong></h2>      <p>需要调整src的目录结构，分工明确，代码可维护性更好。</p><pre><code class="bash">src├─api            # 接口相关代码，axios相关代码├─assets         # 静态资源，css  images ...├─components     # 公用级别组件├─router         # 路由相关代码├─styles         # less相关代码├─utils          # 全局工具模块相关代码├─views          # 路由级别组件└─App.vue        # 根组件└─main.js        # 入口文件</code></pre>        <h2 id="4-安装常用的npm包">          <a href="#4-安装常用的npm包" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-安装常用的npm包" class="headerlink" title="4.安装常用的npm包"></a>4.安装常用的npm包</h2>      <pre><code>npm i axios  # 一款基于Promise API 的HTTP客户端   https://github.com/axios/axios</code></pre><pre><code>npm install mockjs    # 生成随机数据，拦截 Ajax 请求   http://mockjs.com/</code></pre><pre><code>npm install moment --save  # 一个轻量级的JS日期库，用于分析、校验、操作和格式化日期  http://momentjs.cn/</code></pre><pre><code>npm i --save lodash  # 一款JS库，封装了很多有用的JS API https://lodash.com/</code></pre><p>带更新中…..</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP重定向</title>
      <link href="/2020/08/30/HTTP%E9%87%8D%E5%AE%9A%E5%90%91/"/>
      <url>/2020/08/30/HTTP%E9%87%8D%E5%AE%9A%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP的重定向">          <a href="#HTTP的重定向" class="heading-link"><i class="fas fa-link"></i></a><a href="#HTTP的重定向" class="headerlink" title="HTTP的重定向"></a>HTTP的重定向</h1>      <p>One of the most common and largely overlooked vulnerabilities by web developers is Open Redirect (also known as “Unvalidated Redirects and Forwards”).</p><blockquote><p>其中一个最常见的，也是大部分被网站开发者忽视的漏洞是开放重定向（也称为 “无效重定向和转发”）。</p></blockquote><p>  A website is vulnerable to Open Redirect when parameter values (the portion of URL after “?”) in an HTTP GET request allow for information that will redirect a user to a new website without any validation of the target of redirect.<a id="more"></a></p><blockquote><p>当HTTP GET请求中的参数值（”? “后的部分URL）允许提供信息，将用户重定向到一个新的网站，而不对重定向的目标进行任何验证时，网站就会受到Open Redirect的攻击。</p></blockquote><p> Depending on the architecture of a vulnerable website, redirection could happen after certain action, such as login, and sometimes it could happen instantaneously upon loading of a page.</p><blockquote><p>根据易受攻击网站的架构，重定向可能会在某些操作后发生，如登录，有时也可能在页面加载时瞬间发生。</p></blockquote><p>An example of a vulnerable website link could look something like this: <span class="exturl"><a class="exturl__link" href="https://www.example.com/login.html?RelayState=http%3A%2F%2Fexample.com%2Fnext" target="_blank" rel="noopener">https://www.example.com/login.html?RelayState=http%3A%2F%2Fexample.com%2Fnext</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><blockquote><p>一个脆弱的网站链接的例子可能是这样的：: <span class="exturl"><a class="exturl__link" href="https://www.example.com/login.html?RelayState=http%3A%2F%2Fexample.com%2Fnext" target="_blank" rel="noopener">https://www.example.com/login.html?RelayState=http%3A%2F%2Fexample.com%2Fnext</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p></blockquote><p>In this example, “RelayState” parameter indicates where to send user upon successful login (In our example it is “<span class="exturl"><a class="exturl__link" href="http://example.com/next&quot;).If" target="_blank" rel="noopener">http://example.com/next").If</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> website doesn’t validate the “RelayState” parameter value to make sure that target web page is legitimate and intended, attacker  could manipulate that parameter to send a victim to a fake page crafted by attacker: <span class="exturl"><a class="exturl__link" href="https://www.example.com/login.html?RelayState=http%3A%2F%2FEvilWebsite.com" target="_blank" rel="noopener">https://www.example.com/login.html?RelayState=http%3A%2F%2FEvilWebsite.com</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><blockquote><p>在这个例子中，”RelayState “参数表示在用户成功登录后将用户发送到哪里（在我们的例子中是 “<span class="exturl"><a class="exturl__link" href="http://example.com/next&quot;）。如果网站没有验证" target="_blank" rel="noopener">http://example.com/next"）。如果网站没有验证</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> “RelayState “参数的值，以确保目标网页是合法的，攻击者可以操纵该参数，将受害者发送到一个由攻击者制作的虚假页面：<span class="exturl"><a class="exturl__link" href="https://www.example.com/login.html?RelayState=http%3A%2F%2FEvilWebsite.com。" target="_blank" rel="noopener">https://www.example.com/login.html?RelayState=http%3A%2F%2FEvilWebsite.com。</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p></blockquote><p>Open Redirect vulnerabilities don’t get enough attention from developers because they don’t directly damage website and do not allow an attacker to directly steal data that belong to the company. However, that doesn’t mean that Open Redirect attacks are not a threat. One of the main uses for this vulnerability is to make phishing attacks more credible and effective.</p><blockquote><p>开放式重定向漏洞没有引起开发者的足够重视，因为它们不会直接破坏网站，也不允许攻击者直接窃取数据，而这些数据是属于该公司。然而，这并不意味着Open Redirect攻击不构成威胁。这个漏洞的主要用途之一是使钓鱼攻击更加可信和有效。</p></blockquote><p>When an Open Redirect is used in a phishing attack, the victim receives an email that looks legitimate with a link that points to a correct and expected domain. What the victim may not notice, is that in a middle of a long URL there are parameters that manipulate and change where the link will take them.</p><blockquote><p>当开放重定向被用于网络钓鱼攻击时，受害者会收到一封看似合法的电子邮件，其中的链接指向一个正确的、预期的域名。受害者可能没有注意到的是，在长长的URL中间，有一些参数可以操纵和改变链接的位置。</p></blockquote><p> To make identification of the Open Redirect even more difficult, redirection could take place after victim provides login on a legitimate website first. Attackers have found that an effective way to trick a victim is to redirect him to a fake website after they enter their credentials on a legitimate page. The fake website would look identical to a legitimate website, and it would ask the victim to re-enter their password. After the victim re-enters their password it would be recorded by the attacker and victim would be redirected back to a valid website. If done correctly, victim would think that he mistyped password once and would not notice that his username and password were stolen.</p><blockquote><p>为了使识别开放重定向更加困难，重定向可能发生在受害者先提供登录合法网站之后。攻击者发现，欺骗受害者的有效方法是在受害者在合法网页上输入凭证后将其重定向到一个假网站。这个假网站看起来和合法网站一样，它会要求受害者重新输入密码。当受害者重新输入密码后，攻击者会记录下来，受害者会被重定向到一个有效的网站。如果操作得当，受害者会认为自己打错了一次密码，不会注意到自己的用户名和密码被盗。</p></blockquote><p>Phishing is used in most successful targeted hacks and also regularly in opportunistic attacks. Considering how prominent phishing is in our daily lives, Open Redirect vulnerabilities should not be dismissed.</p><blockquote><p>网络钓鱼被用于大多数成功的目标黑客，也经常用于机会主义攻击。考虑到网络钓鱼在我们的日常生活中是多么的突出，Open Redirect漏洞不应该被忽视。</p></blockquote><p>It would have been unfair to single out any specific website or company as being vulnerable to Open Redirect because so many companies have it. Instead, it’s more useful to demonstrate how common those websites are and how easy it is to find them.</p><blockquote><p>如果单独指出任何特定的网站或公司容易受到开放重定向的影响，这是不公平的，因为有这么多公司都有这种情况。相反，更有用的是展示这些网站有多普遍，以及找到它们有多容易。</p></blockquote><p>Doing a web search is one of the best tools to find Open Redirect on your own website and across a wider Internet.</p><blockquote><p>进行网络搜索是在自己的网站和更广泛的互联网上找到Open Redirect(开放重定向)的最佳工具之一。</p></blockquote><p>Google Search allows for a great flexibility in writing search queries, including queries that specifically search through URLs of pages.</p><blockquote><p>Google搜索可以非常灵活地编写搜索查询，包括专门通过网页的URL进行搜索的查询。</p></blockquote><p>The following operators and special symbols allow anyone to craft very targeted Google Searches for finding Open Redirects:</p><blockquote><p>以下操作符和特殊符号使任何人都可以针对特定的Google搜索，以查找开放重定向：</p></blockquote><p><strong>allinurl</strong> - operator that tells Google to search within URL for all provided keywords</p><p>Example: allinurl:ReturnUrl which searches for web pages that have “ReturnUrl” as part of their URL</p><blockquote><p>allinurl - 操作符，告诉谷歌在URL中搜索所有提供的关键字。</p><p>例如：allinurl:ReturnUrl，它可以搜索URL中含有 “ReturnUrl “的网页。</p></blockquote><p><strong>site</strong> - operator that tells to only return results that are on specific domain or a web site<br>Example: site:example.com which searches for web pages from example.com</p><blockquote><p>site - 操作符，指示只返回特定域名或网站上的结果。<br>例如：site:example.com可以搜索example.com的网页。</p></blockquote><p><strong>“”</strong> - double quotes are a special symbols that used to indicate to search for exact combination of words and symbols within quotes</p><blockquote><p>“”–双引号是一种特殊的符号，用来表示搜索引号内的单词和符号的精确组合。</p></blockquote><p>*- The asterisk is a wildcard that represents one or more words</p><blockquote><p>*- 星号是通配符，代表一个或多个词。</p></blockquote><p>Using these allows us to search for certain tell tale signs of potential Open Redirect:</p><p>We can look for the general presence of “http” or “https” within parameter area of GET request. For instance:</p><blockquote><p>使用这些可以让我们搜索某些潜在的开放重定向的迹象：</p><p>我们可以在GET请求的参数区域中寻找 “http “或 “https “的一般存在。例如，我们可以在GET请求的参数区寻找 “http “或 “https “的存在:</p></blockquote><p>allinurl:%3Dhttps*</p><p> allinurl:%253Dhttps* </p><p>allinurl:%3Dhttp* </p><p>allinurl:%253Dhttp*</p><p>We can also search for specific, common words related to forwarding within parameter area of GET request. For instance:</p><blockquote><p>我们还可以在GET请求的参数区中搜索与转发相关的特定的、常用的词。比如说:</p></blockquote><p>allinurl:”&lt;keyword&gt;=https” </p><p>allinurl:”&lt;keyword&gt;=http” </p><p>allinurl:&lt;keyword&gt;=https </p><p>allinurl:&lt;keyword&gt;=http </p><p>allinurl:&lt;keyword&gt;%3Dhttps </p><p>allinurl:”&lt;keyword&gt;%3Dhttps* “</p><p>allinurl:&lt;keyword&gt;%253Dhttps </p><p>allinurl:”&lt;keyword&gt;%253Dhttps* “</p><p>…</p><p>Instead of &lt;keyword&gt;, we would use one of the following words typical of redirects:RelayState, ReturnUrl, RedirectUri, Return, Return_url, Redirect, Redirect_uri, Redirect_url,RedirectUrl, Forward, ForwardUrl, Forward_URL, SuccessUrl, Redir, Exit_url, Destination. This is by no means a comprehensive list of keywords. You can find more by analyzing results from the more general queries looking for a URL in the parameter section of the GET request.</p><blockquote><p>我们将使用以下典型的重定向词来代替\keyword&gt;：RelayState，ReturnUrl，RedirectUri，Return，Return_url，Redirect，Redirect_uri，Redirect_url，RedirectUrl，Forward，ForwardUrl，Forward_URL，SuccessUrl，Redir，Exit_url，Destination。这绝不是一个全面的关键词列表。你可以通过分析GET请求的参数部分中寻找URL的更一般查询的结果来找到更多。</p></blockquote><p>For targeted searches, you can add “site:<domain_name>“ to the end of your Google Queries. This can help you identify Open Redirect vulnerabilities on your own website.</domain_name></p><blockquote><p>对于有针对性的搜索，你可以在Google查询的结尾添加 “site:<domain_name>“。这可以帮助你找出自己网站上的Open Redirect漏洞。</domain_name></p></blockquote><p>Using this simple search technique you can find dozens of Open Redirect vulnerabilities within minutes. List of vulnerable websites includes banking websites, websites of international corporations, trusted companies, beloved projects and numerous websites of smaller organizations. As an additional bonus, each time Google’s web crawler comes across new website that has Open Redirect, we will get updated results through our queries.</p><blockquote><p>使用这种简单的搜索技术，你可以在几分钟内找到几十个Open Redirect漏洞。易受攻击的网站列表包括银行网站、国际公司网站、值得信赖的公司、心爱的项目和众多小型组织的网站。作为额外的奖励，每次Google的网络爬虫遇到有Open Redirect的新网站，我们都会通过查询得到更新的结果。</p></blockquote><p>The best way to avoid Open Redirect vulnerability is to avoid redirecting based on parameter controlled by users or supplied through GET method. If redirecting is unavoidable,it can be dealt with by validating a redirect target and sanitizing it using whitelist of approved URLs.</p><blockquote><p>避免Open Redirect漏洞的最好方法是避免基于用户控制的参数或通过GET方法提供的重定向。如果重定向是不可避免的，可以通过验证重定向目标，并使用批准的URL白名单对其进行消毒处理。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http重定向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何正确删除linux分区</title>
      <link href="/2020/08/19/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%88%A0%E9%99%A4linux%E5%88%86%E5%8C%BA/"/>
      <url>/2020/08/19/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%88%A0%E9%99%A4linux%E5%88%86%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<p> 原因：</p><p>​         当初装双系统低估了win10的占量，高估了linux的占量。导致win10空间急速下降，之后找到了cmd终端替代品。就打算删除linux分区，（win10并不识别linux分区）就直接在win10自带的磁盘管理系统，直接删除了分区。结果导致开机无法正常启动系统</p><p>解决办法：</p><p>1、启动进入Windows系统</p><p>2、下载Mbrfix</p><p>3、解压到C盘根目录下 </p><p>4、打开Windows命令行，也就是开始－运行－打入cmd<a id="more"></a></p><p>5、在命令行下，键入：cd，然后回车</p><p>在键入：mbrfix /drive 0 fixmbr /yes回车</p><p>6、进入磁盘管理器，把将要删除的Ubuntu分区删除，这里说明一下，其实大家都知道哈，就是Windows里边有ntfs和fat格式，所以非Windows格式的分区即是Ubuntu的分区。</p><p>7、右键新的分区，点击创建新的逻辑分区。</p><p>8、重启，ok！</p><p>如果说你像我一样已经删除了linux，无法进入，而我的做法是在安装一遍linux系统，然后在像上面操作一样</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vuepress上手</title>
      <link href="/2020/08/18/vuepress%E4%B8%8A%E6%89%8B/"/>
      <url>/2020/08/18/vuepress%E4%B8%8A%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<p>1.创建并进入一个新目录</p><pre><code class="bash">mkdir xxx &amp;&amp; cd xxx</code></pre><p>2.选择喜欢的包管理器进行初始化</p><pre><code class="bash">yarn init &amp; # npm init</code></pre><p>3.将Vuepress安装为本地依赖(不推荐全局安装)</p><pre><code class="bash">yarn add -D vuepress &amp; # npm i -D vuepress</code></pre><p>4.创建第一篇文档<a id="more"></a></p><pre><code class="bash">mkdir docs &amp;&amp; echo '# Hello worde' &gt; docs/README.md</code></pre><p>5.在packgae.json中添加scripts</p><pre><code class="bash">{  "scripts": {    "docs:dev": "vuepress dev docs",    "docs:build": "vuepress build docs"  }}</code></pre><p>5.在本地启动服务器</p><pre><code class="bash">yarn docs:dev &amp; # npm run docs:dev</code></pre><p>6.在docs中新建<code>.vuepress</code>文件夹及config.js文件</p><pre><code class="bash">mkdir .vuepress &amp;&amp; cd .vuepress/ &amp;&amp; touch config.js</code></pre><p>7.在<code>.vuepress</code>文件夹新建<code>public</code></p><pre><code class="bash">mkdir public  // 用来放网页标签的图标</code></pre><p>8.在config.js中写入</p><pre><code class="js">module.exports = {    title: '名字',    // 网页标题    description: 'xxx',  // 随便起    // 注入到当前页面的 HTML &lt;head&gt; 中的标签    head: [      ['link', { rel: 'icon', href: '/favicon.ico' }], // 增加一个自定义的 favicon(网页标签的图标)    ],    base: '/xxx/', // github仓库地址    markdown: {      lineNumbers: true // 代码块显示行号    },    themeConfig: {      sidebarDepth: 2, // e'b将同时提取markdown中h3 和 h3 标题，显示在侧边栏上。      lastUpdated: 'Last Updated',// 文档更新时间：每个文件git最后提交的时间   //   主页导航栏      nav:[        { text: 'xxx', link: 'xxx' }, // link处添外部链接（仓库地址码云或者github）        // 下拉列表        {          text: 'xxx',          items: [            { text: 'xxx', link: 'xxx' },            {              text: 'xxx',              link: 'xxxx'            }          ]      }       ],        // 侧边栏        sidebar: [          ['/', 'xxx'],    // README.md          {            title: 'xxx',            collapsable: false,            children:[                ['/help/one.md', '标题名'],            ]          },             ]          }    }</code></pre><p>9.在你的项目(根目录)中创建一个<code>deploy.sh</code>文件（请自行判断去掉高亮行的注释）</p><pre><code class="sh">#!/usr/bin/env sh# 确保脚本抛出遇到的错误set -e# 生成静态文件npm run docs:build# 进入生成的文件夹cd docs/.vuepress/dist# 如果是发布到自定义域名# echo 'www.example.com' &gt; CNAMEgit initgit add -Agit commit -m 'deploy'# 如果发布到 https://&lt;USERNAME&gt;.github.io# git push -f git@github.com:&lt;USERNAME&gt;/&lt;USERNAME&gt;.github.io.git master# 如果发布到 https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;# git push -f git@github.com:&lt;USERNAME&gt;/&lt;REPO&gt;.git mastercd -</code></pre><p>10.写完之后运行sh打包上传</p><pre><code class="bash">sh deploy.sh</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vuepress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cygwin安装配置</title>
      <link href="/2020/08/09/Cygwin%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/08/09/Cygwin%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cygwin.com/" target="_blank" rel="noopener">Cygwin</a>是：</p><ul><li><p>GNU和开放源代码工具的大量集合，它们提供的功能类似于 Windows上的 Linux发行版。</p></li><li><p>提供实质性POSIX API功能的DLL（cygwin1.dll）。<a id="more"></a></p>        <h2 id="安装">          <a href="#安装" class="heading-link"><i class="fas fa-link"></i></a><a href="#安装" class="headerlink" title="安装"></a>安装</h2>              <h3 id="1-下载Cygwin">          <a href="#1-下载Cygwin" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-下载Cygwin" class="headerlink" title="1.下载Cygwin"></a>1.下载Cygwin</h3>      <img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/下载Cygwin.png" style="zoom: 50%;"></li></ul>        <h3 id="2-打开安装包">          <a href="#2-打开安装包" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-打开安装包" class="headerlink" title="2.打开安装包"></a>2.打开安装包</h3>      <img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/下一步.png" style="zoom: 67%;">        <h3 id="3-按需选择">          <a href="#3-按需选择" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-按需选择" class="headerlink" title="3.按需选择"></a>3.按需选择</h3>      <img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/选择.png" style="zoom:67%;">        <h3 id="4-选择安装目录">          <a href="#4-选择安装目录" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-选择安装目录" class="headerlink" title="4.选择安装目录"></a>4.选择安装目录</h3>      <img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/安装目录.png" style="zoom: 80%;">        <h3 id="5-选择本地目录（里面文件可以删除）">          <a href="#5-选择本地目录（里面文件可以删除）" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-选择本地目录（里面文件可以删除）" class="headerlink" title="5.选择本地目录（里面文件可以删除）"></a>5.选择本地目录（里面文件可以删除）</h3>      <img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/创建本地目录.png" style="zoom: 80%;">        <h3 id="6-设置代理">          <a href="#6-设置代理" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-设置代理" class="headerlink" title="6.设置代理"></a>6.设置代理</h3>      <img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/设置代理png.png" style="zoom:80%;">        <h3 id="7-选择镜像源">          <a href="#7-选择镜像源" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-选择镜像源" class="headerlink" title="7.选择镜像源"></a>7.选择镜像源</h3>      <img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/镜像源的选择.png" style="zoom:80%;">        <h3 id="8-下一步">          <a href="#8-下一步" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-下一步" class="headerlink" title="8.下一步"></a>8.下一步</h3>      <img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/弹出框.png" style="zoom: 50%;">        <h3 id="9-下一步">          <a href="#9-下一步" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-下一步" class="headerlink" title="9.下一步"></a>9.下一步</h3>              <h3 id="10-完成">          <a href="#10-完成" class="heading-link"><i class="fas fa-link"></i></a><a href="#10-完成" class="headerlink" title="10.完成"></a>10.完成</h3>              <h2 id="配置-需要安装（dos2unix、wget、lynx）">          <a href="#配置-需要安装（dos2unix、wget、lynx）" class="heading-link"><i class="fas fa-link"></i></a><a href="#配置-需要安装（dos2unix、wget、lynx）" class="headerlink" title="配置 需要安装（dos2unix、wget、lynx）"></a>配置 需要安装（dos2unix、wget、lynx）</h2>              <h3 id="还是打开安装程序按照安装过程到第8步-先不要关闭！！！先不要关闭！！！先不要关闭！！！">          <a href="#还是打开安装程序按照安装过程到第8步-先不要关闭！！！先不要关闭！！！先不要关闭！！！" class="heading-link"><i class="fas fa-link"></i></a><a href="#还是打开安装程序按照安装过程到第8步-先不要关闭！！！先不要关闭！！！先不要关闭！！！" class="headerlink" title="还是打开安装程序按照安装过程到第8步(先不要关闭！！！先不要关闭！！！先不要关闭！！！)"></a>还是打开安装程序按照安装过程到第8步(先不要关闭！！！先不要关闭！！！先不要关闭！！！)</h3>      <img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/full.png" style="zoom:67%;"><p>先从github克隆<a href="https://github.com/transcode-open/apt-cyg" target="_blank" rel="noopener">apt-cyg</a>  [git clone <span class="exturl"><a class="exturl__link" href="https://github.com/transcode-open/apt-cyg]" target="_blank" rel="noopener">https://github.com/transcode-open/apt-cyg]</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>   <font color="#c91627" size="5">PS：在Cygwin上克隆</font></p><p>cd apt-cyg   【进入apt-cyg目录】</p><p>install  apt-cyg   /bin    【将apt-cyg安装到/bin目录下】</p><p>下载东西【例如：apt-cyg install vim】，如果不出意外会出报错</p><blockquote><p>/usr/bin/apt-cyg:行25: $’\r’: 未找到命令 </p><p>/usr/bin/apt-cyg:行121: 未预期的符号 <code>$'{\r'' 附近有语法错误</code></p><p> <code>'usr/bin/apt-cyg:行121:</code>function wget {</p></blockquote>        <h3 id="需要下载dos2unix">          <a href="#需要下载dos2unix" class="heading-link"><i class="fas fa-link"></i></a><a href="#需要下载dos2unix" class="headerlink" title="需要下载dos2unix"></a>需要下载dos2unix</h3>      <img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/dos2unix.png" style="zoom:67%;"><p><strong>1.在终端输入cd ../..  &amp;&amp; ls</strong></p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E9%87%8D%E6%96%B0%E7%BC%96%E8%AF%91.png" alt=""></p><ol start="2"><li><strong>cd usr/bin/</strong></li></ol><p>在终端输入 dos2unix apt-cyg会显示dos2unix: 正在转换文件 apt-cyg为Unix格式…，然后在运行apt-cyg install vim 就不会报上面的错误</p><p>但是下载的时候会显示</p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/wget.png" alt=""></p><p>或者  lynx: 未找到命令</p><p>需要安装lynx和安装wget  和下载doswunix一样</p><p>之后下一步下一步</p>        <h2 id="QAQ">          <a href="#QAQ" class="heading-link"><i class="fas fa-link"></i></a><a href="#QAQ" class="headerlink" title="QAQ:"></a>QAQ:</h2>              <h3 id="1-如何切换zsh？">          <a href="#1-如何切换zsh？" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-如何切换zsh？" class="headerlink" title="1.如何切换zsh？"></a>1.如何切换zsh？</h3>      <p> vim  .bash_profile</p><p>在最后一行加入exec zsh 保存退出</p><p>【ps： 按i  最后一行输入exec zsh  按Esc  按:输入wq 按enter】</p><p>重新打开</p>        <h3 id="2-切换zsh重新打开乱码？">          <a href="#2-切换zsh重新打开乱码？" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-切换zsh重新打开乱码？" class="headerlink" title="2.切换zsh重新打开乱码？"></a>2.切换zsh重新打开乱码？</h3>      <p>需要安装oh-my-zsh</p><p><a href="https://ohmyz.sh/" target="_blank" rel="noopener">官网</a>或者</p><p>链接：<span class="exturl"><a class="exturl__link" href="https://pan.baidu.com/s/1pKsMhbz1ahx1F9fWj57k_g" target="_blank" rel="noopener">https://pan.baidu.com/s/1pKsMhbz1ahx1F9fWj57k_g</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>提取码：obva   </p><p>注：百度盘不一定是最新的(但可以更新到最新)</p>        <h3 id="3-如何更新oh-my-zsh？">          <a href="#3-如何更新oh-my-zsh？" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-如何更新oh-my-zsh？" class="headerlink" title="3.如何更新oh-my-zsh？"></a>3.如何更新oh-my-zsh？</h3>      <p>omz update</p>        <h3 id="4-如何查看oh-my-zsh安装成功？">          <a href="#4-如何查看oh-my-zsh安装成功？" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-如何查看oh-my-zsh安装成功？" class="headerlink" title="4.如何查看oh-my-zsh安装成功？"></a>4.如何查看oh-my-zsh安装成功？</h3>      <p>如下图显示就安装成功了</p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/oh-my-zsh.png" alt=""></p><p>失败请安装git 【apt-cyg install git】</p>        <h3 id="5-主题如何获取？">          <a href="#5-主题如何获取？" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-主题如何获取？" class="headerlink" title="5.主题如何获取？"></a>5.主题如何获取？</h3>      <p><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes" target="_blank" rel="noopener">主题地址</a></p>        <h3 id="6-如何更改zsh主题？">          <a href="#6-如何更改zsh主题？" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-如何更改zsh主题？" class="headerlink" title="6.如何更改zsh主题？"></a>6.如何更改zsh主题？</h3>      <p>终端输入vim  .zshrc</p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E4%B8%BB%E9%A2%98%E5%90%8D%E7%A7%B0.png" alt=""></p><p>箭头处更改主题名称</p>        <h3 id="7-为什么不能输入-如何保存退出？">          <a href="#7-为什么不能输入-如何保存退出？" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-为什么不能输入-如何保存退出？" class="headerlink" title="7.为什么不能输入/如何保存退出？"></a>7.为什么不能输入/如何保存退出？</h3>      <p>按 i 进入编辑   更改完成后 按 ESC   然后按 :  输入wq 按Enter 重新启动</p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/i.png" alt=""></p><p>ps：别忘了按ESC</p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/wq.png" alt=""></p>        <h3 id="8-如何更改Cygwin语言设置？">          <a href="#8-如何更改Cygwin语言设置？" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-如何更改Cygwin语言设置？" class="headerlink" title="8.如何更改Cygwin语言设置？"></a>8.如何更改Cygwin语言设置？</h3>      <p>终端任意位置点击鼠标右键</p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/设置.png" style="zoom: 55%;"><p>点击Options （看图UI language选择语言） </p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/语言.png"><p>选择（zh_CN）完之后点击Apply</p>        <h3 id="9-如何调整窗口大小（不是关闭恢复原状）？">          <a href="#9-如何调整窗口大小（不是关闭恢复原状）？" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-如何调整窗口大小（不是关闭恢复原状）？" class="headerlink" title="9.如何调整窗口大小（不是关闭恢复原状）？"></a>9.如何调整窗口大小（不是关闭恢复原状）？</h3>      <p>设置 -窗口（调整窗口到合适大小）-点击当前大小—然后应用</p>        <h3 id="10-如何打开Windows中的文件-文件夹？">          <a href="#10-如何打开Windows中的文件-文件夹？" class="heading-link"><i class="fas fa-link"></i></a><a href="#10-如何打开Windows中的文件-文件夹？" class="headerlink" title="10.如何打开Windows中的文件/文件夹？"></a>10.如何打开Windows中的文件/文件夹？</h3>      <p><em>cygstart</em>  xxx</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 应用与插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cygwin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何部署vuepress</title>
      <link href="/2020/08/08/%E5%A6%82%E4%BD%95%E9%83%A8%E7%BD%B2vuepress/"/>
      <url>/2020/08/08/%E5%A6%82%E4%BD%95%E9%83%A8%E7%BD%B2vuepress/</url>
      
        <content type="html"><![CDATA[<p>  在项目中，创建一个<code>deploy.sh</code>文件（请自行判断，去掉高亮行的注释）</p><pre><code class="sh">#!/usr/bin/env sh# 确保脚本抛出遇到的错误set -e# 生成静态文件npm run docs:build# 进入生成的文件夹cd docs/.vuepress/dist# 如果是发布到自定义域名# echo 'www.example.com' &gt; CNAMEgit initgit add -Agit commit -m 'deploy'# 如果发布到 https://&lt;USERNAME&gt;.github.io# git push -f git@github.com:&lt;USERNAME&gt;/&lt;USERNAME&gt;.github.io.git master# 如果发布到 https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;# git push -f git@github.com:&lt;USERNAME&gt;/&lt;REPO&gt;.git mastercd -</code></pre><p><strong>如何在windows下运行sh？</strong></p><p>如果有Git则直接打开终端输入<code>sh xxx.sh</code>(ps:xxx为你起得名字)</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vuepress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sandboxie沙盒</title>
      <link href="/2020/08/03/Sandboxie%E6%B2%99%E7%9B%92/"/>
      <url>/2020/08/03/Sandboxie%E6%B2%99%E7%9B%92/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl"><a class="exturl__link" href="https://sandboxie-plus.com/Sandboxie" target="_blank" rel="noopener">Sandboxie</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> ，是一款从底层操作系统层面，将真实系统环境与虚拟系统隔离，以防止个人数据、程序等不受未知程序或有风险操作影响的<strong>Windows端沙盘/沙箱软件。</strong></p><p><span class="exturl"><a class="exturl__link" href="https://github.com/sandboxie-plus/Sandboxie/releases" target="_blank" rel="noopener">GitHub</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>下载</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 应用与插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 沙盒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EndNote软件</title>
      <link href="/2020/08/02/EndNote%E8%BD%AF%E4%BB%B6/"/>
      <url>/2020/08/02/EndNote%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p> 借助 EndNote X9 更智能地研究，告别设置文献格式、全文查找、搜索和整理参考书目之类的繁琐工作</p><p>整理pdf以及word或者文献<a href="https://buy.endnote.com/1603/purl-buy" target="_blank" rel="noopener">EndNote X9</a> [官网需要购买PS：贵。淘宝：不能升级（废且51元）]<font color="#d65071" size="5">都不建议购买,除非你确定买来不吃灰</font></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 应用与插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EndNote </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当代心理学观点</title>
      <link href="/2020/08/02/%E5%BD%93%E4%BB%A3%E5%BF%83%E7%90%86%E5%AD%A6%E8%A7%82%E7%82%B9/"/>
      <url>/2020/08/02/%E5%BD%93%E4%BB%A3%E5%BF%83%E7%90%86%E5%AD%A6%E8%A7%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>​          当代心理学观点是一种观察心理学议题的方式或者取向，并在五个观点的基础上进行折中取向。生物观点以生物取向来区辨出行为和心理现象下的生物神经过程，探究行为与心理历程的神经生物过程的研究取向。行为观点则是以条件作用与强化作用观点来探究可观察行为的研究取向如：S-R（刺激-反应）。认知观点回归认知基础但并非以内省法为基础，而是以两种假设为前提（1.心智历程的研究可着完全了解有机体的所作所为2.心智历程的研究可着眼于对特殊行为的客观观察，并以内在心智历程观点解释。）来探索诸如知觉、记忆、决策于问题解决等心理过程，以及它们与行为关系。心理分析则是以认知概念与生物基本本能的想法结合，以源自性与攻击冲动的无意识观点，来探索，并提出大多数行为的产生来自无意识过程，即人们不自知但却可影响其行为的思想、恐惧和欲望等。</p><p>​       主观论者以人们主动建构的主观现实，来探究行为与心理历程，并主张人类行为是他所知觉的世界，而非客观世界。【朴素的现实主义⑴】 与认知论（格式塔）来对抗行为论的狭缢论点</p><p>⑴指人们会倾向于将自己建构好的、主观的现实，理解为忠实地表现了客观世界</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 爱好心理学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-Redux技术要点</title>
      <link href="/2020/08/01/React-Redux%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9/"/>
      <url>/2020/08/01/React-Redux%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/react.jpg" alt=""></p><a id="more"></a><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E7%BB%84%E5%BB%BA%E9%80%9A%E8%AE%AF.jpg" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>涂鸦？</title>
      <link href="/2020/07/31/%E6%B6%82%E9%B8%A6%EF%BC%9F/"/>
      <url>/2020/07/31/%E6%B6%82%E9%B8%A6%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E7%9B%86%E6%A0%BD.jpg" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活与话 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Krita软件</title>
      <link href="/2020/07/29/Krita%E8%BD%AF%E4%BB%B6/"/>
      <url>/2020/07/29/Krita%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl"><a class="exturl__link" href="https://krita.org/zh/" target="_blank" rel="noopener">Krita </a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 是一款由社区驱动的自由开源数字绘画软件，可免费使用，无任何商用限制，让每一位画师都可以随心所欲地表达创意。</p><ul><li><p>适合：概念草图、插画、漫画、动画、接景和 3D 贴图</p></li><li><p>支持：数位板、压感、防抖、图层、滤镜、色彩管理等</p></li><li><p>中文：软件、文档和网站内建官方中文版</p><p><a href="https://docs.krita.org/zh_CN/" target="_blank" rel="noopener">Krita 4.3文档</a></p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 应用与插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Krita </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何建立自己的知识体系?</title>
      <link href="/2020/07/28/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
      <url>/2020/07/28/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.jpg" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎样才算会读书？</title>
      <link href="/2020/07/28/%E6%80%8E%E6%A0%B7%E6%89%8D%E7%AE%97%E4%BC%9A%E8%AF%BB%E4%B9%A6%EF%BC%9F/"/>
      <url>/2020/07/28/%E6%80%8E%E6%A0%B7%E6%89%8D%E7%AE%97%E4%BC%9A%E8%AF%BB%E4%B9%A6%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>类比一下这个问题：“怎么才算会吃饭？”</p><p>一口尝出七八味作料算会吃（<strong>对书本理解非常透彻</strong>），还是吃完之后能舌灿如花地点评（<strong>善于写各种书评</strong>）算会吃？<br>吃完了马上到厨房COPY一份几乎尝不出差别的复制品（<strong>能够学以致用指导人生</strong>）算会吃，还是悠悠道来这道菜的悠久历史（<strong>善于触类旁通</strong>）才算会吃？</p><p>活到现在基本健康的人们都出来回答一下，你觉得怎么才算会吃饭？</p><p>读个书而已，多大点事啊。</p><p>知乎对读书的矫枉过正也不是一两天了~但是读书不过就是读书啊，想要读成博士或者想要读成大师，想要通透地理解一本书，跟“会读书”应该不是一个概念吧。而且呀，知行合一不是那么容易做到的，古人说<u>“知易行难”</u>诚不欺我也啊。</p><p>读书跟吃饭都是个动宾短语，一个是供养精神，一个是供养身体，真的没必要搞得跟参拜一样。能在西餐厅礼仪万方地吃饭，不意味着在大排档站着聊天啃串的人就不会吃饭了。</p><p>邯郸学步大概就是说这个状态。有人善于走猫步，漂亮潇洒高端大气，但这不意味着别人都不会走路了。而且我也不觉得只有那样才叫“会走路”。</p><p><strong>想读书，就读；跟饿了就吃饭一样。</strong></p></blockquote><p>&lt;怎样才算读书?&gt; <a href="https://www.zhihu.com/question/21293180" target="_blank" rel="noopener">知乎</a>  </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯COS+PicGo</title>
      <link href="/2020/07/28/%E8%85%BE%E8%AE%AFCOS-PicGo/"/>
      <url>/2020/07/28/%E8%85%BE%E8%AE%AFCOS-PicGo/</url>
      
        <content type="html"><![CDATA[<h2 id="1-腾讯COS-PicGo">          <a href="#1-腾讯COS-PicGo" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-腾讯COS-PicGo" class="headerlink" title="1.腾讯COS+PicGo"></a>1.腾讯COS+PicGo</h2>      <p>1.1登录<a href="https://cloud.tencent.com/" target="_blank" rel="noopener">腾讯云</a>搜索COS（对象存储）</p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/Snipaste_2020-07-28_12-57-59.png" alt=""></p><p>1.2点击立即使用<img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/Snipaste_2020-07-28_13-00-06.png" alt=""></p><p>1.3之后是实名认证之类的（微信）</p><p>1.4进入对象存储桶列表创建存储桶<a id="more"></a></p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/Snipaste_2020-07-28_13-03-31.png" alt=""></p><p>1.5填写(看情况填写)</p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/Snipaste_2020-07-28_13-15-09.png" alt=""></p><p>1.6申请API密钥</p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/Snipaste_2020-07-28_13-17-29.png" alt=""></p><p>会提示（继续使用）</p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/Snipaste_2020-07-28_13-18-19.png" alt=""></p><p>新建密钥</p>        <h2 id="2-在PicGo填写">          <a href="#2-在PicGo填写" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-在PicGo填写" class="headerlink" title="2.在PicGo填写"></a>2.在PicGo填写</h2>      <p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/Snipaste_2020-07-28_13-26-05.png" alt=""></p><p>注：COS版本选择V5（我选V4不能上传）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 应用与插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github图床+PicGo</title>
      <link href="/2020/07/27/Github%E5%9B%BE%E5%BA%8A-PicGo/"/>
      <url>/2020/07/27/Github%E5%9B%BE%E5%BA%8A-PicGo/</url>
      
        <content type="html"><![CDATA[<h2 id="1-新建图床仓库">          <a href="#1-新建图床仓库" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-新建图床仓库" class="headerlink" title="1.新建图床仓库"></a>1.新建图床仓库</h2>      <p>  1.1 在Github中创建一个仓库</p><p>  1.2在Github生成一个token（给PicGo使用）<a id="more"></a></p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E8%AE%BE%E7%BD%AE.jpg" alt="image"></p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/Snipaste_2020-07-27_19-35-02.png" alt=""></p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/Snipaste_2020-07-27_19-36-52.png" alt=""></p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/Snipaste_2020-07-27_19-40-03.png" alt=""></p><p>1.3之后点最下面的<button>Generate token</button>,会生成一串token，注：生成的token最好保存到本地，因为下次再进GitHub的时候，这个token就不再显示了。</p>        <h2 id="2-PicGo客户端">          <a href="#2-PicGo客户端" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-PicGo客户端" class="headerlink" title="2.PicGo客户端"></a>2.PicGo客户端</h2>      <p><span class="exturl"><a class="exturl__link" href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">PicGo下载</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/Snipaste_2020-07-27_20-13-48.png" alt=""></p><p>PS:仓库名就是github用户名/仓库名，前/后什么都不加。分支默认master。上一部生成的token。存储路径可写可不写</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 应用与插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue知识体</title>
      <link href="/2020/07/27/vue%E7%9F%A5%E8%AF%86%E4%BD%93/"/>
      <url>/2020/07/27/vue%E7%9F%A5%E8%AF%86%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/123.jpg" alt="image"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html语义化（基本）</title>
      <link href="/2020/07/24/html%E8%AF%AD%E4%B9%89%E5%8C%96/"/>
      <url>/2020/07/24/html%E8%AF%AD%E4%B9%89%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>  根据内容的结构化，选择合适的标签</p><p>优点：</p><p>有利于SEO。有利于开发与维护。有利于用户阅读，在丢失样式时，能让页面呈现清晰的结构。方便设备解读</p><p>扩展：</p><p>html5是什么？</p><p>是html标准的最新演进的版本，多样化，功能更强大</p><a id="more"></a><p>新特征：</p><p>1.语义特性</p><p>2.多媒体</p><p>3.图像效果</p><p>4.设备兼容性</p><p>5.离线或存储</p><p>6.性能与集成特性</p><p>css选择器</p><p>通配符选择器 。 类选择器。 id选择器 。伪类选择器 。 后代选择器 。 属性选择器</p><p>！important -行内样式 - id选择器 - 类选择器 - 伪类选择器 - 通配符选择器 - 继承 - 默认</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法与面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rem和em的区别</title>
      <link href="/2020/07/24/rem%E5%92%8Cem%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/07/24/rem%E5%92%8Cem%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>   rem：表示根元素字体的大小 em：表示父元素（fontsize）大小</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法与面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>W3C标准是什么</title>
      <link href="/2020/07/21/W3C%E6%A0%87%E5%87%86%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2020/07/21/W3C%E6%A0%87%E5%87%86%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>1.结构标准，代表语言是xHTML</p><p>2.表现标准，代表语言是CSS</p><p>3.动作标准，代表语言是JavaScrip</p><p>除了以上的标准，还有XML，DOM标准</p><a id="more"></a><p>扩展：</p><p>XHTML</p><p>可扩展超文本标记语言，是一种<span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/标记语言" target="_blank" rel="noopener">标记语言</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，表现方式与超文本标记语言（HTML）类似，不过语法上更加严格。</p><p>XML</p><p>   XML 被设计用来传输和存储数据。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法与面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVC开发思想</title>
      <link href="/2020/07/21/MVC%E5%BC%80%E5%8F%91%E6%80%9D%E6%83%B3/"/>
      <url>/2020/07/21/MVC%E5%BC%80%E5%8F%91%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p>MVC即Model、View、Controller即模型、视图、控制器。是一种软件架构的思想，将一个软件按照模型、视图、控制器进行划分。模型用来封装业务逻辑，视图用来实现表示逻辑，而控制器用来协调模型与视图</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法与面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言学习思路</title>
      <link href="/2020/07/21/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%B7%AF/"/>
      <url>/2020/07/21/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>1）数据类型：<br>需要死记硬背。其中–浮点数表示法 需要学习下 程度达到能理解就行<br>二进制 十进制 十六进制 8进制也需要了解<br>整数的负数表示方法<br>2) 判断 分支 循环 和 数组<br>会了数组和循环后,就可以学基础的三个排序算法: 选择 冒泡 插入,其中冒泡在吧里讨论最广泛,有很多问题出现</p><p>然后会接触到 随机函数，时间函数，和 个别的数学函数<br>3) 基本的输入和输出函数<br>printf 和 scanf 需要非常熟悉, 同样有很多问题会拿出来讨论<br>4) 流程图 以及 NS流程图的画法<br>5) 函数 以及 函数调用栈<br>6) 字符串、字符串输入输出、字符串常用函数<br>7) 指针：<br>需要多练练，需要弄得很懂。字符串的几个函数和指针的联系很紧，尝试用自己的方法实现字符串的几个常用函数，对理解指针会很有帮助。</p><p>8) 文件和文件输入输出<br>9) 结构体 联合体<br>10) 数据结构和算法中的基础部分 —链表</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 语言与Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git命令</title>
      <link href="/2020/07/19/Git%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/07/19/Git%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>  git branch &lt;分支名&gt;     新建分支</p><p>  git checkout &lt;分支名&gt;    切换分支</p><p>合并分支：</p><p>git merge一:</p><div class="table-container"><table><thead><tr><th>git checkout -b &lt;分支名&gt;</th><th>新建并切换分支名</th></tr></thead><tbody><tr><td>git commit -m ‘注释’</td><td>提交注释</td></tr><tr><td>git push origin &lt;分支名&gt;</td><td>上传</td></tr><tr><td>git checkout master</td><td>切换主分支</td></tr><tr><td>git merge &lt;分支名&gt;</td><td>合并分支</td></tr></tbody></table></div><p>git rebase二： </p><div class="table-container"><table><thead><tr><th align="left">git checkout -b &lt;分支名&gt;</th><th>新建并切换分支名</th></tr></thead><tbody><tr><td align="left">git commit -m ‘注释’</td><td>提交注释</td></tr><tr><td align="left">git checkout master</td><td>切换主分支</td></tr><tr><td align="left">git commit -m ‘注释’</td><td>提交注释</td></tr><tr><td align="left">git checkout &lt;分支名&gt;</td><td>切换分支</td></tr><tr><td align="left">git rebase master</td><td>合并到主分支</td></tr></tbody></table></div><p>相对引用：</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 语言与Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>话十肆</title>
      <link href="/2020/07/14/%E8%AF%9D%E5%8D%81%E8%82%86/"/>
      <url>/2020/07/14/%E8%AF%9D%E5%8D%81%E8%82%86/</url>
      
        <content type="html"><![CDATA[<p>我们没有人可以凭借与众不同而与众不同，因为与众不同是你所能做的最与众不同的事情，因为它是一件会自然而然地发生在每个人身上的事情。所以，相比“做一个与众不同的人”,我们或许更应该说：“尽情地做个显而易见的混蛋吧，因为与众不同已经让别人占有了。”——已经被所有人占有了，这可真讽刺呀！</p><p>  或者，我们应该把这句话改为“不要甘于平庸，要做一个最平庸的人”。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活与话 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 话 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux美化</title>
      <link href="/2020/07/14/Linux%E7%BE%8E%E5%8C%96/"/>
      <url>/2020/07/14/Linux%E7%BE%8E%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>主题图标网址：<span class="exturl"><a class="exturl__link" href="https://www.pling.com/browse/cat/381/order/latest/" target="_blank" rel="noopener">https://www.pling.com/browse/cat/381/order/latest/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>管理界面：<span class="exturl"><a class="exturl__link" href="https://github.com/elementary-tweaks/elementary-tweaks" target="_blank" rel="noopener">https://github.com/elementary-tweaks/elementary-tweaks</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 语言与Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推理小说</title>
      <link href="/2020/07/11/%E6%8E%A8%E7%90%86%E5%B0%8F%E8%AF%B4/"/>
      <url>/2020/07/11/%E6%8E%A8%E7%90%86%E5%B0%8F%E8%AF%B4/</url>
      
        <content type="html"><![CDATA[<ul><li><input checked="" disabled="" type="checkbox"> 怪盗的二十面相</li><li><input disabled="" type="checkbox"> 魔术师</li><li><input checked="" disabled="" type="checkbox"> 八声甘州</li><li><input disabled="" type="checkbox"> 蜘蛛男（3/10）</li><li><input disabled="" type="checkbox"> 钟表馆事件<a id="more"></a></li><li><input disabled="" type="checkbox"> 血字研究</li><li><input disabled="" type="checkbox"> 四签名</li><li><input disabled="" type="checkbox"> 红发会</li><li><input disabled="" type="checkbox"> 跳舞的小人</li><li><input disabled="" type="checkbox"> 北方夕鹤2/3杀人事件</li><li><input checked="" disabled="" type="checkbox"> 占星术杀人魔法</li><li><input disabled="" type="checkbox"> 东方快车谋杀事件</li><li><input disabled="" type="checkbox"> 尼罗河上的惨案</li><li><input disabled="" type="checkbox"> 无人生还</li><li><input disabled="" type="checkbox"> 斜屋犯罪</li><li><input disabled="" type="checkbox"> 异邦骑士</li><li><input disabled="" type="checkbox"> 奇想，天动</li><li><input disabled="" type="checkbox"> 克莱因壶</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>词</title>
      <link href="/2020/07/10/%E8%AF%8D/"/>
      <url>/2020/07/10/%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th>拼音</th><th>词解释</th></tr></thead><tbody><tr><td>lian pian lei du（2 1 3 2）</td><td></td></tr><tr><td>连篇累牍</td><td>篇幅过多，文辞冗(rong)长</td></tr><tr><td>an cun (4 3)</td><td></td></tr><tr><td>暗忖</td><td>思量，盘算，推算</td></tr><tr><td>ao sang (4 4)</td><td></td></tr><tr><td>懊丧</td><td>因事情不如意而情绪低落</td></tr><tr><td>an zi si cun (4 4 1 3)</td><td></td></tr><tr><td>暗自思忖</td><td>在私底下里思量；在暗地：~盘算 | ~高兴</td></tr><tr><td>ji ( 4)</td><td></td></tr><tr><td>蓟</td><td>草本植物：大蓟</td></tr><tr><td></td><td></td></tr></tbody></table></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>话十叁</title>
      <link href="/2020/07/10/%E8%AF%9D%E5%8D%81%E5%8F%81/"/>
      <url>/2020/07/10/%E8%AF%9D%E5%8D%81%E5%8F%81/</url>
      
        <content type="html"><![CDATA[<p>“愿灵魂安息吧。” 这句话相当自私。它的根本意思是：“待在你的坟墓里，别在我身边游荡”。 相反的一句话会是：“动不动翻个身吧” 和 “去跑个步吧”。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活与话 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 话 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>话十二</title>
      <link href="/2020/07/04/%E8%AF%9D%E5%8D%81%E4%BA%8C/"/>
      <url>/2020/07/04/%E8%AF%9D%E5%8D%81%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>了解一件事是桥梁和道路上回转的可能性，解释一件事却是专横独断，有时甚至是谋杀了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活与话 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 话 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>妖怪</title>
      <link href="/2020/06/25/%E5%A6%96%E6%80%AA/"/>
      <url>/2020/06/25/%E5%A6%96%E6%80%AA/</url>
      
        <content type="html"><![CDATA[<ul><li><input disabled="" type="checkbox"> 巷说百物语</li><li><input disabled="" type="checkbox"> 续巷说百物语</li><li><input disabled="" type="checkbox"> 后巷说百物语</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据类型</title>
      <link href="/2020/06/24/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/06/24/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th></th><th>基本类型</th><th></th></tr></thead><tbody><tr><td>整型</td><td>字浮型</td><td>实型（浮点型）</td></tr><tr><td>int</td><td>char</td><td>单精度型    |   双精度型</td></tr><tr><td></td><td></td><td>float        |    double</td></tr></tbody></table></div><p>|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||</p><div class="table-container"><table><thead><tr><th></th><th></th><th>构造类型</th><th></th><th></th></tr></thead><tbody><tr><td>枚举类型</td><td>数组类型</td><td></td><td>结构体类型</td><td>共用体类型</td></tr></tbody></table></div><p>|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||</p><div class="table-container"><table><thead><tr><th></th><th></th><th>指针类型</th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><p>|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||</p><div class="table-container"><table><thead><tr><th></th><th></th><th>空类型</th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><p>小记：浮点数据指带小数点后的数字</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 语言与Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>歌声</title>
      <link href="/2020/06/15/%E6%AD%8C%E5%A3%B0/"/>
      <url>/2020/06/15/%E6%AD%8C%E5%A3%B0/</url>
      
        <content type="html"><![CDATA[<p>在时间的沙池中 我终于听到了 那柔和的心跳声 可是却无法触碰 在爱的阳炎下 赤着脚丫 飞驰而去  我和你是相反的存在 在那个我们相互追逐的春天里的某一天 在风儿的带动下 沙砾翩翩起舞 如果这个世界宛如瓶底的话 把它翻转过来的话 我们的明天就能永远描绘下去 在最后 请把爱的残月给予我 仅需那一秒的时间 就那么一秒钟 宛如剥落星辰一般 脸庞传来你指尖的感触 把拂晓照亮了</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第一章复习题</title>
      <link href="/2020/06/12/%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%A4%8D%E4%B9%A0%E9%A2%98/"/>
      <url>/2020/06/12/%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%A4%8D%E4%B9%A0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>1.对编程而言，可移植性意味着什么？</p><pre><code class="text">在一中系统中编写的c程序稍作修改或不修改就能在其他系统运行</code></pre><p>2.解释源代码文件、目标代码文件、可执行文件有什么区别？</p><pre><code class="te">源代码文件包含程序员使用的任何编程语言编写的代码。目标代码文件包含机器语言代码，它不必是完整的代码。可执行文件包含组成可执行程序的完整机器语言代码。</code></pre><p>3.编程的7个主要步骤？<a id="more"></a></p><pre><code class="text">1.定义程序的目标2.设计程序3.编写代码4.编译5.运行程序6.测试和调试程序7.维护和修改程序</code></pre><p>4.编译器的任务是什么？</p><pre><code class="text">把源代码转换成中间代码</code></pre><p>5.链接器的任务是什么？</p><pre><code class="text">把中间代码和其他代码合并，生成可执行文件</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 语言与Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C基础</title>
      <link href="/2020/06/12/C%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/06/12/C%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>C（嵌入式语言）是一门功能强大的专业化编程语言。强大的控制结构、快速、代码紧凑、可移植性。</p><p>c语言天下第一！！！</p><p>C语言中的6个语句：<a id="more"></a></p><p>语句：【标号语句  复合语句 表达式语句 选择语句 迭代语句 跳转语句】—–关键字、标识符、运算符、数据</p><pre><code class="c#">【典型的c程序】    |                                          &lt;stdio.h&gt;--------------头文件(包含了编译器创建最终可执行程序要用的到信息)    |----#include---------预处理器指令    |-----int main ()----------------总是第一个被调用的函数    |                     |________________________________语句--------------组成函数的语句    |------function a()    |                 |________________________语句    |    |-------function b()    |               |     |__________________语句    |   函数是C程序的构造块                      </code></pre><p>main()函数 c语言一定从main函数执行。圆括号用于识别main（）是一个函数</p><p>int则是main函数返回类型。</p><p>注释：编译器会忽视</p><pre><code class="js">/* 这是一种注释*/// 这也是一种注释</code></pre><p>花括号、函数体、块</p><pre><code class="c">{    ...   // 花括号会把main函数扩起来。也就是开始和结束。也可以把函数中的多条语句合并为一个单元格或块}</code></pre><p>声明：c语言中声明是最重要的特性之一</p><p>Eg：int mun   mun是一个变量，int则表明mun是一个整数（int则是一种数据类型）</p><p>命名：给变量命名时要使用有意义的变量名或标识符 PS: c99和c11允许使用更长的标识符名，但编译器只识别前63个<del>(但是没意义，63个手不累吗？)</del></p><p>Eg：可以用小写字母、大写字母、数字、下划线( _ ) 来命名。注：名字的第一个字符必须是字母或下划线，<font color="#D32525">不能是数字</font>。c语言的命名大小要区分，一个字母的大小写会被视为两个不同的字符。</p><p>声明变量的4个理由：</p><p>1.把所有的变量放在一处，方便读者查找和理解程序的用途。变量名要有意义，如果无法表述清楚，则注释解释变量的含义、</p><p>2.声明变量会促使在编写程序之前做些计划</p><p>3.声明变量有助于发现隐藏的bug。拼写错误等</p><p>4.未声明变量则无法编译</p><p>赋值：从右侧把值赋到左侧</p><p>printf()函数：一个标准函数PS：打印？</p><p>return语句：返回值的c函数要有return语句…</p><p><font color="#138091" size="5">扩展：</font></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 语言与Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode代码片段(html篇)</title>
      <link href="/2020/06/12/vscode%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5-html%E7%AF%87/"/>
      <url>/2020/06/12/vscode%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5-html%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>   此篇用于创建html代码片段，代码如下：</p><p>“prefix”: “vh”,指的是你自定义的快捷代码,输入vh就会出现快速生成代码提示，也可以自定义其他字段。</p><a id="more"></a><pre><code class="html">{     "Html5-Vue": {        "prefix": "vh",         "body": [            "&lt;!DOCTYPE html&gt;",            "&lt;html lang=\"zh-CN\"&gt;\n",            "&lt;head&gt;",            "\t&lt;meta charset=\"UTF-8\"&gt;",            "\t&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;",            "\t&lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;",            "\t&lt;title&gt;Document&lt;/title&gt;",            "&lt;/head&gt;\n",            "&lt;body&gt;",            "\t&lt;script&gt;",            "\t&lt;/script&gt;",            "&lt;/body&gt;\n",            "&lt;/html&gt;"        ]    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码片段 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode代码片段(vue篇)</title>
      <link href="/2020/06/12/vscode%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5-vue%E7%AF%87/"/>
      <url>/2020/06/12/vscode%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5-vue%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p> 此篇用于快速创建vue模板，代码如下: </p><p>管理——&gt;用户代码片段———-&gt;新建全局代码片段 <code>xxx.json</code>  PS：覆盖</p><p>“prefix”: “vue”,指的是你自定义的快捷代码，输入vue就会出现快速生成代码提示，也可以自定义其他字段。</p><a id="more"></a><pre><code class="vue">{        "Print to console": {          "prefix": "vue",            "body": [            "&lt;!-- $1 --&gt;",            "&lt;template&gt;",            "&lt;div&gt;&lt;/div&gt;",            "&lt;/template&gt;",            "",            "&lt;script&gt;",            "export default {",            "data() {",            "return {",            "",            "}",            "},",            "//生命周期 - 创建完成（访问当前this实例）",            "created() {",            "",            "},",            "//生命周期 - 挂载完成（访问DOM元素）",            "mounted() {",            "",            "}",            "}",            "&lt;/script&gt;",            "&lt;style scoped&gt;",            "/* @import url(); 引入css类 */",            "$4",            "&lt;/style&gt;"          ]        }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码片段 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript语句</title>
      <link href="/2020/06/12/javascript%E8%AF%AD%E5%8F%A5/"/>
      <url>/2020/06/12/javascript%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<p>语句：使用一或多个关键字来完成给定任务</p><p>if语句：可以嵌套多个if…esle…</p><pre><code class="js">if () {    ...  } else {    ...}</code></pre><p>do-while语句: 一种后测试循环语句  PS：最常用于循环体中的代码至少要被执行一次的情形<a id="more"></a></p><pre><code class="js">do {    ...} while (...)</code></pre><p>while语句: 在某个条件表达式为真的前提下，循环执行指定的一段代码，直到那个表达式不为真时结束循环。</p><pre><code class="js">while (...) {    ...       }</code></pre><p>for语句：用于创建一个循环，它包含了三个可选的表达式</p><pre><code class="js">for ([initialization]; [condition]; [final-expression]) {    ...}</code></pre><p>for-in语句：以任意顺序遍历一个对象的 </p><pre><code class="js">for (variable in object) {    ...}</code></pre><p>注：for…in是为遍历对象属性而构成的，不建议与数组一起使用 PS：数组可以用<code>Array.prototype.forEach()</code> 和 <code>for...of</code></p><p>label语句：标记就是在一条语句前面加个可以引用的标识符（identifier）（了解？？？）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见错误(二)</title>
      <link href="/2020/06/09/%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E4%BA%8C/"/>
      <url>/2020/06/09/%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="17-’vue-cli-service’-不是内部或外部命令，也不是可运行的程序">          <a href="#17-’vue-cli-service’-不是内部或外部命令，也不是可运行的程序" class="heading-link"><i class="fas fa-link"></i></a><a href="#17-’vue-cli-service’-不是内部或外部命令，也不是可运行的程序" class="headerlink" title="17.’vue-cli-service’ 不是内部或外部命令，也不是可运行的程序"></a>17.’vue-cli-service’ 不是内部或外部命令，也不是可运行的程序</h3>      <p>解决：</p><p>删除<code>node_modules</code>文件夹，重新运行<code>npm install</code></p>        <h3 id="18-npm-install-报错（npm-ERR-errno-4048，Error-EPERM-operation-not-permitted-）">          <a href="#18-npm-install-报错（npm-ERR-errno-4048，Error-EPERM-operation-not-permitted-）" class="heading-link"><i class="fas fa-link"></i></a><a href="#18-npm-install-报错（npm-ERR-errno-4048，Error-EPERM-operation-not-permitted-）" class="headerlink" title="18.npm install 报错（npm ERR! errno -4048，Error: EPERM: operation not permitted,）"></a>18.npm install 报错（npm ERR! errno -4048，Error: EPERM: operation not permitted,）</h3>      <blockquote><p>npm ERR! code EPERM<br>npm ERR! syscall unlink<br>……<br>npm ERR!   errno: -4048,<br>npm ERR!   code: ‘EPERM’,<br>npm ERR!   syscall: ‘unlink’,<br>npm ERR!   path: ‘C:\Users\15969\Desktop\vue-admin-beautiful\node_modules\.staging\echarts-9aadd223\dist\echarts-en.common.min.js’,<br>npm ERR!   parent: ‘vue-admin-beautiful’<br>npm ERR! }<br>npm ERR!<br>npm ERR! The operation was rejected by your operating system.<br>npm ERR! It’s possible that the file was already in use (by a text editor or antivirus),<br>npm ERR! or that you lack permissions to access it.<br>npm ERR!<br>npm ERR! If you believe this might be a permissions issue, please double-check the<br>npm ERR! permissions of the file and its containing directories, or try running<br>npm ERR! the command again as root/Administrator.</p></blockquote><p>解决方案：<a id="more"></a></p><pre><code class="text">首先检查是不是管理员运行，如果不是则用管理员运行命令。</code></pre><p>或</p><pre><code class="text"> 清除npm缓存npm cache clean --force</code></pre><p>或</p><pre><code class="text">删除C:\Users\{账户}\下的.npmrc文件..</code></pre><p>终极方案：npm cache verify  PS：大概估计也许可能有用。我没用过<span class="exturl"><a class="exturl__link" href="https://docs.npmjs.com/cli/cache" target="_blank" rel="noopener">npm</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h3 id="19-Git报错：error-failed-to-push-some-refs-to">          <a href="#19-Git报错：error-failed-to-push-some-refs-to" class="heading-link"><i class="fas fa-link"></i></a><a href="#19-Git报错：error-failed-to-push-some-refs-to" class="headerlink" title="19.Git报错：error: failed to push some refs to"></a>19.Git报错：error: failed to push some refs to</h3>      <pre><code>To https://xxx.com/xxx/xxx.git ! [rejected]        master -&gt; master (fetch first)error: failed to push some refs to 'https://xxx.com/xxx/xxx.git'hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details.</code></pre><p>错误原因：在推送前没有进行本地仓库和远程服务器的同步</p><p>解决方法：</p><p>如果确定本地是最新的则强行推送</p><p><code>git push -f origin master</code></p>        <h3 id="20-解决Git建立远程分支关联时fatal-the-current-branch-master-has-no-upstream-branch-问题">          <a href="#20-解决Git建立远程分支关联时fatal-the-current-branch-master-has-no-upstream-branch-问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#20-解决Git建立远程分支关联时fatal-the-current-branch-master-has-no-upstream-branch-问题" class="headerlink" title="20.解决Git建立远程分支关联时fatal the current branch master has no upstream branch 问题"></a>20.解决Git建立远程分支关联时fatal the current branch master has no upstream branch 问题</h3>      <p>发生的原因：</p><p>  执行sh的时候推送没推上去，sh中没由写master</p><p>解决办法：</p><p>git push -u  origin master</p>        <h3 id="21-运行项目报以下错误Error-PostCSS-plugin-autoprefixer-requires-PostCSS-8-Update-PostCSS-or-downgrade-this-plugin">          <a href="#21-运行项目报以下错误Error-PostCSS-plugin-autoprefixer-requires-PostCSS-8-Update-PostCSS-or-downgrade-this-plugin" class="heading-link"><i class="fas fa-link"></i></a><a href="#21-运行项目报以下错误Error-PostCSS-plugin-autoprefixer-requires-PostCSS-8-Update-PostCSS-or-downgrade-this-plugin" class="headerlink" title="21.运行项目报以下错误Error: PostCSS plugin autoprefixer requires PostCSS 8. Update PostCSS or downgrade this plugin."></a>21.运行项目报以下错误Error: PostCSS plugin autoprefixer requires PostCSS 8. Update PostCSS or downgrade this plugin.</h3>      <p>发生原因：启动模板项目报错</p><p>解决办法：未找到解决办法</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 错误 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>findIndex</title>
      <link href="/2020/06/09/findIndex/"/>
      <url>/2020/06/09/findIndex/</url>
      
        <content type="html"><![CDATA[<p><code>findIndex()</code>方法返回数组中满足提供的测试函数的第一个元素的<strong>索引</strong>。否则返回-1。</p><p><font color="#2be5e5">语法：</font></p><pre><code class="js">   arr.findIndex(callback[, thisArg]) </code></pre><p><font color="#2be5e5">参数：</font></p><p><code>callback¹</code>——&gt;针对数组中的每个元素，都会执行该回调函数，执行时会自动传入三个参数:<code>element</code>——&gt;当前元素。<code>index</code>——&gt;元素的索引。<code>array</code>——&gt;调用findIndex的数组。</p><p><code>thisArg²</code>——&gt;（可选）执行<code>callback</code>时作为this对象的值。</p><p><font color="#2be5e5">返回值：</font> 数组中通过提供测试函数的第一个元素的<strong>索引</strong>。否则，返回-1</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> findIndex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="/2020/06/08/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/06/08/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>  原理：：每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，以此循环，直至排序完毕。</p><p>代码：</p><pre><code class="js">void select_sort(int arr[], int len){    //每次从后边选择一个最小值    for (int i = 0; i &lt; len-1; i++){     //只需选择n-1次        int min = i;        for (int j = i+1; j &lt; len; j++){            if (arr[min]&gt;arr[j]){                min = j;            }        }        if (min != i){            swap(arr[i], arr[min]);        }    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法与面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode中ESLint配置</title>
      <link href="/2020/06/08/vscode%E4%B8%ADESLint%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/06/08/vscode%E4%B8%ADESLint%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>在创建项目选择ESLint，创建项目之后会看到根目录下有个<code>.eslintrc.js</code>.</p><p>在vscode中对eslint进行配置：在根目录下创建一个文件夹<code>.vscode</code>，并在文件夹下创建一个名为<code>settings.json</code>的文件，填写一下内容：PS：按下ctrl + s保存代码：自动调试eslint修复</p><pre><code class="json">{    "eslint.run":"onType",    "editor.codeActionsOnSave": {        "source.fixAll.eslint": true    },    "eslint.alwaysShowStatus": true}</code></pre><p>或<a id="more"></a></p><p>管理—-设置  然后点击工作区 点击右上角的打开设置（json）添加一下内容：</p><pre><code class="json">{    "eslint.run":"onType",    "editor.codeActionsOnSave": {        "source.fixAll.eslint": true    },    "eslint.alwaysShowStatus": true}</code></pre><p>PS：核实用户设置（json）的插件设置（禁用，防止设置失效）</p><p>或</p><p>运行<code>npm run lint</code> 命令用来eslint检查并自动修复代码中的问题</p><p>如果上述还是报错：</p><p>直接在脚手架关掉eslint：首先在根目录下创建一个<code>vue.config.js</code>写入以下内容：</p><pre><code>module.exports = {  lintOnSave: false // 默认是true}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ESLint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作符</title>
      <link href="/2020/06/08/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2020/06/08/%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>算术操作符（如加号和减号）、位操作符、 关系操作符和相等操作符</p><p><font color="#208dc9" size="4">一元运算符：</font>只能操作一个值的操作符</p><p>1.递增或递减</p><pre><code class="js">// 递增var age = 29; ++age;// 递减var age = 29;--age;</code></pre><p>2.一元加和减操作符  <a id="more"></a></p><pre><code class="js">// 加var num = 25;num = +num;// 减var num = 25;num = -num;</code></pre><p><font color="#208dc9" size="4">位操作符：</font>按内存中表示数值的位来操作数值。（了解？）</p><p><font color="#208dc9" size="4">布尔操作：</font>逻辑运算符</p><p>逻辑与(&amp;&amp;) –AND</p><pre><code class="js">x1 &amp;&amp; x2 // </code></pre><p>逻辑或(||)–OR</p><pre><code class="js">x1 || x2</code></pre><p>逻辑非(!)–NOT</p><pre><code class="js">!x</code></pre><p>双重非(!!)运算符</p><pre><code class="js">!!x</code></pre><p><font color="#208dc9" size="4">乘性操作符: </font>乘法、除法和求模</p><ol><li>乘法  <code>*</code></li><li>除法 <code>/</code>      PS：第二个操作数除第一个操作数的计算</li><li>求模<code>%</code>     Eg：var result = 26 % 5;</li></ol><p><font color="#208dc9" size="4">加性操作符：</font>加与减—-+与-   PS：如果要和字符串相加会被转换成字符串“ var a = 5; var b = “2”  a+ b= “52”;”</p><p><font color="#208dc9" size="4">关系操作符：</font></p><p>小于（&lt;）大于（&gt;）小于等于（&lt;=） 大于等于（&gt;=）</p><p><font color="#208dc9" size="4">相等操作符：</font></p><p>1.相等和不相等</p><p>​    ① ==</p><p>​    ② !=</p><p>2.全等和不全等</p><p>​     ① ===</p><p>​     ② !==</p><p><font color="#208dc9" size="4">条件操作符：</font>（三元）</p><p>语法</p><pre><code class="js">condition ? exprIfTrue : exprIfFalse</code></pre><p><font color="#208dc9" size="4">赋值操作符:</font> 右侧的值赋给左侧的变量</p><pre><code class="js">// 赋值      // 乘赋值      // 除赋值      // 模赋值     // 加赋值     // 减赋值     // 左移赋值     // 有符合右移赋值   // 无符号右移赋值var a = 10; var a *= 10;  var a /= 10;  var a %= 10;  var a += 10;  var a -= 10;  var a &lt;&lt;= 10;  var a &gt;&gt;= 10;      var a &lt;&lt;&lt;= 10; </code></pre><p><font color="#208dc9" size="4">逗号操作符：</font>逗号操作符多用于声明多个变量</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量与数据类型</title>
      <link href="/2020/06/08/%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/06/08/%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>ECMAScript的变量是松散类型：可以用来保存任何类型的数据 var let  const</p><pre><code class="js">var message = 'hello word' // 右边赋值到左边  var 声明语句声明一个变量let message = 'hello word'  // let声明一个块级作用域的本地变量const messgae = 'hello word' // 常量是块级作用域，很像使用 let 语句定义的变量。常量的值不能通过重新赋值来改变，并且不能重新声明。</code></pre><p>注：在严格模式下，不能定义名为 eval 或 arguments 的变量，否则会导致语法错误</p>        <h3 id="数据类型：">          <a href="#数据类型：" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据类型：" class="headerlink" title="数据类型："></a><font color="#4dc1bb" size="4">数据类型：</font></h3>      <p>5中简单数据类型（基本数据类型）：一种复杂数据类型<a id="more"></a></p><div class="table-container"><table><thead><tr><th>Undefined</th><th>Null</th><th>Boolean</th><th>Number</th><th>String</th></tr></thead><tbody><tr><td>未定义(一个值)</td><td>空对象指针(一个值)</td><td>布尔值</td><td>数值</td><td>字符串(不可变)</td></tr><tr><td></td><td></td><td>true与false</td><td></td><td>由双 引号（”）或单引号（’）表示（左右引号必须匹配*）</td></tr><tr><td></td><td>如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null 而不是其他值</td><td>true 不一定等于 1，而 false 也不一定等于 0</td><td>十进制表示外，整数还可以通过八进制（以 8 为基数）或十六进制（以 16 为基数）的字面值 来表示。</td><td>由零或多个 16位Unicode字符组成的字符序列</td></tr><tr><td></td><td></td><td></td><td>八进制字面值的第一位必须是零（0），然后是八进制数字序列（0～7）。如果字面值中的 数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析。（八进制字面量在严格模式下是无效的，会导致支持的 JavaScript引擎抛出错误。）*</td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>Object</th><th>对象可以通过执行 new 操作符后跟要创建 的对象类型的名称来创建。</th></tr></thead><tbody><tr><td>一组数据和功能的集合</td><td>即在 ECMAScript中， Object 类型是所有它的实例的基础。</td></tr><tr><td>复杂数据类型</td><td>“Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。”</td></tr><tr><td>构造函数（constructor） 就是 Object()</td><td></td></tr></tbody></table></div><p>Object 本质上是由一组无序的名值对组成的</p><p>typeof操作符：检测给定的数据类型[它是一个操作符而不是一个函数]</p><p>PS：typeof 操作符会返回一些令人迷惑但技术上却正确的值。比如，调用 typeof null 会返回”object”，因为特殊值 null 被认为是一个空的对象引用</p>        <h3 id="转换：">          <a href="#转换：" class="heading-link"><i class="fas fa-link"></i></a><a href="#转换：" class="headerlink" title="转换："></a><font color="#22a1b5" size="4">转换：</font></h3>      <p><font color="#22a1b5">数值转换:</font></p><p>3个函数可以把非数值转换为数值：Number()、parseInt()和 parseFloat()。第一个函数， 即转型函数 Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。</p><p><font color="#22a1b5">转换为字符串：</font></p><p>toString()方法</p><p>PS：null 和 undefined 没有 toString()方法</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关键字与保留字(了解)</title>
      <link href="/2020/06/08/%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97(%E4%BA%86%E8%A7%A3)/"/>
      <url>/2020/06/08/%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97(%E4%BA%86%E8%A7%A3)/</url>
      
        <content type="html"><![CDATA[<p>   特定用途的关键字，来表示控制语句的开始或结束，或用于执行特定的操作。但是不能用作标识符</p><div class="table-container"><table><thead><tr><th>break</th><th>do</th><th>instanceof</th><th>typeof</th></tr></thead><tbody><tr><td>case</td><td>else</td><td>new</td><td>var</td></tr><tr><td>catch</td><td>finally</td><td>return</td><td>void</td></tr><tr><td>continue</td><td>for</td><td>switch</td><td>while</td></tr><tr><td>debugger*</td><td>function</td><td>this</td><td>with</td></tr><tr><td>default</td><td>if</td><td>throw</td><td></td></tr><tr><td>delete</td><td>in</td><td>try</td><td>关键字</td></tr></tbody></table></div><a id="more"></a><p>保留字</p><div class="table-container"><table><thead><tr><th>abstract</th><th>enum</th><th>int</th><th>short</th></tr></thead><tbody><tr><td>boolean</td><td>export</td><td>interface</td><td>static</td></tr><tr><td>byte</td><td>extends</td><td>long</td><td>super</td></tr><tr><td>char</td><td>final</td><td>native</td><td>synchronized</td></tr><tr><td>class</td><td>float</td><td>package</td><td>throws</td></tr><tr><td>const</td><td>goto</td><td>private</td><td>transient</td></tr><tr><td>debugger</td><td>implements</td><td>protected</td><td>volatile</td></tr><tr><td>double</td><td>import</td><td>public</td><td>保留字</td></tr></tbody></table></div><p>….</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语句</title>
      <link href="/2020/06/07/%E8%AF%AD%E5%8F%A5/"/>
      <url>/2020/06/07/%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<p>  语句以一个分号结尾<code>;</code>如果省略分号，则由解析器确定语句的结尾。虽然语句结尾分号不是必须的，但最好不要省略它，∵加上分号可以避免很多错误（输入不完整）压缩js的时候也不会导致压缩错误，也可以增进代码的性能。多条语句组合到一个代码块中，则需要左花括号（ <code>{</code> ）开头,右花括号（<code>{</code>）结尾</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript概念基础</title>
      <link href="/2020/06/07/javascript%E6%A6%82%E5%BF%B5%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/06/07/javascript%E6%A6%82%E5%BF%B5%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p> 区分大小写，不能用关键字命名，标识符则指变量、函数、属性的名字，或者函数的参数：</p><p> 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；其它字符可以是字母、下划线、美元符号或数字。命名的时候首字母不能是数字</p><p>PS：不能把关键字、保留字、true、false 和null 用作标识符</p><a id="more"></a><p>注释可以使用单行注释:两个斜杠开头</p><pre><code class="js">// 单行注释</code></pre><p>也可使用块级注释:一个斜杠和一个星号（/ <code>*</code>）开头，以一个星号和一个斜杠（<code>*</code>/）结尾</p><pre><code class="js">/* * 这是一个多行* （块级）注释*/</code></pre><p>扩展：</p><p>严格模式是为 JavaScript 定义了一种不同的 解析与执行模型。</p><p>在严格模式下，ECMAScript 3中的一些不确定的行为将得到处理，而且对某些不安全 的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码： “use strict”;</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文档模式(了解)</title>
      <link href="/2020/06/07/%E6%96%87%E6%A1%A3%E6%A8%A1%E5%BC%8F-%E4%BA%86%E8%A7%A3/"/>
      <url>/2020/06/07/%E6%96%87%E6%A1%A3%E6%A8%A1%E5%BC%8F-%E4%BA%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>HTML文档模式是通过使用文档类型DOCTYPE来指定的。DOCTYPE中会引用对应的dtd文件，这个文件告诉浏览器按什么标准、规则来解析文件。html5标准不依赖于SGML规则，所以不需要引用dtd文件。</p><p>文档模式是：混杂模式（quirks mode） 和  标准模式（standards mode）以及IE提出的  准标准模 式（almost standards mode）。而准标准模式，则可以通过使用过渡型（transitional）或框架集型（frameset）文档类型来触发，</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活与话 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html中使用JavaScript</title>
      <link href="/2020/06/07/html%E4%B8%AD%E4%BD%BF%E7%94%A8JavaScript/"/>
      <url>/2020/06/07/html%E4%B8%AD%E4%BD%BF%E7%94%A8JavaScript/</url>
      
        <content type="html"><![CDATA[<p>javascript在html中主要使用方法是<code>&lt;script&gt;</code>元素,有6个属性：</p><div class="table-container"><table><thead><tr><th>async</th><th>charset</th><th>defer</th><th>language</th><th>src</th><th>type</th></tr></thead><tbody><tr><td>可选</td><td>可选(少)</td><td>可选</td><td>废用</td><td>可选</td><td>可选</td></tr><tr><td>立即下载脚本，不妨碍页面其它操作</td><td>指定代码字符集</td><td>延迟文档完全被解析和显示之后执行外部脚本有效</td><td></td><td>执行代码的外部文件</td><td>脚本语言内容类型</td></tr></tbody></table></div><p>两种使用方式：直接页面嵌入js代码 和引入包含外部js文件</p><a id="more"></a><p>而包含元素内部的js则是<font color="#258f9d">从上往下</font>依次解析，但在使用<code>&lt;script&gt;</code>嵌入js代码时，不要在任何地方出现<code>&lt;script&gt;</code>字符串，会报错，使用转义字符“/”可以解决。</p><p>引入外部js文件使用src引入，但不能在其<code>&lt;script&gt;</code>下写格外的js代码，还有一点就是引入的先后顺序，则点尤为重要。引入的位置则是在body中，这样在解析js代码之前，页面的内容将完全展现在浏览器中，从而感到打开页面速度变快了。</p><p>如果想要延迟脚本，需要加defer属性也就是<code>defer="defer"</code>，但defer只适用于外部js文件. 还有一个和他相同行为的属性<code>async</code>异步脚本但不同的是async的脚本并不保证按照指定它们的先后顺序执行，而是不让页面等待两个脚本下载和执行，来达到异步加载页面其它内容。</p><p>一般来说推荐使用外部引入文件：</p><p>可维护性   可缓存  </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1049799107101114</title>
      <link href="/2020/06/06/%E5%95%A5/"/>
      <url>/2020/06/06/%E5%95%A5/</url>
      
        <content type="html"><![CDATA[<p>u0049u0020u0077u0061u006eu0074u0020u0074u006fu0020u0062u0065u0020u0061u0020u0068u0061u0063u006bu0065u0072u0020u0061u006eu0064u0020u006eu006fu0074u0020u0061u0020u0073u0063u0072u0069u0070u0074u0020u006bu0069u0064\u0048\u006f\u0077\u0020\u0074\u006f\u0020\u006c\u0065\u0061\u0072\u006e\u0020\u0077\u0065\u006c\u006c</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>侧记</title>
      <link href="/2020/06/04/%E4%BE%A7%E8%AE%B0/"/>
      <url>/2020/06/04/%E4%BE%A7%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>不要过分强调选择什么语言。选择一种语言，这将有助于你学习编程，并完成你的任务。😊 不要担心什么很酷或最新的东西适合你。不管怎样，你以后还是会学习新的语言。因此，只要你有基本的编程概念，并放下技术，你就能更容易地学习一门新语言。最重要的部分是玩得开心！享受你正在做的事情，或者为什么这样做？</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活与话 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>话十一</title>
      <link href="/2020/06/04/%E8%AF%9D%E5%8D%81%E4%B8%80/"/>
      <url>/2020/06/04/%E8%AF%9D%E5%8D%81%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p><strong>过高地估计了你和别人的关系，希望越大，失望也会越大。一旦期待落空，那种强烈的落差感就会让人寒心。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活与话 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 话 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小狼毫输入法</title>
      <link href="/2020/06/04/%E5%B0%8F%E7%8B%BC%E6%AF%AB%E8%BE%93%E5%85%A5%E6%B3%95/"/>
      <url>/2020/06/04/%E5%B0%8F%E7%8B%BC%E6%AF%AB%E8%BE%93%E5%85%A5%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl"><a class="exturl__link" href="https://rime.im/" target="_blank" rel="noopener">RIME</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 是一个跨平台、开源、免费、且特别简洁流畅的输入法框架 (输入法引擎)</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 应用与插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 输入法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>话十</title>
      <link href="/2020/06/04/%E8%AF%9D%E5%8D%81/"/>
      <url>/2020/06/04/%E8%AF%9D%E5%8D%81/</url>
      
        <content type="html"><![CDATA[<p>  想要能获得什么 就必须付出相应的代价</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活与话 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 话 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扩展运算符(...)</title>
      <link href="/2020/06/04/%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2020/06/04/%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>扩展运算符(spread)：是三个点（…）。主要用于函数调用/数组构造是，将数组表达式或者string在语法层面展开，但值得注意的是如果扩展运算符后面是一个空数组，则不产生任何效果，而且只有函数调用时，扩展运算符才可以放在圆括号中，否则会报Uncaught SyntaxError: Unexpected number</p><p>语法：</p><p>函数调用</p><pre><code class="js">myFunction(...iterableObj);</code></pre><p>数组结构或字符串<a id="more"></a></p><pre><code class="js">[...iterableObj, '4', ...'hello', 6];</code></pre><p>进行克隆或者属性拷贝（原数组不受影响）</p><pre><code class="js">var arr = [1, 2, 3];var arr2 = [...arr]; // like arr.slice()arr2.push(4); // arr2 此时变成 [1, 2, 3, 4]// arr 不受影响let objClone = { ...obj };</code></pre><p>放置表达式?</p><pre><code class="js">const arr = [  ...(x &gt; 0 ? ['a'] : []),  'b',];</code></pre><p>扩展：</p><p>扩展运算符等价与apply的方式</p><pre><code class="js">function myFunction(x, y, z) { }var args = [0, 1, 2];myFunction.apply(null, args);</code></pre><p>PS：使用new关键字调用构造函数时，不能直接使用数组+apply的方式（<code>apply</code> 执行的是调用 <code>[[Call]]</code> , 而不是构造 <code>[[Construct]]</code>）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ECS6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atom插件合集</title>
      <link href="/2020/06/03/Atom%E6%8F%92%E4%BB%B6%E5%90%88%E9%9B%86/"/>
      <url>/2020/06/03/Atom%E6%8F%92%E4%BB%B6%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p> 代码美化：</p><p>file-icons 显示文件类型对应的图标</p><p>atom-beautify 支持大多数语言的代码格式化</p><p>pigments 颜色提示</p><p>minimap 代码预览图</p><p>提升效率：</p><p>autocomplete-paths 补全路径</p><a id="more"></a><p>atom-ternjs 补全 JS</p><p>emmet 超有名的前端工具</p><p>docblockr   代码注释</p><p>vim-mode  在 Atom 上使用 Vim</p><p>platformio-ide-terminal 集成终端</p><p>markdown-writer  markdown工具</p><p>autoclose-html  自动闭合html标签</p><p>代码相关：react</p><p>language-babel  atom内开发react的核心插件</p><p>language-javascript-jsx   JavaScript, ES6, ES7, react，JSX, Flow支持</p><p>atom-react-autocomplete  组件名及状态的自动补全 </p><p>autocomplete-js-import   模块导入智能提示 </p><p>react-es6-snippets   es6写法的react snippet   &amp;&amp;    react-snippets</p><p>代码相关：vue</p><p>language-vue  atom内开发vue的核心插件</p><p>vue2-autocomplete  vue中自动补全插件</p><p>vuejs2-snippets   vue碎片提示</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 应用与插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>彻底删除软件依赖包</title>
      <link href="/2020/06/02/%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E8%BD%AF%E4%BB%B6%E4%BE%9D%E8%B5%96%E5%8C%85/"/>
      <url>/2020/06/02/%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E8%BD%AF%E4%BB%B6%E4%BE%9D%E8%B5%96%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>apt-get remove –purge xxx # 移除应用及配置<br>apt-get autoremove # 移除没用的包</p><p> 1.删除已安装包（不保留配置文件）</p><pre><code class="csharp">apt-get purge</code></pre><ol start="2"><li>删除为满足依赖而安装且不需要的软件包（保留配置文件）</li></ol><pre><code class="csharp">apt-get autoremove </code></pre><p>3.删除已安装的软件包（保留配置文件），不会删除依赖软件包，且保留配置文件。</p><pre><code class="csharp">apt-get remove</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 语言与Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rm删除命令</title>
      <link href="/2020/06/02/rm%E5%88%A0%E9%99%A4%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/06/02/rm%E5%88%A0%E9%99%A4%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>rm删除文件:  <font color="#2874A6">rm [选项]  文件夹名</font></p><p>选项：</p><pre><code class="text">-d：直接把欲删除的目录的硬连接数据删除成0，删除该目录；-f：强制删除文件或目录；-i：删除已有文件或目录之前先询问用户；-r或-R：递归处理，将指定目录下的所有文件与子目录一并处理；--preserve-root：不对根目录进行递归操作；-v：显示指令的详细执行过程。</code></pre><p>注：指定被删除的文件列表，如果参数中含有目录，则必须加上<code>-r</code>或者<code>-R</code>选项。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 语言与Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Width(了解)</title>
      <link href="/2020/06/02/Width/"/>
      <url>/2020/06/02/Width/</url>
      
        <content type="html"><![CDATA[<p>   width的默认值是auto。但至少包含栏4种不同的宽度表现：</p><p>1）充分利用可用空间。也叫作fill-available(了解)</p><p>2）收缩与包裹。也就是浮动、绝对定位、 inline-block元素或者table元素。</p><p>3）收缩到最小。 min-content</p><p>4）超出容器限制。max-content</p><p>Ps：除非有明确的width设置，否则不会超过父容器宽度。Eg：white-space:nowrap</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>块级元素</title>
      <link href="/2020/06/01/%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0/"/>
      <url>/2020/06/01/%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p>“块级元素”和“display 为 block 的元素”不是一个概念。</p><p>由于“块级元素”具有换行特性，因此理论上它都可以配合 clear 属性来<font color="#3db2c6">清除浮动 </font>带来的影响。</p><p>使用 block或使用 table，但不会使用list-item &amp;&amp; Ps:设置display：list-item,会出现项目符号，他就会生成了一个附加盒子，学名“标记盒子”（marker box）用于存放原点、数字项目符号.</p><p>.在此之后又增添了display：inline-block ——”内在盒子“也叫作”容器盒子“。<a id="more"></a></p><p><font color="#1c67af" size="4">display: block和display: inline-block与display: inline-table区别：</font></p><p>值为block的元素盒子实际由外在的”块级盒子“和内在的”块级容器盒子“组成，而inline-block的元素则是由外在的”内联盒子“和内在的”块级容器盒子“组成，值为inline的元素则内外均是“内联盒子”.display: inline-table的话则是外面是“内联盒子”，里面是“table 盒子”</p><p>display:inline-block元素既能和图文一行显示，又能直接设置宽与高，外面的盒子是inline，而里面盒子是block</p><p><del>Ps：display：block 可以理解为block-block，虽然没什么人说就是</del></p><p>而宽或高作用在“容器盒子上”</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS术语</title>
      <link href="/2020/05/31/CSS%E6%9C%AF%E8%AF%AD/"/>
      <url>/2020/05/31/CSS%E6%9C%AF%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<p><font color="#5eb3e0" size="5">术语：</font></p><p><font color="#5eb3e0" size="4">属性：</font></p><p><font color="#5eb3e0" size="4">值：</font>整数值，数值，百分比 ， 长度值 ，颜色值</p><p><font color="#5eb3e0" size="4">关键字：</font><del>很关键的字</del></p><p><font color="#5eb3e0" size="4">变量：</font>也可以说自定义属性或级联变量</p><a id="more"></a><p>   自定义属性：</p><pre><code class="css"> element {    --main-bg-color: brown;}</code></pre><p>局部变量：</p><pre><code class="css">element {    background-color： var(--main-bg-color)}</code></pre><p><font size="2" color="#d30f2d">注：具体内容请查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_custom_properties">MDN web docs</a></font></p><p><font color="#5eb3e0" size="4">长度单位：</font>px em rem等 %是不是长度单位，是一个完整的值</p><p>​      <font color="#d64395" size="3">○相对长度单位</font></p><p>​          •对字体长度单位，如 em 和 ex,rem</p><p>​          •相对视区长度单位，如 vh、vw、vmin 和 vmax</p><p>​      <font color="#d64395" size="3">  ○绝对长度单位</font></p><p>​           •px   </p><p><font color="#5eb3e0" size="4">功能符：</font>值以函数的形式指定</p><p>​       ○颜色（rgba 和 hsla）、 背景图片地址（url）、元素属性值、计算（calc）和过渡效果等</p><p><font color="#5eb3e0" size="4">属性值：</font>属性冒号后面的所有内容统一称为属性值。</p><p><font color="#5eb3e0" size="4">声明：</font>属性名加上属性值就是声明</p><p><font color="#5eb3e0" size="4">声明块：</font>花括号（{}）包裹的一系列声明</p><p><font color="#5eb3e0" size="4">规则或规则集：</font>选择器+声明块</p><p><font color="#5eb3e0" size="4">选择器：</font></p><p>​            <font color="#d64395" size="3">  ○类选择器：</font>指以“.”这个点号开头的选择器</p><p>​            <font color="#d64395" size="3">  ○ID 选择器：</font>“#”打头，权重相当高。</p><p>​            <font color="#d64395" size="3">  ○属性选择器：</font>指含有[]的选择器</p><p>​            <font color="#d64395" size="3">  ○ 伪类选择器：</font>一般指前面有个英文冒号（:）的选择器</p><p>​            <font color="#d64395" size="3">  ○伪元素选择器： </font>就是有连续两个冒号的选择器</p><p><font color="#5eb3e0" size="4">关系选择器：</font></p><p>​       <font color="#d64395" size="3">  ○后代选择器：</font>选择所有合乎规则的后代元素。<font color="#5eb3e0" size="4">空格连接</font>。</p><p>​      <font color="#d64395" size="3">  ○相邻后代选择器： </font>又称“子 选择器”。仅仅选择合乎规则的儿子元素，孙子、重孙元素忽略，<font color="#5eb3e0" size="3">&gt;连接</font>。适用于 IE7 以上版本。</p><p>​      <font color="#d64395" size="3">  ○ 兄弟选择器： </font>选择当前元素后面的所有合乎规则的兄弟元素。<font color="#5eb3e0" size="4">~连接</font>。适用于 IE7 以上 版本。<br>​        <font color="#d64395" size="3">  ○相邻兄弟选择器： </font>仅仅选择当前元素相邻的那个合乎规则的兄弟元素。<font color="#5eb3e0" size="4">+连接</font>。适用于<br>IE7 以上版本。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS简述（了解）</title>
      <link href="/2020/05/31/CSS%E7%AE%80%E8%BF%B0%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89/"/>
      <url>/2020/05/31/CSS%E7%AE%80%E8%BF%B0%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>CSS 世界的诞生就是为图文信息展示服务的，CSS世界构建的基石是HTML，而HTML最具代表的两个基石&lt;\div&gt;和&lt;\span&gt;正好是CSS 世界中<u>块级元素</u>和<u>内联级元素</u>的代表.</p><p>对 CSS2.1 的全面支持是从微软公司的 IE8 开始的</p><a id="more"></a><p>CSS3:</p><p>（1）布局更为丰富。</p><p> • 移动端的崛起，催生了 CSS3 媒介查询以及许多响应式布局特性的出现，如图片元素 的 srcset 属性、CSS 的 object-fit 属性。<br>• 弹性盒子布局（flexible box layout）</p><p> • 格栅布局（grid layout）<br>（2）视觉表现长足进步。</p><p> • 圆角、阴影和渐变让元素更有质感。</p><p> • transform 变换让元素有更多可能。</p><p> • filter 滤镜和混合模式让 Web 轻松变成在线的 Photoshop；<br>• animation 让动画变得非常简单。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在Linux安装zsh</title>
      <link href="/2020/05/31/%E5%A6%82%E4%BD%95%E5%9C%A8Linux%E5%AE%89%E8%A3%85zsh/"/>
      <url>/2020/05/31/%E5%A6%82%E4%BD%95%E5%9C%A8Linux%E5%AE%89%E8%A3%85zsh/</url>
      
        <content type="html"><![CDATA[<p><strong>Z shell</strong>（<strong>Zsh</strong>）是一款可用作<span class="exturl"><a class="exturl__link" href="https://zh.wikipedia.org/w/index.php?title=交互式&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">交互式</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>登录的<span class="exturl"><a class="exturl__link" href="https://zh.wikipedia.org/wiki/殼層" target="_blank" rel="noopener">shell</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>及<span class="exturl"><a class="exturl__link" href="https://zh.wikipedia.org/wiki/Shell脚本" target="_blank" rel="noopener">脚本编写</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>的<span class="exturl"><a class="exturl__link" href="https://zh.wikipedia.org/wiki/命令行界面" target="_blank" rel="noopener">命令解释器</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>下载<code>zsh</code>  <font color="#316666" size="4">sudo apt-get install  zsh</font></p><p>下载<a href="https://ohmyz.sh/" style="text-decoration:none">Oh My ZSH!</a>   </p><hr><p>根据官网的两条命令会出现以下错误</p><p>sh -c “$(curl -fsSL <span class="exturl"><a class="exturl__link" href="https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;" target="_blank" rel="noopener">https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><blockquote><p>curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused</p></blockquote><p>sh -c “$(wget <span class="exturl"><a class="exturl__link" href="https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh" target="_blank" rel="noopener">https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> -O -)”</p><blockquote><p>正在解析主机 raw.githubusercontent.com (raw.githubusercontent.com)… 0.0.0.0<br>正在连接 raw.githubusercontent.com (raw.githubusercontent.com)|0.0.0.0|:443… 失败：Connection refused。</p></blockquote><hr><p>解决办法就是：<a id="more"></a></p><p>科学上网在浏览器输入<span class="exturl"><a class="exturl__link" href="https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh" target="_blank" rel="noopener">https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 像是保存js或者css一样。<font color="#f42b56" size="4">Ctrl + S</font>保存到文件夹然后在终端运行 <code>./install.sh</code></p><p>切换shell命令：</p><p><font color="#316666" size="4">chsh -s /bin/zsh</font></p><p>然后重启</p><p>配置主题：<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes" style="text-decoration:none">主题地址</a></p><p>~vim .zshrc     ps:修改前需要先修改文件权限</p><p>更新oh my zsh： <code>omz update</code></p><p><font color="#005300" size="5">扩展:</font></p><p>查看当前使用的shell</p><blockquote><p>echo $SHELL</p></blockquote><p>或</p><blockquote><p>echo ＄０</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 应用与插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zsh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript基础二</title>
      <link href="/2020/05/27/javascript%E5%9F%BA%E7%A1%80%E4%BA%8C/"/>
      <url>/2020/05/27/javascript%E5%9F%BA%E7%A1%80%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>javascript由以下三个不同的部分组成：核心（ecmascript）文档对象模型（dom）浏览器对象模型（bom）</p><p>规定：语法 类型 语句 关键字 保留字  操作符 对象</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>词汇</title>
      <link href="/2020/05/26/%E8%AF%8D%E6%B1%87/"/>
      <url>/2020/05/26/%E8%AF%8D%E6%B1%87/</url>
      
        <content type="html"><![CDATA[<p>能够以所有人都能理解、并且具有说服力的方式，来清晰阐明得出的结论的原因。或许可以说，让别人去接纳你所断定的结论，正好是逻辑思维的职责所在。在逻辑思维中，不能一下子从最初的论点直接跳到结论，而是应当以事实前提作为基础通过一系列判断的积累，形成起思考的调理。而其中的每一个判断，也都要清晰明确。</p><p>  为此，在做出每个判决时，除了严谨的思维，果断也很重要。即便面对暧昧的灰色区域，你也可以基本一些前提，做出明确的判断（“黑色”），这才是现实中逻辑思维的使用方法。</p><p><del>当所有人都说错的时候，对的也变成错的。当所有人都说对的时候，错的也是对的。</del></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态路由与404</title>
      <link href="/2020/05/23/React%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E4%B8%8E404/"/>
      <url>/2020/05/23/React%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E4%B8%8E404/</url>
      
        <content type="html"><![CDATA[<p>​    </p><p><font color="#7D9EC0" size="4">动态路由在Router组件的path属性:</font> {/url/:parameter}</p><pre><code class="jsx">&lt;Router path='/xxx/:id' component={xxx} /&gt;</code></pre><p>Switch组件配置404页面：</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 404 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React路由的基本组件</title>
      <link href="/2020/05/23/React%E8%B7%AF%E7%94%B1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6/"/>
      <url>/2020/05/23/React%E8%B7%AF%E7%94%B1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>React路由基础组件:</p><p>1.路由组件(router components)</p><p>  <code>&lt;BrowserRouter&gt;</code> （推荐）和<code>&lt;HashRouter&gt;</code>两种路由组件</p><p>Eg:</p><pre><code class="react">import { BrowserRouter } from "react-router-dom";ReactDOM.render(     &lt;BrowserRouter&gt;             &lt;App /&gt;    &lt;/BrowserRouter&gt;,    document.getElementById('root'))</code></pre><p>2.路由匹配组件（router matching components)</p><p><code>&lt;Route&gt;</code>和<code>&lt;Switch&gt;</code>路由匹配组件。<a id="more"></a></p><p>Route:通过<code>&lt;Route&gt;</code>组件的path属性匹配当前地址，当匹配成功时就渲染component属性指定的组件。</p><pre><code class="jsx">import { Route, Switch } from "react-router-dom";....// 当前路径是'/about'&lt;Route path='/about' component={About}/&gt; // renders &lt;About/&gt;&lt;Route path='/contact' component={Contact}/&gt; // renders null&lt;Route component={Always}/&gt; // renders &lt;Always/&gt;</code></pre><p>Switch:遍历所有子Route元素，并仅渲染与当前地址匹配的第一个元素。实现404组件</p><pre><code class="jsx">&lt;Switch&gt;       ....  &lt;Route component={NoMatch}/&gt;&lt;/Switch&gt;</code></pre><p>3.导航组件(nacigation components)</p><p><code>Link</code>和<code>NavLink</code>主要导航组件。</p><p>Link: 创建连接，渲染后为html的a标签</p><pre><code class="jsx">&lt;Link to='/'&gt;Home&lt;/Link&gt;    =&gt;  &lt;a to='/'&gt;Home&lt;/a&gt;</code></pre><p>NavLink:特殊类型的Link，当to属性与当前地址匹配时，自动添加active状态。</p><pre><code class="jsx">&lt;NavLink to="/react" activeClassName="active"&gt;React&lt;/NavLink&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React路由的基本使用</title>
      <link href="/2020/05/23/React%E8%B7%AF%E7%94%B1%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/05/23/React%E8%B7%AF%E7%94%B1%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>   前段路由是一套映射规则，在React中，是URL路径与组件的对应关系。就是配置路径和组件（一一对应）</p><p>1.React路由安装：</p><pre><code class="bash">$ npm i react-router-dom</code></pre><p>2.导入路由的三个核心组件：Router / Route / Link</p><pre><code class="jsx">import { BrowserRouter as Router , Route, LInk } from 'react-router-dom'</code></pre><p>3.使用Router组件包裹整个应用（重要！！！）<a id="more"></a></p><pre><code class="jsx">&lt;Router&gt;  &lt;nav className="menu"&gt;        // ...               &lt;/nav&gt;  &lt;div className="app"&gt;        // ...路由配置  &lt;/div&gt;&lt;/Router&gt;</code></pre><p>4.使用Link组件作为导航菜单（路由入口）</p><pre><code class="jsx">&lt;Link&gt; ... &lt;/Link&gt;</code></pre><p>5.使用Router组件配置路由规则和要展示的组件（路由出口）</p><pre><code class="jsx">class Home extends Component{    render () {         return (           .....         )    }}.....b&lt;Router&gt;  &lt;nav className="menu"&gt;    &lt;Link to="/home"&gt;home&lt;/Link&gt;  &lt;/nav&gt;  &lt;div className="app"&gt;    &lt;Route path="/home" component={Home} /&gt;  &lt;/div&gt;&lt;/Router&gt;</code></pre><p>注：Router组件：包裹整个应用，一个React应用只需使用一次</p><p>​        Router Ｌink组件：须在Ｒouter组件内部</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React脚手架</title>
      <link href="/2020/05/23/React%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
      <url>/2020/05/23/React%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p><font color="#2F4F4F" size="4">使用脚手架初始化项目：</font></p><p>1.初始化项目，命令npx create-react-app  xxx</p><p>2.启动项目，在项目根目录执行命令：npm start</p><pre><code class="react">public/                                                                                                                       // 公共资源         index.html                                                                                                     // 首页（必须）         manifest.jsonsrc /     index.js                                                                                                                 // 项目入口文件（必须）    App.js                                                                                                                    // 项目的根组件    App.test.js                                                                                                          //  App组件的测试文件    serviceworker.js                                                                                            //    实现pwa（可选）</code></pre><p>扩展：<a id="more"></a></p><p>npx是npm V5.2.0引入的一条命令，提升包内提供的命令行工具使用体验</p><p><font color="#2F4F4F" size="4">在脚手架使用react：</font> </p><p>  1.导入react 和 react-dom 两个包</p><p>  2.调用React.createElement()方法创建react元素</p><p>  3.调用ReactDOM.render()方法渲染react元素到页面</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JQuery效果</title>
      <link href="/2020/05/21/JQuery%E6%95%88%E6%9E%9C/"/>
      <url>/2020/05/21/JQuery%E6%95%88%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<p><font color="#86d7ed" size="4">常见的动画效果：</font>动画或效果一旦触发就会执行，如果触发多次，就造成多个动画或效果排队执行。但可以停止动画排队：stop() </p><div class="table-container"><table><thead><tr><th>显示隐藏</th><th>滑入滑出</th><th>淡入淡出</th><th>自定义动画</th></tr></thead><tbody><tr><td>show()</td><td>slideDown()</td><td>fadein()</td><td>animate()</td></tr><tr><td>hide()</td><td>slideUp()</td><td>fadeOut()</td><td></td></tr><tr><td>toggle()</td><td>slideToggle()</td><td>fadeToggle()</td><td></td></tr><tr><td></td><td></td><td>fadeTo()×××</td><td></td></tr><tr><td>[speed,[easing],[fn]</td><td>[speed,[easing],[fn]</td><td>[speed,[easing],[fn]</td><td>[params,speed,[easing],[fn]</td></tr></tbody></table></div><p> <font color="#86d7ed" size="4">显示语法：</font>show([speed,[easing],[fn] )    <a id="more"></a></p><p>参数：都可以省略，无动画直接显示。</p><p>speed：三种预订速度之一的字符串（“slow”， “noemal”，“fast”）或者表示动画时长的毫秒数值（1000）</p><p>easing：(Optional)用来指定切换效果，默认“swing”，可选“linear”。</p><p>fn：回调函数，在动画完成时执行的函数，且每个元素执行一次。</p><p> <font color="#86d7ed" size="4">隐藏语法：</font>hide( [speed,[easing],[fn] )</p><p>同上略….</p><p><font color="#86d7ed" size="4">切换语法：</font>toggle( [speed,[easing],[fn])</p><p>同上略….注：没特殊情况，则不带参数，直接显示隐藏即可</p><p>×××：参数：opacity 透明度必须写，取值0～1之间。speed：必须写</p><p><font color="#dd5325" size="5">自定义动画：</font>模拟上面所有动画！！！</p><p>语法：animate(params, [speed],[easing],[fn])</p><p>params：更改样式属性则以对象形式传递，必须写。属性名可以不带引号，复合属性则需采用驼峰命名法</p><p><font color="#0c1e76" size="4">停止动画排队：</font>stop()方法用于停止动画或效果。须写到动画或效果前面，相当于停止结束上一次动画。</p><p>也就是说每次使用动画前，先调用stop()在调用动画。</p><p><font color="#203149" size="4">事件的切换：</font>hover([over], out)类似css中伪类 :hover</p><p>over：鼠标移到元素上触发的函数（相当于mouseenter）</p><p>out：鼠标移出元素上触发的函数（相当于mouseleave）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React表单处理</title>
      <link href="/2020/05/20/React%E8%A1%A8%E5%8D%95%E5%A4%84%E7%90%86/"/>
      <url>/2020/05/20/React%E8%A1%A8%E5%8D%95%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>受控组件(双向绑定（v-model）)：</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类组件中state和setState()</title>
      <link href="/2020/05/20/%E7%B1%BB%E7%BB%84%E4%BB%B6%E4%B8%ADstate%E5%92%8CsetState/"/>
      <url>/2020/05/20/%E7%B1%BB%E7%BB%84%E4%BB%B6%E4%B8%ADstate%E5%92%8CsetState/</url>
      
        <content type="html"><![CDATA[<p><font color="#408d96" size="4">state的基本使用：</font>状态（state）即是数据,是组件内部的私有数据，只能在组件内部使用，且state的值是对象，表示一个组件中可以有多个数据</p><p><font color="#305991" size="4">初始语法：</font></p><pre><code class="react">class KEL extends React.Component {    constructor() {        super () {            // 初始化state            this.state = {                count: 0            }        }        render () {            return {                &lt;div&gt;有状态组件&lt;/div&gt;            }        }    }}</code></pre><p><font color="#305991" size="4">简化语法：</font><a id="more"></a></p><pre><code class="react">class KEL extends React.Component {            // 初始化state          state = {                count: 0            }          render () {            return {                &lt;div&gt;有状态组件, {this.state.count}&lt;/div&gt;            }      }  }</code></pre><p><font color="#305991" size="4">  获取状态：</font>this.state</p><pre><code class="react">{this.state.count}</code></pre><p><font color="#39abe8" size="4">setState()修改状态：</font>注：不要直接修改state中的值，【this.state.num=2】&lt;-错误。【数据驱动视图】</p><p>语法：this.setState({key:val, key2:val2})</p><p>作用：修改state和更新UI</p><p><font color="#305991" size="4">Eg：</font></p><pre><code class="react">// 正确  this.setState({      count: this.state.count + 1  })// 错误this.state.count += 1</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类组件中this指向(注)</title>
      <link href="/2020/05/20/%E7%B1%BB%E7%BB%84%E4%BB%B6%E4%B8%ADthis%E6%8C%87%E5%90%91/"/>
      <url>/2020/05/20/%E7%B1%BB%E7%BB%84%E4%BB%B6%E4%B8%ADthis%E6%8C%87%E5%90%91/</url>
      
        <content type="html"><![CDATA[<p>只有类组件下有这个问题（函数组件没有this）</p><p><font color="#406497" size="4">利用bind修改this指向组件：</font></p><pre><code class="react">class HEL extends React.Comonent {    num = 0;    addNum() {        this.num += 1;        alert(this.num)    }    render () {        return (         &lt;div&gt;           &lt;h1 onClick={this.addNum.bing(this)}&gt;数字加一&lt;/h1&gt;            &lt;/div&gt;        )    }}</code></pre><p><font color="#406497" size="4">利用箭头函数方法（推荐）：</font>该语法是实验性语法，由于babel的存在可以直接使用 <a id="more"></a></p><pre><code class="react">class HEL extends React.Comonent {    num = 0;    addNum = () =&gt; {        this.num += 1;        alert(this.num)    }    render () {        return (         &lt;div&gt;           &lt;h1 onClick={this.addNum.bing(this)}&gt;数字加一&lt;/h1&gt;            &lt;/div&gt;        )    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React事件处理</title>
      <link href="/2020/05/19/React%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
      <url>/2020/05/19/React%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>​    <font color="#4b8ce5" size="4">事件绑定：</font>React事件绑定语法与DOM事件语法相似，而语法则是<font color="#2fd36a" size="3">on+事件名称={事件处理程序fn}</font>需要注意的是React事件则采用<font color="#368499" size="3">小驼峰命名法：除第一个单词之外，其他单词首字母大写。</font></p><p> <font color="#287a7a" size="4"> 类 组件绑定：</font></p><pre><code class="react">class KL extends React.Component {    headrClick () {        ...    }     render () {         return (          &lt;button  onClick={this.headrClick}&gt;&lt;/button&gt;         )     } }</code></pre><p><font color="#287a7a" size="4"> 函数组件绑定: </font>     <a id="more"></a></p><pre><code class="react">function KL() {    function headeClick() {        ...    }        return (       &lt;button  onClick={headeClick}&gt;&lt;/button&gt;       )}</code></pre><p><font color="#287a7a" size="4">事件对象: </font>通过处理程序的默认参数获取到事件对象，但是在React中事件对象叫做：合成事件（对象）&lt;—–兼容所有浏览器——-&gt;</p><pre><code class="react">function hadeClick (e) {    e.preventDefault()}   &lt;a href="..." onClick={hadeClick}&gt;&lt;/a&gt; // 阻止跳转</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es5类的创建与继承</title>
      <link href="/2020/05/19/es5%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
      <url>/2020/05/19/es5%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p>父类：</p><a id="more"></a><pre><code class="js">function Parent(name) {   // 实例的属性    this.name = name}// 定义静态属性 =》不在实例Parent.a = 1;Parent.fn = function () {    console.log(this.abc, Parent.a)}</code></pre><p>原先方法：</p><pre><code class="js">// 原型方法Parent.prototype.getName = function () {  console.log(this.name)}// 子类：继承 function Child(name) {  // 继承实例的属性  Parent.call(this, name)}// Child.prototype = new Parent();Child.prototype = Object.create(Parent.prototype, {  constructor: {    value: Child  }})// 测试let Chi = new Child('普京');console.log(Chi)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法与面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JQuery样式操作</title>
      <link href="/2020/05/19/JQuery%E6%A0%B7%E5%BC%8F%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/05/19/JQuery%E6%A0%B7%E5%BC%8F%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p><font color="#48ded5" szie="4">Query中常用的样式操作：</font>Jcss()和设置类样式方法</p><p> <font color="#48ded5" size="4">操作css方法：</font>JQuery使用css方法修改简单元素样式，操作类，修改多个样式</p><pre><code class="js">// 1.参数只写属性名，则返回属性值 var strColor = $(this).css('color');// 2.参数是属性名，属性值，逗号分隔（英文），设置一组样式，属性须加引号，如果是数字可不用加单位和引号 $(this).css("color", "red");// 3.参数可以是对象形式(css()用于样式少时)$(this).css({"color":"white", "font-size":"20px"});</code></pre><p><font color="#48ded5" size="4">设置类样式：</font>等同于classList，可以操作样式，注：操作类不加点且不会覆盖原先的类名<a id="more"></a></p><pre><code class="js">1.添加类$("div").addClass("current");2.删除类$("div").removeClass("current");3.切换类$("div").toggleClass("current");</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React组件</title>
      <link href="/2020/05/19/React%E7%BB%84%E4%BB%B6/"/>
      <url>/2020/05/19/React%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p> <font color="#65c1e0" size="5">  React组件创建：</font>特点：复用 独立 可组合</p><p><font color="#eb60aa" size="3">    函数创建：</font>使用JS函数或<u>箭头函数</u>创建的组件</p><pre><code class="react">import React from 'react';const Dnz = () =&gt; {     return (       &lt;div&gt;             &lt;h2&gt;函数组件&lt;/h2&gt;              &lt;p onClick={fn}&gt;点击&lt;/p&gt;       &lt;/div&gt;     )}ReactDOM.render(&lt;Dnz /&gt;, root)</code></pre><p>【注意事项：</p><p>​           1.类与函数名称都需以大写字母开头，使用<font color="#4aeadb">大驼峰命名法</font>。</p><p>​           2.函数组件必须有返回值，表示该组件的结构，而类组件则需提供render()方法。<a id="more"></a></p><p>​          3.函数的组件标签闭合，而类的render()方法须有返回值表示该组件的结构 </p><p>】</p><p>   <font color="#65c1e0" size="4">  class创建组件：</font>使用ES6的class关键字创建的组件</p><p>  类组件应继承React.Component父类，从而可以使用父类中提供的方法和属性。有关继承请访问<a href="#">es5类的创建与继承</a>与<a href="#">es6类的创建与继承</a></p><pre><code class="react">import React from 'react';class Hello extends React Component {    render() {        return &lt;div&gt;Hello Class Component!&lt;/div&gt;    }}ReactDOM.render(&lt;Hello /&gt;, root)</code></pre><p><font color="#55a7ce" size="4">组件抽离：</font>将每个组件放到单独的JS文件中。独立体放单独JS文件中</p><p> 步骤:</p><p>​      1.创建JS文件</p><p>​      2.在JS中导入React核心包</p><p>​      3.创建组件（函数或类）</p><p>​       4.在JS中导出组件</p><p>​       5.在index.js中导入组件</p><p>​      6.渲染组件</p><hr><p><font color="#3f98b8" size="4">扩展：</font></p><p>状态组件与无状态组件</p><p><font color="#db638f">函数组件：</font>无状态组件</p><p><font color="#db638f">类组件class：</font>有状态组件</p><p>区别：</p><ul><li>类组件有自己的状态，负责更新 UI，让页面“动” 起来 （响应式）</li><li>函数组件没有自己的状态，只负责数据展示（静）</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2020/05/19/%E6%95%B0%E7%BB%84/"/>
      <url>/2020/05/19/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>javascript的Array对象是用于构造数组的全局对象，数组是类似于列表的高阶对象。</p><p>创建数组：属性——Array.length于Array.prototype[]</p><pre><code class="js">var fruits = ['App', 'ios']// 打印数组console.log(fruits.length)</code></pre><p>遍历数组：</p><pre><code class="js">fruits.forEach( (item, index, array) =&gt; {         console.log(item, index);                })</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSX基本使用</title>
      <link href="/2020/05/18/JSX%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/05/18/JSX%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Babel会把JSX转译成一个名为React.createElement()函数调用</p><p><font color="#1688a0" size="4">原生创建recat元素：</font></p><pre><code class="react">const span = React.createElement('span', null, 'span')</code></pre><p><font color="#1688a0" size="4">用JSX创建react元素：</font></p><pre><code class="react">const ul = &lt;div&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;hello worde!!!&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</code></pre><p><font color="#1688a0" size="4">JSX中使用JS表达式：</font></p><p> 语法：{JavaScript表达式}</p><p> <font color="#de5c6a" size="3"> 注：语法中是单大括号，不是双大括号</font>       <a id="more"></a></p><pre><code class="react">const name = 'kl' const div = (   &lt;div&gt;XXX:{name}&lt;/div&gt; )</code></pre><p><font color="#1688a0" size="4">使用jsx注意事项：</font>自身也是js表达式</p><p>​       1.添加类名需小驼峰命名法：第一个单词首字母小写，从第二个单词及以后的首字母是大写开头</p><p>​       2.声明的jsx元素需圆括号下只能有一个根元素</p><pre><code>   3.不能在{}中出现语句和对象（if/for,{a:555}等）</code></pre><p><font color="#1688a0" size="4">数据类型支持：</font></p><p>单大括号：值、变量、函数调用、三元运算符、数组（基本类型，jsx）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React初体验</title>
      <link href="/2020/05/18/React%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/2020/05/18/React%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>  引入react react-dom</p><p>  安装包：npm Install react  react-dom</p><p>   react：创建元素 react-dom：渲染元素</p><p><font color="#0baba5" size="4">创建元素：</font></p><pre><code class="js">  const h1 = React.createElement('h1', {classNmae: 'k', id: 'hh'}, 'hello react')</code></pre><p><font color="#0baba5" size="4">渲染元素：</font></p><pre><code class="js"> React.render(div, document.getElementById('app'))</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JQuery选择器</title>
      <link href="/2020/05/18/JQuery%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/2020/05/18/JQuery%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>JQuery选择器：原生 JS 获取元素方式很多，很杂，而且兼容性情况不一致，因此 jQuery 做了封装，使获取元素统一标准。</p><p> <font color="#08a9b7" size="4"> 基础选择器：</font></p><pre><code class="js">$('选择器') // 直接写css选择器，需加引号</code></pre><div class="table-container"><table><thead><tr><th>名称</th><th>用法</th><th>描述</th></tr></thead><tbody><tr><td>ID选择器</td><td>$(“#id”)</td><td>获取指定的ID的元素</td></tr><tr><td>全选选择器</td><td>$(‘*’)</td><td>匹配所有元素</td></tr><tr><td>类选择器</td><td>$(‘.class’)</td><td>获取同一类class的元素</td></tr><tr><td>标签选择器</td><td>$(‘div’)</td><td>获取同一类标签的全有元素</td></tr><tr><td>并集选择器</td><td>$(‘div,p,li’)</td><td>选取多个元素</td></tr><tr><td>交集选择器</td><td>$(‘li.current’)</td><td>交集元素</td></tr></tbody></table></div><p><font color="#08a9b7" size="4">层级选择器：</font>后代选择器和子代选择器<a id="more"></a></p><div class="table-container"><table><thead><tr><th>名称</th><th>用法</th><th>描述</th></tr></thead><tbody><tr><td>自带选择器</td><td>$(‘ul&gt;li’)</td><td>使用&gt;号获取亲儿子层级的元素；注：并不会获取孙子层级的元素</td></tr><tr><td>后代选择器</td><td>$(‘ul li’)</td><td>使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等</td></tr></tbody></table></div><p><font color="#08a9b7" size="4">筛选选择器：</font>选择满足条件进行筛选选择</p><div class="table-container"><table><thead><tr><th>语法</th><th>用法</th><th>描述</th></tr></thead><tbody><tr><td>:first</td><td>$(‘li:first’)</td><td>获取第一个li元素</td></tr><tr><td>:last</td><td>$(‘li:last’)</td><td>获取最后一个li元素</td></tr><tr><td>:eq(index)</td><td>$(‘li:eq(2)’)</td><td>获取到的li元素中，选择索引号为2的元素，索引号index从0开始</td></tr><tr><td>:odd</td><td>$(‘li:odd’)</td><td>获取到li元素中，选择索引号为奇数的元素</td></tr><tr><td>:even</td><td>$(‘li:even’)</td><td>获取到的li元素中，选择索引号为偶数的元素</td></tr></tbody></table></div><p><font color="#189cbd" size="4">扩展：</font></p><div class="table-container"><table><thead><tr><th>语法</th><th>用法</th><th>说明</th></tr></thead><tbody><tr><td>parent()</td><td>$(‘li’).parent()</td><td>查找父级</td></tr><tr><td>children(selector)</td><td>$(‘ul’).children(‘li’)</td><td>相当于$(‘ul&gt;li’),最近一级</td></tr><tr><td>find(selector)</td><td>$(‘ul’).find(“li”)</td><td>相当于$(“ul li”),后代选择器</td></tr><tr><td>siblings(selector)</td><td>$(‘.first’).siblings(“li”)</td><td>查找兄弟节点，不包括本身</td></tr><tr><td>nextAll([expr])</td><td>$(‘.first’).nextAll()</td><td>查找当前元素之后所有的同辈元素</td></tr><tr><td>prevtAll([expr])</td><td>$(‘.last’).prevtAll()</td><td>查找当前元素之前所有的同辈元素</td></tr><tr><td>hasClass(class)</td><td>$(‘div’).hasClass(‘protected’)</td><td>检查当前的元素是否有某个特定的类</td></tr><tr><td>eq(index)</td><td>$(‘li’).eq(2)</td><td>相当于$(‘li:eq(2)’),index从0开始</td></tr></tbody></table></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心流</title>
      <link href="/2020/05/18/%E5%BF%83%E6%B5%81/"/>
      <url>/2020/05/18/%E5%BF%83%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p><font size="4" color="#29c7ca">心流的成因和特征：</font><br>第一，注意力。(自律、集中注意力)<br>第二，有一个愿意为之付出的目标。(目标是什么不要紧，只要那目标将他的注意力集中于此)<br>第三，有即时的回馈。<br>第四，因全神贯注于此，日常恼人的繁琐被忘却和屏蔽。<br>第五，达到了忘我的状态。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 爱好心理学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装依赖包</title>
      <link href="/2020/05/18/Linux%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E5%8C%85/"/>
      <url>/2020/05/18/Linux%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>apt -f install</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 语言与Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何安装linux中安装typora</title>
      <link href="/2020/05/18/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85linux%E4%B8%AD%E5%AE%89%E8%A3%85typora/"/>
      <url>/2020/05/18/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85linux%E4%B8%AD%E5%AE%89%E8%A3%85typora/</url>
      
        <content type="html"><![CDATA[<p>Typora给您既是读者又是作家的无缝体验。它删除了预览窗口，模式切换器，降价源代码的语法符号以及所有其他不必要的干扰。相反，它提供了真正的实时预览功能，可帮助您专注于内容本身。</p><p>如何在linux中安装typora：</p><p>第一步：</p><pre><code>wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -</code></pre><p>第二步：<a id="more"></a></p><pre><code>sudo add-apt-repository 'deb https://typora.io/linux ./'sudo apt-get update</code></pre><p>第三步：</p><pre><code>sudo apt-get install typora</code></pre><p>如果报错请查看<a href="https://kid1412.cc/blog/2020/03/12/%E6%97%A5%E5%B8%B8%E7%8A%AF%E9%94%99%E8%AF%AF/">12条</a></p><p>或者到<a href="https://www.typora.io/#linux">官网下载</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 应用与插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>remove卸载命令</title>
      <link href="/2020/05/18/remove%E5%8D%B8%E8%BD%BD%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/05/18/remove%E5%8D%B8%E8%BD%BD%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>sudo apt-get remove  XXX</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 语言与Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下安装.ded文件</title>
      <link href="/2020/05/18/Linux%E4%B8%8B%E5%AE%89%E8%A3%85-ded%E6%96%87%E4%BB%B6/"/>
      <url>/2020/05/18/Linux%E4%B8%8B%E5%AE%89%E8%A3%85-ded%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>cd到安装包目录   dpkg -i 安装包名字</p><p>注：如果无法安装请尝试一下方法</p><p>cd到安装包目录  rpm -ivh 安装包名字</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 语言与Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>话玖</title>
      <link href="/2020/05/17/%E8%AF%9D%E7%8E%96/"/>
      <url>/2020/05/17/%E8%AF%9D%E7%8E%96/</url>
      
        <content type="html"><![CDATA[<p>有时候 周围无意的一句话远比施暴的人更伤人</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活与话 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 话 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chmod777与555</title>
      <link href="/2020/05/17/chmod777%E4%B8%8E555/"/>
      <url>/2020/05/17/chmod777%E4%B8%8E555/</url>
      
        <content type="html"><![CDATA[<p>chmod修改文件与文件夹权限：<font color="#0dcc8d" size="4">chmod 777  xxx </font>所有用户都有读、写、执行权限。<font color="#0dcc8d" size="4">chmod 755 xxx</font> 所有用户都是读取、执行权限</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 语言与Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JQuery基本使用</title>
      <link href="/2020/05/16/JQuery%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/05/16/JQuery%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><font color="#28b0de" size="4"> JQuery中常见的两种入口函数：</font></p><pre><code class="js">第一种：简单易用$(function () {    ... // 此处是页面DOM加载完成的入口})第二种：繁琐，（不推荐）$(document).ready(function() {    ... 此处是页面DOM加载完成的入口})</code></pre><p><font color="#28b0de" size="4">JQuery中的顶级对象$:</font> </p><p>$是JQuery的顶级对象，相当于原生JavaScript中的window。把元素利用*包装成JQuery对象。<a id="more"></a></p><p><font color="#28b0de" size="4">JQuery对象和DOM对象：</font> </p><p><font color="#e5a490" size="3">  JQuery方法和原生js获取的元素是不一样的：</font></p><p>​               1.用原生的js获取来的对象就是DOM对象</p><p>​               2.JQuery方法获取的元素就是JQuery对象</p><p>  <font color="#e5a490" size="3">JQuery对象本质是：</font>利用$对DOM对象包装后产生的对象（伪数组形式存储）</p><hr><p>注：只有JQuery对象才能使用JQuery方法，DOM对象册使用原生的JavaScript方法.常用的是把DOM对象转换为JQuery对象</p><hr><p><font color="#28b0de" size="4">JQuery对象和DOM对象转换：</font> </p><p>   原生的一些属性和方法JQuery没有封装，需将JQuery对象转换为DOM对象才能使用</p><pre><code class="js">// 1.DOM对象转换成JQuery对象  var box = document.getElementById('box') // 获取  var JQueryObject = $(box) // 把DOM对象转换为JQuery对象// 2.JQuery对象转换为DOM对象  var domObject = $('div')[0] // 第一种  var domObject = $('div').get[0] // 第二种</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何下载公司github的代码</title>
      <link href="/2020/05/16/%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BD%E5%85%AC%E5%8F%B8github%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
      <url>/2020/05/16/%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BD%E5%85%AC%E5%8F%B8github%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>找个地方命令窗口输入<font color="#e50b6d" sizr="4">git clone 仓库地址</font>等待….</p><p><font color="#06bcaf" size="4">cd 仓库名</font></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法与面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>返回上两级目录</title>
      <link href="/2020/05/16/Linux%E7%9A%84cd%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/05/16/Linux%E7%9A%84cd%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>cd ../..返回上两级目录</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 语言与Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>话八</title>
      <link href="/2020/05/16/%E8%AF%9D%E5%85%AB/"/>
      <url>/2020/05/16/%E8%AF%9D%E5%85%AB/</url>
      
        <content type="html"><![CDATA[<p>不是所有的事情都能两全 任何事情 不管是好是坏 都要付出代价</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活与话 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 话 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>话七</title>
      <link href="/2020/05/16/%E8%AF%9D%E4%B8%83/"/>
      <url>/2020/05/16/%E8%AF%9D%E4%B8%83/</url>
      
        <content type="html"><![CDATA[<p>这世上那来什么幸与不幸    那全都是看你怎么解读</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活与话 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 话 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端交互动画优化</title>
      <link href="/2020/05/16/%E5%89%8D%E7%AB%AF%E4%BA%A4%E4%BA%92%E5%8A%A8%E7%94%BB%E4%BC%98%E5%8C%96/"/>
      <url>/2020/05/16/%E5%89%8D%E7%AB%AF%E4%BA%A4%E4%BA%92%E5%8A%A8%E7%94%BB%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>最基本的优化思路就是优化DOM的读写操作</p><p><font color="#192e4d" size="4">减少对DOM元素读操作：</font></p><p>缓存DOM引用</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法与面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>touch和mkdir</title>
      <link href="/2020/05/15/touch%E5%92%8Cmkdir/"/>
      <url>/2020/05/15/touch%E5%92%8Cmkdir/</url>
      
        <content type="html"><![CDATA[<p>创建文件：<font color="#229bcc" size="5">touch XXX</font> 创建文件夹：<font color="#1a6f94" size="5">mkdir XXX</font></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 语言与Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue如何实现组件缓存</title>
      <link href="/2020/05/15/Vue%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E7%BC%93%E5%AD%98/"/>
      <url>/2020/05/15/Vue%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>keep-alive：组件级缓存</p><p>两种模式：全局缓存/局部组件缓存</p><p>页面跳转到详情页面时，需要保持列表页的滚动条的深度，等返回的时候也然在这个位置。</p><p><font color="#395e92" size="4">使用方式：</font>keep-alive是抽象组件（或称为功能型组件），实际不会被渲染在    DOM树中。它的作用是在内存中缓存组件（不让组件销毁），等到下次渲染的时候，还保持其中的所有状态，并触发activated钩子函数。缓存的额需要通常出现在页面切换时</p><p><font color="#2f87b0" size="4">全局缓存 </font>    <a id="more"></a></p><pre><code class="js">&lt;keep-alive&gt;       &lt;router-view /&gt; &lt;/keep-alive&gt;</code></pre><p><font color="#2fb0a5" size="4">局部缓存：</font>使用keep-alive组件的include/exclude属性。include属性表示要缓存的组件名（组件定义时的name属性）</p><pre><code class="js">    &lt;!--缓存想要缓存的页面，实现后退不刷新--&gt;    &lt;!--加上v-if的判断，可以自定义想要缓存的组件，自定义在router里面--&gt;    &lt;keep-alive&gt;      &lt;router-view v-if="$route.meta.keepAlive"&gt;&lt;/router-view&gt;    &lt;/keep-alive&gt;    &lt;router-view v-if="!$route.meta.keepAlive"&gt;&lt;/router-view&gt;</code></pre><p>在router文件加上meta判断</p><pre><code class="js">export default new Router({    {    // home会被缓存    path:"/home",    component:home,    meta:{keepAlive: true}    },      {     // home不会被缓存    path:"/home",    component:home,    meta:{keepAlive: false}                       }                    })</code></pre><p><font color="#18919b" size="4">注：</font>如果想要看有没有缓存成功，可以再各个组件的created钩子里面打印输出标志，缓存成功就是首次进入页面，created会请求数据，后面就不会再次请求而是直接调用缓存的</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法与面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>watch用箭头函数会出现什么情况？</title>
      <link href="/2020/05/15/watch%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%EF%BC%9F/"/>
      <url>/2020/05/15/watch%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>this是undefined，typeError错误。Cannot read property ‘xxx’ of undefined</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法与面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>箭头函数和普通函数的区别</title>
      <link href="/2020/05/15/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/05/15/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>1.箭头函数没有this对象，因此不可以用构造函数，不能用call(), apply(), bin()这些方法去改变this指向</p><a id="more"></a><p>2.不绑定arguments对象，不过可以使用rest参数来解决</p><p>3.不能使用new操作符，会报错</p><p>4.没有prototype属性（原型）</p><p>5.不能作用生成器</p><p>总结：</p><p>箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或 new.target。这些函数表达式最适合用于非方法函数(non-method functions)，并且它们不能用作构造函数。</p><p>扩展：</p><p>箭头函数的 <code>IIEF</code>:</p><pre><code class="js">(() =&gt; {console.log('1');})(); </code></pre><p>上面的是可以，但是下面的写法就会报错</p><pre><code class="js">(() =&gt; {console.log('1');}());</code></pre><p>原因：</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法与面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex常用的属性</title>
      <link href="/2020/05/15/vuex%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7/"/>
      <url>/2020/05/15/vuex%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th>state</th><th>geters</th><th>muations</th><th>acions</th><th>modules</th></tr></thead><tbody><tr><td>全局基本数据</td><td>计算属性</td><td>提交更改数据的方法，同步</td><td>提交更改数据的方法，可以异步</td><td>分割成模块</td></tr></tbody></table></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法与面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mv命令</title>
      <link href="/2020/05/15/mv%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/05/15/mv%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p> Linux mv命令用来为文件或目录改名 或这文件或目录移动到其它位置</p><p>mv 源文件名 目标文件名   表示将源文件名改为目标文件名</p><p>命令格式：</p><div class="table-container"><table><thead><tr><th>命令格式</th><th>结果</th></tr></thead><tbody><tr><td>mv 文件名 文件名</td><td>将源文件名改为目标文件名</td></tr><tr><td>mv 文件名 目录名</td><td>将文件移动到目标目录</td></tr><tr><td>mv 目录名 目录名</td><td>目标目录已存在，将源目录移动到目标目录；目标目录不存在则改名</td></tr><tr><td>mv 目录名 文件名</td><td>出错</td></tr></tbody></table></div><p>参数：<a id="more"></a></p><div class="table-container"><table><thead><tr><th>-i</th><th>若存在同名文件，则向用户询问是否覆盖</th></tr></thead><tbody><tr><td>-f</td><td>覆盖已有文件时，不进行任何提示</td></tr><tr><td>-b</td><td>当文件存在时，覆盖前为其创建一个备份</td></tr><tr><td>-u</td><td>当源文件比目标文件新，或者目标文件不存在时，才执行移动此操作</td></tr><tr><td>-t</td><td>复制多个文件或文件夹</td></tr></tbody></table></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 语言与Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue的两种路由模式</title>
      <link href="/2020/05/15/Vue%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/15/Vue%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>在vue-router路由对象中，有两种模式：<font color="#F6416C">hash</font>和<font color="#9708CC">history</font>，默认的是hash模式</p><p>扩展:</p><p><font color="#130CB7" size="4">hash路由:</font>监听路由的变化：<code>onhashchange事件</code>，只有#后的地址发生变化，可以在window对象上监听：</p><pre><code class="js">window.onhashchange = function(event) {    let hash = loaction.hash}</code></pre><p><font color="#130CB7" size="4">history路由:</font>模式充分利用 <code>history.pushState</code> API 来完成 URL 跳转而无须重新加载页面。<a id="more"></a></p><pre><code class="js">const router = new VueRouter({  mode: 'history',  routes: [...]})</code></pre><p>注：使用history需要后台配置支持，因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问网页就会返回 404。</p><p>只需在服务器增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 <code>index.html</code> 页面，这个页面就是你 app 依赖的页面</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法与面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue全家桶</title>
      <link href="/2020/05/15/Vue%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
      <url>/2020/05/15/Vue%E5%85%A8%E5%AE%B6%E6%A1%B6/</url>
      
        <content type="html"><![CDATA[<p><font color="#0080FF">Vue  </font><font color="#DF3A01">vue-router</font>       <font color="#086A87">vue-cli </font>  <font color="#8A084B">  Vuex-resource</font></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法与面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由的动态获取</title>
      <link href="/2020/05/14/%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96/"/>
      <url>/2020/05/14/%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<p>第一种利用<font color="#4C83FF">$route.query</font>属性获取连接上的参数，url参数使用？形式</p><p>第二种利用<font color="#4C83FF">$route.params</font>获取参数，url形式是/参数形式</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法与面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jquery和react区别</title>
      <link href="/2020/05/14/jquery%E5%92%8Creact%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/05/14/jquery%E5%92%8Creact%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>React是UI库而JQuery则是工具库，然后就是对Dom操作的不同，<font color="#16d9e3" size="4">Reactjs</font>提供了一整套的vistualDom（虚拟Dom）所有的操作都在这个虚拟的额Dom上而非</p><p>真实的Dom，React默认这个真实Dom是不会被改变，而改变的只有虚拟的Dom，然后通过这个虚拟的Dom来对真实的Dom进行渲染。<font color="#37ecba" size="4">JQuery</font>则是操作真实的Dom，处理事件方式就是用选择器筛选出需要改变的Dom元素，或者监听Dom，最后改变真实的Dom来达到预期的结构</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法与面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.x与3.x脚手架的区别</title>
      <link href="/2020/05/14/2-0%E4%B8%8E3-0%E8%84%9A%E6%89%8B%E6%9E%B6%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/05/14/2-0%E4%B8%8E3-0%E8%84%9A%E6%89%8B%E6%9E%B6%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>3.x启动npm run serve</p><p>2.x启动npm run dev</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法与面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目脚手架的创建与运行</title>
      <link href="/2020/05/14/%E9%A1%B9%E7%9B%AE%E8%84%9A%E6%89%8B%E6%9E%B6%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/"/>
      <url>/2020/05/14/%E9%A1%B9%E7%9B%AE%E8%84%9A%E6%89%8B%E6%9E%B6%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>下载：</p><pre><code class="bash">npm install -g @vue/cli# ORyarn global add @vue/cli</code></pre><p>然后用<font color="#7AC5CD">vue –version</font>检查版本是否正确</p><p>创建项目：<font color="#7AC5CD">vue create  XXX</font></p><p>   注： 根据需要选择</p><p>运行项目：<font color="#7AC5CD">npm run serve</font></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法与面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue双向数据绑定的原理</title>
      <link href="/2020/05/13/Vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2020/05/13/Vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><font color="#00C5CD" size="4">vue的双向数据绑定：</font>是通过数据劫持 结合 发布订阅模式的方式实现。数据和视图同步，数据发生变化，视图也跟着变化，数据也随之发生改变。</p><p>简单来说就是通过Object对象的defineProperty属性，重写data的set和get函数来实现的</p><hr><p><font color="red">核心就是Object.defineProperty()方法</font></p><p><font color="#008B8B" size="5">扩展：</font>Object.defineProperty()方法</p><p>Object.defineProperty(obj，prop，descriptor)参数：obj（定义属性对象）prop（定义或修改的属性）descriptor（具体的改变方法）<a id="more"></a></p><p>用这个方法定义一个值，当调用时使用它里面的get方法，当给属性赋值时，又用到set方法</p><pre><code class="js">var obj = {}; Object.defineProperty(obj, 'hello',{     get: function () {         console.log('调用了get方法')     },     set: function (newVal) {         console.log('调用了set方法，方法的值为' + newVal)     } })； obj.hello;obj.hello = 'hi';</code></pre><p><font color="#00C5CD" size="5">JS双向数据绑定</font>通过添加事件监听keyup来触发set方法，而set在修改访问器属性的同时，在修改了dom样式，改变了span标签的文本</p><pre><code class="js">&lt;script&gt;   var obj = [];   // 定义一个空对象   var k = 'once'; // 赋予初始值    Object.defineProperty(obj, 'k', {        get: function () {            return k;        },        set: function (newK) {            k = newK;   // 定义k等于修改后的内容                // 让文本框的内容等于k            document.getElementById('a').value = k              // 让span的内容等于k            document.getElementById('b').innerHTML = k          }    });    document.addEventListener('keyup', function (e) {         //当在文本框输入内容时让对象里你定义的val等于文本框的值        obj.k = e.target.value;                                       })&lt;/script&gt;</code></pre><p><font color="#00C5CD" size="5">vue的双向数据绑定：</font>就是普通单向绑定和事件组合来完成的</p><pre><code class="vue">&lt;div id="vm"&gt;        &lt;p&gt;邮箱&lt;input v-model="email"&gt;&lt;/p&gt;            &lt;span&gt;{{email}}&lt;/span&gt;        &lt;p&gt;名字&lt;input v-model="name"&gt;&lt;/p&gt;     &lt;span&gt;{{name}}&lt;/span&gt;       &lt;/div&gt;        &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;        &lt;script type="text/javascript"&gt;            var vm = new Vue({                el: '#vm',                data: {                    email: '',                    name: ''                }            });       &lt;/script&gt;</code></pre><p><font color="red" size="5">理解：</font></p><p>①将vue中的data中的内容绑定到输入文本框和文本节点中</p><p>②文本框的内容改变时，vue实例中的data也同时发生改变</p><p>③当data中的内容发生改变时，输入框及文本节点的内容也发生变化</p><p><font color="#A52A2A">注：如果使用appendCid方法将原dom树中的节点添加到DocumenntFragment中时，会删除原来的节点</font></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法与面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>导航守卫的理解</title>
      <link href="/2020/05/12/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2020/05/12/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><font color="#04b8cf" size="4">导航守卫</font>主要用来<strong>通过跳转或取消的方式守卫导航</strong>。</p><p>​         简单来说就是路由跳转过程中的一些钩子函数</p><hr><p><font color="#04b8cf" size="4">扩展：</font></p><p>钩子函数执行顺序：</p><p>全局前置守卫：beforeEach——&gt;路由beforeEnter守卫——&gt;组件路由守卫beforeRouteEnter（this并不指向该组件实例）——&gt;全局解析守卫：beforeResolve——&gt;全局后置守卫：afterEach——&gt;组件生命周期：beforeCreate——&gt;组件生命周期created——&gt;组件生命周期beforeMount——&gt;组件声明周期mounted——&gt;组件路由守卫beforeRouteEnter的next回调</p><p><font color="#04b8cf" size="4">导航守卫分为：</font></p><p><code>全局</code>、<code>单个路由独享</code>、<code>组件内</code>三种。 <a id="more"></a></p><hr><p><font color="#04b8cf" size="4">全局：</font>指路由实例上直接操作的钩子函数，所有路由配置的组件都会触发，大白话就是触发路由就会触发这些钩子函数。</p><p><font color="#ed8c86">beforeEach</font>、<font color="#ed8c86">beforeResolve（2.5+）</font>、<font color="#ed8c86">afterEach</font></p><pre><code class="js">const router = new VueRouter({    router.beforeEach((to, from, next) =&gt; {    ....  })})</code></pre><p><font color="#ed8c86">[beforeEach]</font> :在路由跳转前触发，参数包括to，from，next作用：用于登录验证，路由没跳转前告知</p><p><font color="#ed8c86">[beforeResolve]（2.5+）</font> :以上类似，<a href="(https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#全局前置守卫)">官方文档</a>：区别是在导航被确认之前，<u><strong>同时在所有组件内守卫和异步路由组件被解析之后</strong></u>，解析守卫就被调用。</p><p><font color="#ed8c86">[afterEach]</font>:在路由跳转后触发，参数to ，from  发生在beforeEach和beforeResolve之后，beforeRouteEnter之前</p><hr><p><font color="#04b8cf" size="4">路由独享:</font>指单个路由配置的时候设置钩子函数</p><pre><code class="js">const router = new VueRouter({    roues: [        {        path: '',        component: ,        beforeEnter: (to, from ,next) =&gt; {           ....       }     }                         ]})</code></pre><p><font color="#ed8c86">[beforeEnter] ：</font>和…Each相同，都设置在…Each之后执行参数to,from,next</p><hr><p><font color="#04b8cf" size="4">组件内：</font>指在组件内执行钩子函数，类似组件的生命周期，相当于为路由组件添加生命周期钩子函数</p><p>  <font color="#ed8c86">beforeRouteEnter</font>、<font color="#ed8c86">beforeRouteUpdate（2.2+）</font>、<font color="#ed8c86">beforeRouteLeave</font></p><pre><code class="js"> export default {     name: '',     data () {         return {             ....         }     },      beforeRouteEnter (to, from, next) {          // 在渲染组件的对用路由被confirm前调用          // 不能用this！！不能用this！！不能用this！！          // this并不指向该组件实例      }，      beforeRouteUpdate (to, from, next) {          // 当前路由改变，组件被复用时调用          // 可以访问组件实例！！this！！      }，      beforeRouteLeave （to, from, next）{          // 导航离开组件的对应路由时调用          // 可以访问组件实例 ！！this！！      } }</code></pre><p><font color="#ed8c86">[beforeRouteEnter] :</font>路由之前调用，参数to，from，next</p><p>   在全局守卫beforeEach和独享守卫beforeEnter之后，全局beforeResolve和全局afterEach之前调用。在beforeCreate生命周期前触发。</p><p><strong><u>注：该守卫访问不到组件实例，this为undefined</u></strong></p><p><strong>★★★可以通过传一个回调给next来访问组件实例，在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数，可以在这个守卫中请求服务端获取数据，当成功获取并能进入路由时，调用next并在回调中通果vm访问组件实例进行赋值等操作需注意的是next中函数的调用在mounted之后：主要是为了确保能对组件实例的完整访问</strong></p><pre><code class="js">beforeRouteEnter （to, from, next）{    next (vm =&gt; {        // 通过vm访问组件实例    })}</code></pre><p><font color="#ed8c86">[beforeRouteUpdate] (2.2+) :</font>路由改变时，且组件被复用时调用（this可以！！！）参数：to，from， next</p><p><font color="#7719AA"><b>★★什么时候路由改变？ &amp;&amp;  什么时候组件被复用？</b></font></p><p>   1.带有动态参数的路径</p><p>   2.路由query变更时，该守卫会被调用</p><p><font color="#7719AA">★★★<b>补充：query和params的用法区别</b></font></p><p>   <font color="#e04f82" size="3">query:</font></p><pre><code class="js">this.$router.push({    path: '',    query: {        type: ,        typeDesc:     }})</code></pre><p>【query用path引入，params要用name引入。接收参数类似：<code>this.$route.query.name</code>和 <code>this.$route.params.name</code>                     query在浏览器地址中显示参数params则不显示 </p><p>【注：query刷新不会丢失query里面的数据。params刷新会丢失params里面的数据】<u><strong>看需求使用</strong></u>      </p><p>​    如：刷新获取不同的值用params，反之就用query】</p><p><font color="#e04f82" size="3">params:</font></p><pre><code class="js">this.$router.push({    name: '',    params: {        type: ,        typeDesc:    }})</code></pre><p><font color="#ed8c86">[beforeRouteLeave] :</font>导航组件离开组件的对应路由时调用（this可以！！！）</p><p>参数：to, from, next</p><hr><p><font color="#04b8cf" size="4">回调参数:</font>【重点★★★★】</p><p>to: 目标路由对象</p><p>from：离开的路由对象</p><p>next：下一个钩子</p><p>值得注意的是但凡涉及到next参数的钩子，需调用next（）才能继续执行下一个钩子，否则路由跳转会停止。还有就是如果要中断当前的导航要调用next(false)【用于登录验证不通过处理】，URL的改变（手动或浏览器回退按钮）会让URL地址重置到from路由对应的地址。当然next也可以如以下方法使用：next(‘/‘)或next({path:’/‘}):跳转到一个不同的地址。白话就是当前导航被中断，则执行一个新的导航。参数<span class="exturl"><a class="exturl__link" href="https://router.vuejs.org/zh/guide/essentials/navigation.html" target="_blank" rel="noopener">router.push</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>一致</p><p>beforeRouteEnter钩子中的next（（vm）=&gt; {}）内接受的回调函数参数为当前组件的实例vm，在生命周期mounted之后调用。最后执行的钩子函数</p><p>next(error)：（v2.4.0+）如果传入next的参数是一个Error实例，则导航会被终止该错误会被传递给<span class="exturl"><a class="exturl__link" href="https://router.vuejs.org/zh/api/#router-onerror" target="_blank" rel="noopener">router.onError</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>注册过得回调</p><p><strong>被调用的错误如以下情形：</strong></p><blockquote><ul><li>错误在一个路由守卫函数中被同步抛出；</li><li>错误在一个路由守卫函数中通过调用 <code>next(err)</code> 的方式异步捕获并处理；</li><li>渲染一个路由的过程中，需要尝试解析一个异步组件时发生错误。</li></ul></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法与面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clear命令</title>
      <link href="/2020/05/12/clear%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/05/12/clear%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>clear ：清空终端</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 语言与Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何安装Cmder</title>
      <link href="/2020/05/12/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85Cmder/"/>
      <url>/2020/05/12/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85Cmder/</url>
      
        <content type="html"><![CDATA[<p>  替换win10自带的<code>cmd</code>和<code>power shell</code>，两项方案：</p><p>​    方案一：<code>Windows terminal</code></p><p>在微软商场下载<code>Windows terminal</code>不过只能win10下载而且版本号要升级到1903版本以上</p><p>  方案二：<code>Cmder</code>    </p><p>​    在<span class="exturl"><a class="exturl__link" href="https://cmder.net/" target="_blank" rel="noopener">官网</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>下载Cmder,不要下载Mini（不支持Git）下载Download Full</p><p>​    ①安装：把下载的压缩包解压到<code>C:\Users\XXX</code>进入文件夹（免安装直接运行但是需要配置）</p><p>​    ②需要把这个地址（解压的地址）加到系统的path环境中   <strong><u>(Cmder的c要大写！！！Cmder的c要大写！！！Cmder的c要大写！！！)</u></strong>      <a id="more"></a></p><blockquote><pre><code>   win--&gt;搜索编辑系统环境变量--&gt;环境变量--&gt;用户变量/系统变量--&gt;新建--&gt;变量名CMDER_ROOT/值**(解压地址+Cmder.exe)**</code></pre></blockquote><p>   ③配置<code>cmder</code>到右键菜单：<strong>右键Cmder.exe属性-兼容性-以管理员身份运行此程序</strong>然后重新打开Cmder.exe输入<code>Cmder.exe /REGISTER ALL</code></p><p>补充：<code>Cmder.exe /REGISTER ALL</code>开头一定大写，有可能会报错</p><p>也可以到<span class="exturl"><a class="exturl__link" href="https://github.com/cmderdev/cmder/wiki/Setting-up-Environment-Variables" target="_blank" rel="noopener">github</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>上参考官方设置</p><hr><p>了解：</p><p><code>Windows terminal</code>是微软在2019年5月6日至5月8日的 Build 2019 大会上展示了 <code>Windows Terminal</code>且开源</p><p><code>Cmder</code>是一个增强型命令行工具，不仅可以使用windows下的所有命令，也可以使用linux的命令,shell命令。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 应用与插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译的三个步骤（了解）</title>
      <link href="/2020/05/10/%E7%BC%96%E8%AF%91%E7%9A%84%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4/"/>
      <url>/2020/05/10/%E7%BC%96%E8%AF%91%E7%9A%84%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<p> 分词/词法分析（Tokenizing/Lexing）</p><p>   将由字符组成的字符串分解成有意义的代码块，被称为<code>词法单元</code></p><p>他们俩的主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的</p><p>解析/语法分析（Parsing）</p><p> 将词法单元流（<code>数组</code>）转换成一个有元素逐级嵌套所1组成的代表了程序语法结构的书，被称为<code>抽象语法树</code>也就是常说的AST，全名为Abstract Syntax Tree</p><p>代码生成</p><p>将AST转化为可执行代码的过程称为代码生成</p><p><strong><u>注：这里说的是传统编译器</u></strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>话六</title>
      <link href="/2020/05/08/%E8%AF%9D%E5%85%AD/"/>
      <url>/2020/05/08/%E8%AF%9D%E5%85%AD/</url>
      
        <content type="html"><![CDATA[<p>生命中总有不期而遇的惊喜和生生不息的希望。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活与话 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 话 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>话五</title>
      <link href="/2020/04/27/%E8%AF%9D%E4%BA%94/"/>
      <url>/2020/04/27/%E8%AF%9D%E4%BA%94/</url>
      
        <content type="html"><![CDATA[<p>记忆是一种相聚的方式，放下是一种自由的形式。不必悲伤，不必忧愁，邂逅的回忆都是美好的故事。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活与话 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 话 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>话四</title>
      <link href="/2020/04/26/%E8%AF%9D%E5%9B%9B/"/>
      <url>/2020/04/26/%E8%AF%9D%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<p>如果结果不如你所愿 就在尘埃落定的那一刻，奋力一搏！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活与话 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 话 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="/2020/04/25/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/04/25/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p><code>冒泡排序:</code>的实现思路是比较任何两个相邻的项, 如果前者比后者大, 则将它们互换位置.</p><p>​    生成指定个数的随机数组</p><pre><code class="js">   const generateArr = (num = 10) =&gt; {  let arr = []  for(let i = 0; i&lt; num; i++) {    let item = Math.floor(Math.random() * (num + 1))    arr.push(item)  }  return arr}</code></pre><p>​      <code>冒泡排序:</code>         <a id="more"></a></p><pre><code class="js">bubbleSort(arr = []) {    let lkz = arr.length    for(let i = 0; i&lt; lkz; i++) {      for(let j = 0; j &lt; lkz - 1; j++) {        if(arr[j] &gt; arr[j+1]) {          [arr[j], arr[j+1]] = [arr[j+1], arr[j]]        }      }    }    return arr  }</code></pre><p> <code>const arr = generateArr(60)</code></p><p>   <code>冒泡排序优化:</code></p><pre><code class="js">bubbleSort(arr = []) {  let lkz = arr.length  // 优化  for(let i = 0; i&lt; lkz; i++) {    for(let j = 0; j &lt; lkz - 1 - i; j++) {      if(arr[j] &gt; arr[j+1]) {        // 置换        [arr[j], arr[j+1]] = [arr[j+1], arr[j]]      }    }  }  return arr}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法与面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性思维</title>
      <link href="/2020/04/21/%E7%BA%BF%E6%80%A7%E6%80%9D%E7%BB%B4/"/>
      <url>/2020/04/21/%E7%BA%BF%E6%80%A7%E6%80%9D%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<p>引：<code>通常夸大生活事件所带来的消极影响的倾向称之为“恐怖化”</code></p><p>而线性思维所带来最大的负面影响，就是让人容易产生恐怖化的情绪</p><p>一但有什么事情没有按照既定的线性往上发展的时候，我们就会给自己给自己制造障碍，自己给自己加戏，对，你没听错是加戏。但实际上，让我们焦头烂额的事情其实是受制于这样的线性思维，往往会刻意夸大现在的痛苦….</p><p>1.用<code>追求卓越</code>来替代<code>追求优秀</code></p><p>2.紧盯<code>别人</code>的成功，不如记录<code>自己</code>的想法</p><p>3.再多思考一层</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 爱好心理学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>token</title>
      <link href="/2020/04/18/token/"/>
      <url>/2020/04/18/token/</url>
      
        <content type="html"><![CDATA[<p><code>响应拦截器：</code> 处理token过期问题</p><p> 替换token</p><a id="more"></a><pre><code class="js">// Add a 响应拦截器 interceptorrequest.interceptors.response.use(function (response) {  // Any status code that lie within the range of 2xx cause this function to trigger  // Do something with response data  return response}, async function (error) {  // 有错误到这里来,只处理401错误(是由token过期，错误导致)。  if (error.response.status === 401) {    if (store.state.user &amp;&amp; store.state.user.refresh_token) {      try {        // 用refresh_token去求一个特殊的接口以获取新的token        const result = await axios({          url: 'http://ttapi.research.itcast.cn/app/v1_0/authorizations',          method: 'PUT',          headers: {            Authorization: `Bearer ${store.state.user.refresh_token}`          }        })        // 从接口返加值中去取出新token，更新到当前的vuex中        // mutations去改token        store.commit('updateToken', result.data.data.token)        console.log('更新token ok')        // console.log(result)        // error.config 就是当前错误发生时，axios中的配置        // 更新了token请求重发一次        return request(error.config)        // store.state.user.token = result.data.data.token      } catch (e) {        console.log('更新token，refresh_token 失败')        // 消除vuex的token        store.commit('setUser', null)        // 必须要重新登陆        router.push({          path: '/login',          query: {            // router中有一个属性currentRoute            from: router.currentRoute.fullPath          }        })      }    } else {      console.log('没有refresh token,准备去重新登陆吧')      router.push({        path: '/login',        query: {          // router中有一个属性currentRoute          from: router.currentRoute.fullPath        }      })    }    console.log('响应拦截器')    console.dir(error)  } else {    return Promise.reject(error)  }})</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>节流与防抖</title>
      <link href="/2020/04/17/%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/"/>
      <url>/2020/04/17/%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/</url>
      
        <content type="html"><![CDATA[<p><code>防抖:</code>抖：高频率的发送请求</p><p><code>思路：</code>当函数被调用时，不立即执行，而是延迟10秒执行。</p><p>如果在这10秒内再次调用了这个函数，则从当前被调用的时间开始计算</p><a id="more"></a><pre><code class="js">hSearch () { if (this.timer) {    cleraTimeout(this.timer) }   this.timer = setTimeout(async () =&gt; {     if (!this.keyword) {      return}   const result = await getSearchSuggestions(this.keyword)this.searchSuggestions = result.data.data.options}, 0.3 * 1000)}</code></pre><p><code>节流：</code>低频率发送请求</p><p><code>思路：</code>如果这个函数距离上一次被调用的时间之间相隔不到10秒，则本次调用，不执行代码</p><p>两次有效调用时间，并且至少相隔10秒</p><pre><code class="js">hSearch () {// 只有this.timer是null，才会开启下一个定时器 if (!this.timer) {// 只要setTimeout一执行，this.timer就有值了   this.timer = setTimeout(async () =&gt; {      this.timer = null      if (!this.keyword) {         return}  const result = await getSearchSuggestions(this.word)}, 0.3 * 1000)}}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 节流与防抖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>话三</title>
      <link href="/2020/04/16/%E8%AF%9D%E4%B8%89/"/>
      <url>/2020/04/16/%E8%AF%9D%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p>正义从来不是道德的标杆，而是立场的选择</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活与话 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 话 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>话二</title>
      <link href="/2020/04/14/%E8%AF%9D%E4%BA%8C/"/>
      <url>/2020/04/14/%E8%AF%9D%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>人会有<code>前</code>  <code>后</code>的观念，只不过因为视野太小， 所谓的前进 也就只是向着狭小视野的方向移动罢了</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活与话 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 话 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于如何使用跨组件</title>
      <link href="/2020/04/14/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%B7%A8%E7%BB%84%E4%BB%B6/"/>
      <url>/2020/04/14/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%B7%A8%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>事件总线三种方法：</p><p><code>$on</code>,<code>$emit</code>,<code>$off</code> </p><ul><li><p>画图： </p><p>1.index.vue. </p><p>2.articleList.vue </p><p>3.moreAction.vue </p><p>4.channelEdit.vue </p><p>eventBus </p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Electron安装问题</title>
      <link href="/2020/04/13/Electron%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/"/>
      <url>/2020/04/13/Electron%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="关于如何安装eletron卡在node-install-js的解决方法">          <a href="#关于如何安装eletron卡在node-install-js的解决方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#关于如何安装eletron卡在node-install-js的解决方法" class="headerlink" title="关于如何安装eletron卡在node install.js的解决方法"></a>关于如何安装eletron卡在node install.js的解决方法</h3>      <p>①在<code>.npmrc</code>里写入以下数据：在<code>C:\Users\***</code>下</p><p><code>electron_mirror="https://npm.taobao.org/mirrors/electron/"</code></p><p>②<code>npm</code>安装<code>node-sass</code>   网速慢可以切换淘宝的镜像源或<code>npm i nrm</code>工具</p><p>在<code>.npmrc</code>里写入以下数据：</p><p> <code>registry=https://registry.npm.taobao.org</code> <code>sass_binary_site=https://npm.taobao.org/mirrors/node-sass/</code> <code>phantomjs_cdnurl=http://npm.taobao.org/mirrors/phantomjs</code> <code>ELECTRON_MIRROR=http://npm.taobao.org/mirrors/electron/</code></p><p>注：需要删除已安装的<code>node_modules</code>然后重新安装<code>electron</code>，如果有其它的包则需要重新<code>npm install</code>下。<del>应该都有初始化吧<code>npm init</code></del></p><p>​    Eg:<code>npm install --save-dev electron</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 应用与插件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>话一</title>
      <link href="/2020/04/09/%E8%AF%9D%E4%B8%80/"/>
      <url>/2020/04/09/%E8%AF%9D%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>要别人肯定你的同时，首先自己要先肯定自己，自己若不能肯定自己，那你最大的敌人永远也是你自己，这个观念讲起来很简单，但你有认真想过吗？自己是如何输给自己，又是如何赢了自己，又要如何才能超越自己。有些事没必要想的太复杂。犹豫不决，所换到的结果就是浪费时间，时间不是你想掌握就会停止的东西..所以珍惜现在吧</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活与话 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 话 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex的核心</title>
      <link href="/2020/04/08/vuex%E7%9A%84%E6%A0%B8%E5%BF%83/"/>
      <url>/2020/04/08/vuex%E7%9A%84%E6%A0%B8%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<p><code>state：</code>作用：定义全局数据(<code>保存所以公共数据</code>)。类似data</p><pre><code class="js">export default new Vue.store({    state:{    }  })export default store</code></pre><p>获取数据：<code>state</code></p><p>直接使用：<code>1.this.$store.state.自定义</code></p><p>映射的方式：<code>2.computed:{...mapState([''])}</code>     <a id="more"></a></p><p><u><strong>注：在Vue中不推荐直接在组件内部通过<code>this.$store.state.全局数据名称=新值</code>来修改Vue</strong></u></p><p><code>mutation</code>作用：修改公共数据</p><pre><code class="js">const store = new Vuex.Store({    state: {    },    mutations: {    }})</code></pre><p>修改：<code>mutations</code></p><p>直接使用：<code>this.$store.commit('','')</code><strong><u>不推荐</u></strong></p><p><code>map</code>映射的方式：<code>{methods:{// 相当于是在当前组件内部的methods加了对应的方法   ...mapMutations(['mutation名'，'mutation名'])}}</code></p><p><code>※action</code>作用：可以执行异步代码；可以同时调用多个mutation</p><pre><code class="js">new Vuex.store ({    state: {},    actions: {       函数名 :function（参数1，参数2）{   }  }})</code></pre><p>使用：<code>actions</code></p><p>直接使用：<code>this.$store.dispatch</code></p><p><code>map</code>映射的方式：<code>methods:{...mapActions ([''])}</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组建之间共享方式</title>
      <link href="/2020/04/06/%E7%BB%84%E5%BB%BA%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F/"/>
      <url>/2020/04/06/%E7%BB%84%E5%BB%BA%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><code>vuex</code>独立于所有的组件</p><p>作用</p><p>   <code>对所以组件需要用到的公共数据,进行管理</code></p><p>是一种新的组建之间数据共享的方式</p><p><code>父子</code></p><p><code>eventBus</code></p><p><code>Vuex</code></p><p><code>payload</code></p><p><code>mapMutations</code></p><p><code>mapState</code></p><p>actions 中 调用 ———————— 去修改数据？ </p><p><code>mutation</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vertical-align</title>
      <link href="/2020/03/24/vertical-align/"/>
      <url>/2020/03/24/vertical-align/</url>
      
        <content type="html"><![CDATA[<p>  <span class="exturl"><a class="exturl__link" href="https://developer.mozilla.org/en-US/docs/CSS" target="_blank" rel="noopener">CSS</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 的属性 <strong><code>vertical-align</code></strong> 用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。</p><p>语法：vertical-align: ;</p>        <h4 id="行内元素的值">          <a href="#行内元素的值" class="heading-link"><i class="fas fa-link"></i></a><a href="#行内元素的值" class="headerlink" title="行内元素的值:"></a><strong>行内元素的值:</strong></h4>      <p>​    <strong><u>相对父元素的值：</u></strong>这些值使元素相对其父元素垂直对齐：</p><p><code>baseline</code></p><p>使元素的基线与父元素的基线对齐。</p><p><code>sub</code></p><p>使元素的基线与父元素的下标基线对齐。<a id="more"></a></p><p><code>super</code></p><p>使元素的基线与父元素的上标基线对齐。</p><p><code>text-top</code></p><p>使元素的顶部与父元素的字体顶部对齐。</p><p><code>text-bottom</code></p><p>使元素的底部与父元素的字体底部对齐。</p><p><code>middle</code></p><p>使元素的中部与父元素的基线加上父元素x-height（译注：<span class="exturl"><a class="exturl__link" href="https://www.zhangxinxu.com/wordpress/2015/06/about-letter-x-of-css/" target="_blank" rel="noopener">x高度</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>）的一半对齐。</p><p><code>&lt;length&gt;</code></p><p>使元素的基线对齐到父元素的基线之上的给定长度。可以是负数。</p><p><code>&lt;percentage&gt;</code></p><p>使元素的基线对齐到父元素的基线之上的给定百分比，该百分比是<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-height" target="_blank" rel="noopener"><code>line-height</code></a>属性的百分比。可以是负数。</p><p><strong><u>相对行的值：</u></strong>使元素相对整行垂直对齐</p><p><code>top</code></p><p>使元素及其后代元素的顶部与整行的顶部对齐。</p><p><code>bottom</code></p><p>使元素及其后代元素的底部与整行的底部对齐。</p><p>没有基线的元素，使用外边距的下边缘替代。</p>        <h4 id="表格单元格的值">          <a href="#表格单元格的值" class="heading-link"><i class="fas fa-link"></i></a><a href="#表格单元格的值" class="headerlink" title="表格单元格的值"></a><strong>表格单元格的值</strong></h4>      <p><code>baseline</code> (以及 <code>sub</code>, <code>super</code>, <code>text-top</code>, <code>text-bottom</code>, <code>&lt;length&gt;</code>, <code>&lt;percentage&gt;</code>)</p><p>使单元格的基线，与该行中所有以基线对齐的其它单元格的基线对齐</p><p><code>top</code></p><p>使单元格内边距的上边缘与该行顶部对齐。</p><p><code>middle</code></p><p>使单元格内边距盒模型在该行内居中对齐。</p><p><code>bottom</code></p><p>使单元格内边距的下边缘与该行底部对齐。</p><p>可以是负数。</p><p><strong>注： <code>vertical-align</code> 只对行内元素、表格单元格元素生效：不能用它垂直对齐<span class="exturl"><a class="exturl__link" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Block-level_elements" target="_blank" rel="noopener">块级元素</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css属性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重定向与编程式导航与路由嵌套</title>
      <link href="/2020/03/21/%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA/"/>
      <url>/2020/03/21/%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA/</url>
      
        <content type="html"><![CDATA[<h4 id="vue-router-重定向">          <a href="#vue-router-重定向" class="heading-link"><i class="fas fa-link"></i></a><a href="#vue-router-重定向" class="headerlink" title="vue-router-重定向"></a><strong>vue-router-重定向</strong></h4>      <p>  指：访问某一个路由，自动跳转到另外一个路径</p><p> 核心代码：{path:”/“,redirect:”/home}</p>        <h4 id="vue-touter-编程式导航">          <a href="#vue-touter-编程式导航" class="heading-link"><i class="fas fa-link"></i></a><a href="#vue-touter-编程式导航" class="headerlink" title="vue-touter-编程式导航"></a><strong>vue-touter-编程式导航</strong></h4>      <p>指：通过js的方式触发路由的跳转</p><p>核心代码：<code>提供路由相关函数</code>跳转方法this.$router.push()</p><p>  注：<code>route是获取路由相关信息</code>路由传参  this.$route.params <a id="more"></a></p>        <h4 id="vue-router-路由嵌套">          <a href="#vue-router-路由嵌套" class="heading-link"><i class="fas fa-link"></i></a><a href="#vue-router-路由嵌套" class="headerlink" title="vue-router-路由嵌套"></a><strong>vue-router-路由嵌套</strong></h4>      <p>指：套娃</p><p>核心：children</p><p>引：要进行路由的嵌套，只需要在<strong><u>一级路由规则</u></strong>下，加上一个属性<code>children</code>，即可定义二级路由规则。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue-router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语法糖</title>
      <link href="/2020/03/20/%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
      <url>/2020/03/20/%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
      
        <content type="html"><![CDATA[<p>​       Vue指令</p><p>1.v-model 指令是一个语法糖（简写）就是简写了：:value 与 @input 两段代码</p><pre><code>:value = 'msg' 与 @input = 'msg=$event.target.value'</code></pre><p>class:  :class绑定类</p><p>style: 绑定行内样式</p> <a id="more"></a><p>v-mode: 1</p><p>v-cloak:  [v-cloak]{display:none};      浏览器解析插值表达式闪烁问题</p><p>v-once:指渲染一次，之后不受影响 没有值</p>        <h3 id="自定义过滤器：">          <a href="#自定义过滤器：" class="heading-link"><i class="fas fa-link"></i></a><a href="#自定义过滤器：" class="headerlink" title="自定义过滤器："></a><strong>自定义过滤器：</strong></h3>              <h4 id="全局：-api使用方法-Vue-filter-‘过滤器名称’-’-处理函数’">          <a href="#全局：-api使用方法-Vue-filter-‘过滤器名称’-’-处理函数’" class="heading-link"><i class="fas fa-link"></i></a><a href="#全局：-api使用方法-Vue-filter-‘过滤器名称’-’-处理函数’" class="headerlink" title="全局： api使用方法 Vue.filter(‘过滤器名称’,’ 处理函数’)"></a><strong>全局：</strong> api使用方法 Vue.filter(‘过滤器名称’,’ 处理函数’)</h4>      <pre><code>    Vue.filter('up',(value)=&gt;{})</code></pre>        <h4 id="局部：vue实例管理的视图才可以使用">          <a href="#局部：vue实例管理的视图才可以使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#局部：vue实例管理的视图才可以使用" class="headerlink" title="局部：vue实例管理的视图才可以使用"></a><strong>局部：</strong>vue实例管理的视图才可以使用</h4>      <pre><code>const vm = new Vue ({  filter:{  up(value){}  }el:''data:{}})</code></pre><p>使用过滤器：进行格式转换，使用过滤器</p><pre><code>&lt;div&gt; {{***|up}} 术语：管道符&lt;/div&gt;</code></pre>        <h3 id="Vue操作DOM-获取dom操作dom">          <a href="#Vue操作DOM-获取dom操作dom" class="heading-link"><i class="fas fa-link"></i></a><a href="#Vue操作DOM-获取dom操作dom" class="headerlink" title="Vue操作DOM:获取dom操作dom"></a>Vue操作DOM:获取dom操作dom</h3>      <p> 1.<code>Vue.filter('过滤器名称','处理函数')</code>固定</p><p>2.<code>filter:{'过滤器名称':'处理函数'}</code>固定</p><p>3.<code>处理函数return使用固定</code></p><p>dom：给需要获取的表签加上ref属性</p><p>eg:<code>&lt;div ref='myDom'&gt;&lt;/div&gt;</code>        </p><p> 1.<code>ref固定</code></p><p>2.<code>this.$refs也是固定</code></p><p>3.<code>myDom自定</code></p>        <h3 id="Vue自定义指令">          <a href="#Vue自定义指令" class="heading-link"><i class="fas fa-link"></i></a><a href="#Vue自定义指令" class="headerlink" title="Vue自定义指令"></a><strong>Vue自定义指令</strong></h3>              <h4 id="全局自定义指令：Vue-directive-‘指令的名称’-’指令的配置对象’-基本语法">          <a href="#全局自定义指令：Vue-directive-‘指令的名称’-’指令的配置对象’-基本语法" class="heading-link"><i class="fas fa-link"></i></a><a href="#全局自定义指令：Vue-directive-‘指令的名称’-’指令的配置对象’-基本语法" class="headerlink" title="全局自定义指令：Vue.directive(‘指令的名称’,’指令的配置对象’)  基本语法"></a><strong>全局自定义指令：</strong>Vue.directive(‘指令的名称’,’指令的配置对象’)  基本语法</h4>      <p>指令的名字在定义时候不需要加v-，在是用的时候才需要加v-</p><pre><code>固定属性：inserted 在使用指令的元素渲染完毕后触发的函数这个函数执行了，代表元素渲染完毕，才可以操作元素。最后根据你指令的需求，实现业务逻辑。el 是使用指令的dom元素 Vue.directive('focus', {   inserted (el) {     el.focus()       dom提供的api用了获取焦点   }})</code></pre>        <h4 id="局部自定义指令：-directives-key-value-基本语法">          <a href="#局部自定义指令：-directives-key-value-基本语法" class="heading-link"><i class="fas fa-link"></i></a><a href="#局部自定义指令：-directives-key-value-基本语法" class="headerlink" title="局部自定义指令： directives:{ key: value }基本语法"></a><strong>局部自定义指令：</strong> directives:{ key: value }基本语法</h4>      <p>key是 指令的名称 要求：定义时候不需要加v-，在是用的时候才需要加v-</p><pre><code>value是 指令的配置对象  directives: {      focus: {        inserted (el) {      el.focus()             }         }      },       el: '#app'       })</code></pre><p>vue的计算属性：</p><pre><code>computed: {         //     reversedMessage () {      // 反转逻辑，处理之后的结果，是一定要return出去      return this.message.split('').reverse().join('')    }  }})</code></pre><p>使用：直接使用</p><pre><code>&lt;div id="app"&gt;  {{reversedMessage}}&lt;/div&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>术语与指令</title>
      <link href="/2020/03/15/%E6%9C%AF%E8%AF%AD%E4%B8%8E%E6%8C%87%E4%BB%A4/"/>
      <url>/2020/03/15/%E6%9C%AF%E8%AF%AD%E4%B8%8E%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>选项：</p><p>el: 获取指定的容器（具体的标签）element的缩写注：不能指定html和body容器作为试图容器</p><p>data: 数据驱动视图  响应式数据必须是 <strong>显性的声明</strong>       响应式数据必须在data当中提前声明</p><p>methods: 声明函数   可以给vm使用也可以提供视图使用 不可使用箭头函数</p> <a id="more"></a><p>指令： 标签的扩展功能属性</p><p>v-text ：相当于innerText</p><p>v-html：相当于innerHTML</p><p>v-show：样式隐藏display：none </p><ul><li><p>v-show使用场景：当元素要频繁的切换显示和隐藏 </p></li><li><p>v-if使用常用场景：当渲染的时候，就需要判断是否显示，今后不需要频繁切换</p></li><li><p>true显示 false 隐藏</p></li></ul><p>v-if：通过创建和移除元素隐藏</p><p>v-on：事件   简写方式：@click=处理函数</p><p>如果给绑定的函数传参需要带括号而且必须带$event</p><p>  事件修饰符</p><p>v-for：遍历 in 或of都一样</p><p>v-bind：</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前后端的身份验证（概念）</title>
      <link href="/2020/03/12/%E5%89%8D%E5%90%8E%E7%AB%AF%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%EF%BC%88%E6%A6%82%E5%BF%B5%EF%BC%89/"/>
      <url>/2020/03/12/%E5%89%8D%E5%90%8E%E7%AB%AF%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%EF%BC%88%E6%A6%82%E5%BF%B5%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>Web 开发模式：</strong></p>        <h4 id="1-服务器端渲染的传统模式Web开发模式">          <a href="#1-服务器端渲染的传统模式Web开发模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-服务器端渲染的传统模式Web开发模式" class="headerlink" title="1.服务器端渲染的传统模式Web开发模式"></a>1<strong>.服务器端渲染的传统模式Web开发模式</strong></h4>      <p>服务器通过字符串的拼接，动态生成的</p><p><strong>优点：</strong></p><p>① 前端耗时少。因为服务器端负责动态生成 HTML 内容，浏览器只需要直接渲染页面即可。尤其是移动端，更省电。</p><p>② 有利于SEO。因为服务器端响应的是完整的 HTML 页面内容，所以爬虫更容易爬取获得信息，更有利于 SEO。</p><p><strong>缺点：</strong>  <a id="more"></a></p><p>① 占用服务器端资源。即服务器端完成 HTML 页面内容的拼接，如果请求较多，会对服务器造成一定的访问压力。</p><p>② 不利于前后端分离，开发效率低。使用服务器端渲染，则无法进行分工合作，尤其对于前端复杂度高的项目，不利于<br>项目高效开发。</p>        <h4 id="2-前后端分离的新型Web开发模式">          <a href="#2-前后端分离的新型Web开发模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-前后端分离的新型Web开发模式" class="headerlink" title="2.前后端分离的新型Web开发模式"></a><strong>2.前后端分离的新型Web开发模式</strong></h4>      <p>依赖于 Ajax 技术，也就是后端只负责提供 API 接口，前端使用 Ajax 调用接口的开发模式</p><p><strong>优点：</strong></p><p>① 开发体验好。前端专注于 UI 页面的开发，后端专注于api 的开发，且前端有更多的选择性。</p><p>② 用户体验好。Ajax 技术的广泛应用，极大的提高了用户的体验，可以轻松实现页面的局部刷新。</p><p>③ 减轻了服务器端的渲染压力。因为页面最终是在每个用户的浏览器中生成的。</p><p>缺点：</p><p>① 不利于 SEO（解决方案：利用Vue、React等前端框架SSR）</p>        <h4 id="如何选择-Web-开发模式">          <a href="#如何选择-Web-开发模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何选择-Web-开发模式" class="headerlink" title="如何选择 Web 开发模式"></a><strong>如何选择 Web 开发模式</strong></h4>      <p>看需求  没有复杂的交互用服务器……..</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见错误</title>
      <link href="/2020/03/12/%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"/>
      <url>/2020/03/12/%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="1-nodemon不是内部或外部命令，也不是可运行的程序">          <a href="#1-nodemon不是内部或外部命令，也不是可运行的程序" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-nodemon不是内部或外部命令，也不是可运行的程序" class="headerlink" title="1.nodemon不是内部或外部命令，也不是可运行的程序"></a><strong>1.nodemon不是内部或外部命令，也不是可运行的程序</strong></h3>      <p>问题解决： 全局安装nodemon包，这样新创建的node.js应用都可以使用nodemon 运行起来   </p><p>  <code>npm install -g nodemon</code></p>        <h3 id="2-不小心把磁盘变成EFI分区了">          <a href="#2-不小心把磁盘变成EFI分区了" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-不小心把磁盘变成EFI分区了" class="headerlink" title="2.不小心把磁盘变成EFI分区了"></a><strong>2.不小心把磁盘变成EFI分区了</strong></h3>      <p>解决办法：</p><p>用管理员打开 CMD 或者 PowerShell</p><p>第一步——输入<code>diskpart</code> 提示：在计算机上：*****</p><p>第二步——输入<code>list vol</code> 显示EFI分区<a id="more"></a></p><p>第三步——输入<code>sel vol</code>多余EFI分区的号<br>卷 * 是所选的卷</p><p>第三步——<code>del vol override</code>成功删除了卷</p><p>注：别删错EFI分区</p>        <h3 id="3-U盘启动盘提示缺少mmx64-efi的问题">          <a href="#3-U盘启动盘提示缺少mmx64-efi的问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-U盘启动盘提示缺少mmx64-efi的问题" class="headerlink" title="3.U盘启动盘提示缺少mmx64.efi的问题"></a><strong>3.U盘启动盘提示缺少mmx64.efi的问题</strong></h3>      <p>  解决：</p><p>把U盘里的EFI/BOOT里的文件随便一个文件名命名为mmx64.efi</p><p>4.关于ThinkPad笔记本安装 双系统的问题</p><p>  BIOS设置：Secure Boot设置为Enabled</p><p> 分区：没试过，直接选择和win10共存</p><p>关于UEFL设置：</p><p> 第一.将U盘设为第一启动项 <code>shift +</code></p><p>Starup=&gt;boot=&gt;enter=&gt;选择USB HDD …=&gt;shift 加 ‘+’</p><p>第二.将<code>Boot Mode</code>设为<code>Quick</code></p><p>第三.将<code>Secure Boot</code>设置为<code>Enabled</code></p>        <h3 id="4-Linux下如何升级nodejs">          <a href="#4-Linux下如何升级nodejs" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-Linux下如何升级nodejs" class="headerlink" title="4.Linux下如何升级nodejs"></a><strong>4.Linux下如何升级nodejs</strong></h3>      <p>​     方案：</p><p>​     安装n模块：<code>npm install -g n</code></p><p>​     升级node.js到最新稳定版</p><p>​    <code>n stable(推荐)</code></p><p>​     升级node.js到最新版</p><p>​     <code>n latest</code></p><p>报错：</p><pre><code>cp: cannot stat `/usr/local/n/versions/node/12.16.1/lib': No such file or directorycp: cannot stat `/usr/local/n/versions/node/12.16.1/include': No such file or directorycp: cannot stat `/usr/local/n/versions/node/12.16.1/share': No such file or directory</code></pre><p> 执行 n - 版本号</p><p>然后重新安装</p><p>注：可能需要酸酸乳</p>        <h3 id="5-无法找到add-apt-repository命令">          <a href="#5-无法找到add-apt-repository命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-无法找到add-apt-repository命令" class="headerlink" title="5.无法找到add-apt-repository命令"></a><strong>5.无法找到add-apt-repository命令</strong></h3>      <p>  解决办法：</p><p>  <del>sudo apt-get install python-software-properties</del></p><p> sudo apt-get install software-properties-common</p>        <h3 id="6-Linux下报错internal-modules-cjs-loader-js-985-throw-err">          <a href="#6-Linux下报错internal-modules-cjs-loader-js-985-throw-err" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-Linux下报错internal-modules-cjs-loader-js-985-throw-err" class="headerlink" title="6.Linux下报错internal/modules/cjs/loader.js:985 throw err"></a>6.Linux下报错internal/modules/cjs/loader.js:985 throw err</h3>      <p>解决：</p><p>卸载npm——–<code>sudo apt-get remove --purge npm</code></p><p>删除————–<code>rm -rf npm folder in</code></p><p>删除 ————-<code>rm -rf cahce_npm folder in</code></p><p>然后重新下载<code>npm------sudo apt-get install npm</code></p>        <h3 id="7-如何切换包管理器">          <a href="#7-如何切换包管理器" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-如何切换包管理器" class="headerlink" title="7.如何切换包管理器"></a>7.如何切换包管理器</h3>      <p>Windows：</p><p>解决：</p><p>①直接删除<code>c:/用户/**/</code>下的<code>.vuerc</code></p><p>再次创建<code>vue create xx</code>或提示选择配置</p><p>②手动修改<code>.vuerc</code>下的包</p><p>注：*修改为<code>npm</code>或者<code>yarn</code></p><pre><code>{  "useTaobaoRegistry": true,  "packageManager": "***"}</code></pre><p>Linux：</p><p><code>~/.vuerc</code></p><blockquote><p>被保存的 preset 将会存在用户的 home 目录下一个名为 <code>.vuerc</code> 的 JSON 文件里。如果你想要修改被保存的 preset / 选项，可以编辑这个文件。</p></blockquote><p>终端下输入<code>vim .vuerc</code>修改</p>        <h3 id="8-如何删除hexo中的分类">          <a href="#8-如何删除hexo中的分类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-如何删除hexo中的分类" class="headerlink" title="8.如何删除hexo中的分类"></a>8.如何删除<code>hexo</code>中的分类</h3>      <p>解决：</p><p>首先删除<code>source文件夹</code>中的分类文件与删除<code>_postos</code>里的<code>.md</code>文件</p><p>然后删除<code>db.json</code>文件</p><p>在然后<code>hexo clean</code>接着<code>hexo g</code>和<code>hexo d</code></p>        <h3 id="9-如何解决ssh-connect-to-host-github-com-port-22-Connection-timed-out">          <a href="#9-如何解决ssh-connect-to-host-github-com-port-22-Connection-timed-out" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-如何解决ssh-connect-to-host-github-com-port-22-Connection-timed-out" class="headerlink" title="9.如何解决ssh: connect to host github.com port 22: Connection timed out"></a>9.如何解决<code>ssh: connect to host github.com port 22: Connection timed out</code></h3>      <p>问题的原因：<code>.ssh目录缺少config配置文件</code></p><p>解决：</p><p>进入<code>.ssh</code>文件夹，创建<code>config</code>文件写入<code>xxx为你的邮箱地址</code></p><blockquote><p>Host github.com </p><p>  User <span class="exturl"><a class="exturl__link" href="mailto:xxxxx@xx.com">xxxxx@xx.com</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>  </p><p> Hostname ssh.github.com </p><p>  PreferredAuthentications publickey  </p><p> IdentityFile ~/.ssh/id_rsa </p><p>  Port 443</p></blockquote><p>然后输入<code>ssh -T git@github.com</code>会出现一下提示</p><blockquote><p>RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.                   Are you sure you want to continue connecting (yes/no/[fingerprint])? y<br>Please type ‘yes’, ‘no’ or the fingerprint: yes</p></blockquote><p>其实写入yes就可以了</p>        <h3 id="10-如何解决npm下载错误问题？">          <a href="#10-如何解决npm下载错误问题？" class="heading-link"><i class="fas fa-link"></i></a><a href="#10-如何解决npm下载错误问题？" class="headerlink" title="10.如何解决npm下载错误问题？"></a>10.如何解决npm下载错误问题？</h3>      <blockquote><p>npm ERR! Unexpected end of JSON input while parsing near ‘…TURE—–\r\n”}},”1.2’</p></blockquote><p>问题的原因可能是：<code>1.网络问题：需替换淘宝镜像源</code>，<code>2.解析时JSON输入的意外结束</code></p><p>解决：</p><p>1.运行<code>npm cache clean --force</code></p><p>2.更换淘宝镜像源<code>npm config set registry=https://registry.npm.taobao.org/</code></p>        <h3 id="11-下载node-sass报错">          <a href="#11-下载node-sass报错" class="heading-link"><i class="fas fa-link"></i></a><a href="#11-下载node-sass报错" class="headerlink" title="11.下载node-sass报错"></a>11.下载node-sass报错</h3>      <blockquote><p>npm ERR! code ELIFECYCLE</p><p>npm ERR! errno 1</p><p>npm ERR! <span class="exturl"><a class="exturl__link" href="mailto:node-sass@4.14.1">node-sass@4.14.1</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> postinstall: <code>node scripts/build.js</code></p><p>npm ERR! Exit status 1</p><p>npm ERR!</p><p>npm ERR! Failed at the <span class="exturl"><a class="exturl__link" href="mailto:node-sass@4.14.1">node-sass@4.14.1</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> postinstall script.</p><p>npm ERR! This is probably not a problem with npm. There is likely additional logging output above.</p></blockquote><p>​    原因：在github上克隆代码<code>npm install</code>时候报错，也无法run项目</p><p>解决：</p><p>1.更换源<code>npm install -g mirror-config-china --registry=http://registry.npm.taobao.org</code></p><p>然后在单独下载<code>npm install node-sass</code></p><p><code>node-sass</code>的 <a href="https://github.com/sass/node-sass">github</a>地址</p>        <h3 id="12-deepin下typora安装报错">          <a href="#12-deepin下typora安装报错" class="heading-link"><i class="fas fa-link"></i></a><a href="#12-deepin下typora安装报错" class="headerlink" title="12.deepin下typora安装报错"></a>12.deepin下typora安装报错</h3>      <p><code>Error: could not find a distribution template</code></p><p>解决办法：</p><p>​     终端打开 /etc/apt/sources.list 添加</p><p>​     deb <span class="exturl"><a class="exturl__link" href="https://typora.io/linux" target="_blank" rel="noopener">https://typora.io/linux</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> ./</p><p>注：首先要修改文件权限，在更改</p>        <h3 id="13-误操作导致硬盘格式化">          <a href="#13-误操作导致硬盘格式化" class="heading-link"><i class="fas fa-link"></i></a><a href="#13-误操作导致硬盘格式化" class="headerlink" title="13.误操作导致硬盘格式化"></a>13.误操作导致硬盘格式化</h3>      <p>问题：</p><p>安装linux分区的时候，不小心点击格式化</p><p>解决办法：</p><p>  下载大白菜做pe启动盘</p><p>  bios设置u盘启动</p><p> 进入pe系统后点击分区工具（diskgenius）进入之后，点击搜索分区….</p><p>搜索完毕后，点击保存更改</p><p>重启系统</p>        <h3 id="14-数据恢复后，重启显示verification-failed-15-access-denied">          <a href="#14-数据恢复后，重启显示verification-failed-15-access-denied" class="heading-link"><i class="fas fa-link"></i></a><a href="#14-数据恢复后，重启显示verification-failed-15-access-denied" class="headerlink" title="14.数据恢复后，重启显示verification failed:(15) access denied"></a>14.数据恢复后，重启显示verification failed:(15) access denied</h3>      <p>  解决办法：进入BIOS里面关闭安全启动（secure boot —-Enabled）</p><p>重新启动</p>        <h3 id="15-重新启动后开机引导方式变成PCI-LAN选项">          <a href="#15-重新启动后开机引导方式变成PCI-LAN选项" class="heading-link"><i class="fas fa-link"></i></a><a href="#15-重新启动后开机引导方式变成PCI-LAN选项" class="headerlink" title="15.重新启动后开机引导方式变成PCI LAN选项"></a>15.重新启动后开机引导方式变成PCI LAN选项</h3>      <p>问题：</p><p>开机的引导方式变成<code>PCI LAN</code>,并且前面有一个小箭头,无法正常启动加载。在BIOS中重置调整启动顺序也无法解决。无法进入U盘启动盘</p><p>解决办法：</p><p>1.进入BIOS找到<code>ecurity--&gt;Secure Boot</code>选项回车</p><p>2.回车后,把<code>Secure Boot</code>回车改成<code>Disabled</code></p><p>3.接着按ESC返回上一级菜单,选择StartUp选项,把UEFI/Legacy Boot回车改成Both把UEFI/Legacy Boot Priority改成<code>Legacy First</code>，把 CSM Support改成<code>YEs</code>，接着按F10-YES保存即可</p><p>重新启动</p>        <h3 id="16-运行nrm时候PowerShell显示系统禁止运行脚本">          <a href="#16-运行nrm时候PowerShell显示系统禁止运行脚本" class="heading-link"><i class="fas fa-link"></i></a><a href="#16-运行nrm时候PowerShell显示系统禁止运行脚本" class="headerlink" title="16.运行nrm时候PowerShell显示系统禁止运行脚本"></a>16.运行nrm时候PowerShell显示系统禁止运行脚本</h3>      <p>解决办法：</p><p>以管理员打开PowerShell输入<font color="#2296a2" size="4">set-executionpolicy remotesigned</font></p><p>恢复原来设置则<font color="#2296a2" size="4">set-executionpolicy Restricted</font></p><p>已完（开新）<a href="https://kisskisso.com/2020/06/09/常见错误二/">错误（二）</a>…</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 错误 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块从缓存中加载（了解）</title>
      <link href="/2020/03/10/%E6%A8%A1%E5%9D%97%E4%BB%8E%E7%BC%93%E5%AD%98%E4%B8%AD%E5%8A%A0%E8%BD%BD%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89/"/>
      <url>/2020/03/10/%E6%A8%A1%E5%9D%97%E4%BB%8E%E7%BC%93%E5%AD%98%E4%B8%AD%E5%8A%A0%E8%BD%BD%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>模块的加载机制：</strong>优先从缓存中加载</p><p><strong><u>模块在第一次加载后会被缓存</u></strong>。这也意味着多次调用require() 不会导致模块的代码被执行多次。</p><p><strong>注意：</strong>不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率。</p><p><strong>内置模块的加载机制：</strong>内置模块的加载优先级最高。<a id="more"></a></p><p><strong>自定义模块的加载机制：</strong>必须指定以<strong>./</strong> 或 <strong>../</strong> 开头的路径标识符加载否则会把它当作内置模块或第三方模块进行加载。</p><p>如果按确切的文件名没有找到模块，则Node.js 会尝试带上 .js、 .json 或 .node 拓展名再加载。</p><p>⚫ .js 文件会被解析为JavaScript 文本文件</p><p>⚫ .json 文件会被解析为JSON 文本文件</p><p>⚫ .node 文件会被解析为通过process.dlopen() 加载的编译后的插件模块</p><p><strong>第三方模块的加载机制：</strong>从当前模块的父目录开 始，尝试从它的/node_modules 目录里加载模块。</p><p><strong>目录作为模块：</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本SQL语句的学习</title>
      <link href="/2020/03/09/%E5%9F%BA%E6%9C%ACSQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/03/09/%E5%9F%BA%E6%9C%ACSQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>– <strong>SELECT</strong> 和 <strong>FROM</strong> 是 SQL 中的关键字，因此被高亮了</p><p>– SELECT * FROM users</p><p>– 只查询 id 和 username 两列</p><p>– 列之间使用英文的 , 进行分隔</p><p>– SELECT id, username FROM users</p><p>– 向 users 表中插入一条新数据</p><p>– insert into users (？, ？) values (‘？’, ‘？’)<br>– select * from users <a id="more"></a></p><p>– 把 id 为 1 的这个用户的密码，更新为 888888</p><p>– 注意：在使用 update 更新数据的时候，千万要记得添加 where 条件，否则整张表的数据都会被更新</p><p>– update users set ？ where id=？</p><p>– 需求：更新 id 为 2 这个用户，把密码更新成 admin123 同时把status更新为 1</p><p>– update users set password=’admin123’, status=1 where id=2</p><p>– 删除 id 为 4 的这条用户数据<br>– delete from users where id=4</p><p>– 总结：</p><p>– select   insert into    update    delete</p><p>– 演示常用的 WHERE 子句运算符</p><p>– 不等于 &lt;&gt; 或 !=</p><p>– select * from users where id&lt;&gt;2</p><p>– select * from users where id!=2</p><p>– 大于和小于  &gt;     &lt;</p><p>– select * from users where id&gt;2</p><p>– select * from users where id&lt;2</p><p>– 大于等于    &gt;=</p><p>– select * from users where id&gt;=2</p><p>– 小于等于    &lt;=</p><p>– select * from users where id&lt;=2</p><p>– 查询 status 为 0 且 id 小于 10 的用户</p><p>– select * from users where status=0 and id&lt;10</p><p>– 查询status为1或username为zs的用户列表</p><p>– select * from users where status=1 or username=’zs’</p><p>– order by 用来根据指定的列进行排序</p>        <h2 id="–-desc-代表降序排序">          <a href="#–-desc-代表降序排序" class="heading-link"><i class="fas fa-link"></i></a><a href="#–-desc-代表降序排序" class="headerlink" title="– desc 代表降序排序"></a>– desc 代表降序排序</h2>      <ul><li>asc  代表升序排序</li><li>– 按照 status 对结果进行降序排序</li><li>– select * from users order by status desc</li><li>– 按照 id 对结果进行降序排序</li><li>– select * from users order by id desc</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发自己的包</title>
      <link href="/2020/03/08/%E5%BC%80%E5%8F%91%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8C%85/"/>
      <url>/2020/03/08/%E5%BC%80%E5%8F%91%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>初始化包的基本结构：</p><p>① 新建 itheima-utils文件夹，作为包的根目录</p><p>② 在 itheima-utils文件夹中，新建如下三个文件：</p><p> ⚫ package.json （包管理配置文件） </p><p> ⚫ index.js          （包的入口文件） </p><p> ⚫ README.md  （包的说明文档）</p><p>  将不同的功能进行模块化拆分</p> <a id="more"></a><p> 编写包的说明文档</p><p>注册npm账号</p><p>npm login </p><p>npm publish  【根目录】</p><p> 注：包名不能一样</p><p>删除已发布的包—–npm unpublish 包名 –force命令</p><p>注意：</p><p>① npm unpublish 命令只能删除 72 小时以内发布的包</p><p>② npm unpublish 删除的包，在 24 小时内不允许重复发布</p><p>③ 发布包的时候要慎重，尽量不要往npm 上发布没有意义的包</p><p><del>发布包：不要乱发包</del></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm命令合集</title>
      <link href="/2020/03/08/npm%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86/"/>
      <url>/2020/03/08/npm%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>命令：</p><p>npm -v ——-可以查看版本号</p><p>npm init -y ——–初始化【文件夹不能是中文】package.json</p><p>npm install 包的完整名  &amp;&amp; npm i 包的名字（所以完整包）</p><p>npm uninstall 包 ——–卸载指定的包</p><p>npm i 包安装包 @版本号———-安装指定版本的包</p><p>npm i 包名 -D ——–项目上线不使用的包记录进去</p><p>查看当前的下包的镜像源： <a id="more"></a></p><p>npm config get registry</p><p>切换镜像源：</p><p><del>npm config set registry=<span class="exturl"><a class="exturl__link" href="https://registrytaobao.org/" target="_blank" rel="noopener">https://registrytaobao.org/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></del></p><p><code>npm config set registry=https://registry.npm.taobao.org/</code></p><p>检查镜像源是否下载成功：</p><p>npm config get registry</p><p>简单：</p><p>下载nrm工具</p><p>npm i nrm -g ——将nrm安装为全局可用工具</p><p>查看所有可用的镜像源</p><p>nrm ls</p><p>切换镜像源：</p><p>nrm use taobao</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm与包</title>
      <link href="/2020/03/07/npm%E4%B8%8E%E5%8C%85/"/>
      <url>/2020/03/07/npm%E4%B8%8E%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h4 id="什么叫做包？">          <a href="#什么叫做包？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么叫做包？" class="headerlink" title="什么叫做包？"></a><strong>什么叫做包？</strong></h4>      <p>就是指第三方模块，叫法同而已  <del>ps:感觉就像是闲的无聊</del></p><p>包的来源？有网就可以下载，不是很麻烦  但是下载速吧。。。可能会让你抓狂</p>        <h4 id="为什么需要包？">          <a href="#为什么需要包？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么需要包？" class="headerlink" title="为什么需要包？"></a><strong>为什么需要包？</strong></h4>      <p>​    为了提高开发效率</p><p>像是JQuery和浏览器内置API的关系</p><p>官网： <span class="exturl"><a class="exturl__link" href="https://www.npmjs.com" target="_blank" rel="noopener">https://www.npmjs.com</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>  ps：没有中文请自备翻译器</p><p>初次安装包后，项目多node_module的文件夹和package-lock.json配置文件 <a id="more"></a></p><p><strong>node_modules</strong> 文件夹用来存放所有已安装到项目中的包。require() 导入第三方包时，就是从这个目录中查找并加载包。</p><p><strong>package-lock.json</strong>配置文件用来记录node_modules 目录下的每一个包的信息，例如包的名字、版本号、下载地址等。</p><p>注意：不要手动修改node_modules 或 package-lock.json文件中的任何代码，npm 包管理工具会自动维护它们   <del>ps：估计没人会手贱吧(￣.￣)</del></p>        <h4 id="多人协作问题：">          <a href="#多人协作问题：" class="heading-link"><i class="fas fa-link"></i></a><a href="#多人协作问题：" class="headerlink" title="多人协作问题："></a><strong>多人协作问题：</strong></h4>      <p>  遇到的问题：第三方包的体积过大，不 方便团队成员之间共享项目源代码。</p><p>解决方法：</p><p>共享时剔除node_modules</p><p> package.json，用来记录项目中安装了哪些包。</p><p>注：运行时npm i 自动安装包和版本号</p>        <h4 id="dependencies-节点：">          <a href="#dependencies-节点：" class="heading-link"><i class="fas fa-link"></i></a><a href="#dependencies-节点：" class="headerlink" title="dependencies 节点："></a><strong>dependencies 节点：</strong></h4>      <p>package.json 文件中，有一个dependencies 节点，专门用来记录您使用npm install 命令安装了哪些包。</p><p><strong>注意：</strong>npm install 命令运行完毕之后，会自动把包的信息，添加到package.json 的 dependencies 节点中。</p>        <h4 id="devDependencies-节点：">          <a href="#devDependencies-节点：" class="heading-link"><i class="fas fa-link"></i></a><a href="#devDependencies-节点：" class="headerlink" title="devDependencies 节点："></a><strong>devDependencies 节点：</strong></h4>      <p>某些包只在项目开发阶段会用到，在项目上线之后不会用到，则建议把这些包记录到devDependencies 节点</p>        <h4 id="包的分类：">          <a href="#包的分类：" class="heading-link"><i class="fas fa-link"></i></a><a href="#包的分类：" class="headerlink" title="包的分类："></a><strong>包的分类：</strong></h4>      <p>项目包与全局包</p>        <h6 id="项目包">          <a href="#项目包" class="heading-link"><i class="fas fa-link"></i></a><a href="#项目包" class="headerlink" title="项目包"></a><strong>项目包</strong></h6>      <ol><li>那些被安装到项目的node_modules 目录中的包，都是项目包。<br> 项目包又分为两类，分别是：</li><li>⚫ 开发依赖包（被记录到devDependencies 节点中的包，只在开发期间会用到）</li><li>⚫ 核心依赖包（被记录到dependencies 节点中的包，在开发期间和项目上线之后都会用到</li></ol>        <h6 id="全局包">          <a href="#全局包" class="heading-link"><i class="fas fa-link"></i></a><a href="#全局包" class="headerlink" title="全局包"></a><strong>全局包</strong></h6>      <p>​       npm i 包名 -g 全局包</p>        <h6 id="注意：">          <a href="#注意：" class="heading-link"><i class="fas fa-link"></i></a><a href="#注意：" class="headerlink" title="注意："></a><strong>注意：</strong></h6>      <p>① 只有工具性质的包，才有全局安装的必要性。因为它们提供了好用的终端命令。</p><p>② 判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可。</p>        <h6 id="规范的包结构：">          <a href="#规范的包结构：" class="heading-link"><i class="fas fa-link"></i></a><a href="#规范的包结构：" class="headerlink" title="规范的包结构："></a><strong>规范的包结构：</strong></h6>      <p>① 包必须以单独的目录而存在</p><p>② 包的顶级目录下要必须包含package.json 这个包管理配置文件</p><p>③ package.json 中必须包含 name，version，main这三个属性，分别代表包的名字、版本号、包的入口。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js的加载方法</title>
      <link href="/2020/03/05/Node-js%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E6%B3%95/"/>
      <url>/2020/03/05/Node-js%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h4 id="加载其它模块，使用require-方法：">          <a href="#加载其它模块，使用require-方法：" class="heading-link"><i class="fas fa-link"></i></a><a href="#加载其它模块，使用require-方法：" class="headerlink" title="加载其它模块，使用require()方法："></a><strong>加载其它模块，使用require()方法：</strong></h4>      <pre><code>//加载内置的fs模块const fs = require('fs')  //必须加单引号//加载用户自定义模块const cistom = require('./cistom.js')//加载第三方模块（关于第三方模块的下载和使用，会在后面的课程中进行专门的讲解）</code></pre><p><strong><u>注：使用require()方法加载其它模块时，会执行被加载模块中的代码</u></strong></p>        <h3 id="向外共享模块作用域中的成员：">          <a href="#向外共享模块作用域中的成员：" class="heading-link"><i class="fas fa-link"></i></a><a href="#向外共享模块作用域中的成员：" class="headerlink" title="向外共享模块作用域中的成员："></a><strong>向外共享模块作用域中的成员：</strong></h3>      <p><strong>module对象：</strong> <a id="more"></a></p><pre><code>在每个 .js 自定义模块中都有一个module 对象，它表示当前这个具体的.js 模块。module 对象上存储了和当前模块有关的信息</code></pre><p> <strong>module.exports 对象：</strong></p><pre><code>在自定义模块中，可以使用module.exports 对象，将模块内的成员共享出去，供外界使用。外界用 require() 方法导入自定义模块时，得到的就是module.exports 所指向的对象。Eg：    module.exporst{    ...    }</code></pre><p> <strong>exports对象:</strong></p><pre><code>exports 是对 module.exports 的引用，默认情况下，exports 和 module.exports 指向同一个对象。使用exports 向 外共享成员更加方便。</code></pre><p><strong>exports 和 module.exports 的使用误区:</strong></p><pre><code>时刻谨记，require() 模块时，得到的永远是module.exports 指向的对象：</code></pre><p><strong><u>注：为了防止混乱，建议大家不要在同一个模块中同时使用exports 和 module.exports</u></strong></p><p>杂：</p><pre><code>Node.js 遵循了 CommonJS 模块化规范，CommonJS 规定了模块的特性和各模块之间如何相互依赖。CommonJS 规定：① 每个模块内部，module 变量代表当前模块。② module 变量是一个对象，它的exports 属性（即 module.exports）是对外的接口。③ 加载某个模块，其实是加载该模块的module.exports 属性。require() 方法用于加载模块。</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块化基本概念</title>
      <link href="/2020/03/05/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2020/03/05/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是模块化？">          <a href="#什么是模块化？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是模块化？" class="headerlink" title="什么是模块化？"></a><strong>什么是模块化？</strong></h3>      <pre><code> -模块化是指解决一个复杂问题时，自顶向下逐层把系统划分分成若干模块的过程。对于整个系统来说，模块是可组合、分解和更换的单元。</code></pre><pre><code>-编程领域中的模块化，就是遵守固定的规则，把一个大文件拆成独立并互相依赖的多个小模块。</code></pre>        <h4 id="把代码进行模块化拆分的好处">          <a href="#把代码进行模块化拆分的好处" class="heading-link"><i class="fas fa-link"></i></a><a href="#把代码进行模块化拆分的好处" class="headerlink" title="把代码进行模块化拆分的好处:"></a><strong>把代码进行模块化拆分的好处:</strong></h4>      <pre><code>1. 提高了代码的复用性2. 提高了代码的可维护性3. 可以实现按需加载4. etc....</code></pre>        <h3 id="模块化规范：">          <a href="#模块化规范：" class="heading-link"><i class="fas fa-link"></i></a><a href="#模块化规范：" class="headerlink" title="模块化规范："></a><strong>模块化规范：</strong></h3>      <pre><code>模块化规范就是对代码进行模块化的拆分与组合时，需要遵守的那些规则</code></pre><p><strong>模块化规范的好处：</strong>   <a id="more"></a></p><pre><code>大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块之间的相互调用， 利人利己</code></pre>        <h3 id="Node-js-中模块的分类：">          <a href="#Node-js-中模块的分类：" class="heading-link"><i class="fas fa-link"></i></a><a href="#Node-js-中模块的分类：" class="headerlink" title="Node.js 中模块的分类："></a><strong>Node.js 中模块的分类：</strong></h3>      <p><strong>Node.js 中根据模块来源的不同，将模块分为了3 大类，分别是：</strong></p><p>⚫ 内置模块（内置模块是由Node.js 官方提供的，例如fs、path、http 等）</p><p>⚫ 自定义模块（用户创建的每个.js 文件，都是自定义模块）</p><p>⚫ 第三方模块（由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载）</p>        <h3 id="Node-js-中的模块作用域：">          <a href="#Node-js-中的模块作用域：" class="heading-link"><i class="fas fa-link"></i></a><a href="#Node-js-中的模块作用域：" class="headerlink" title="Node.js 中的模块作用域："></a><strong>Node.js 中的模块作用域：</strong></h3>      <pre><code>在 Node.js 中，用户创建的每个.js 文件都是自定义模块。在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域</code></pre>        <h4 id="模块作用域的好处：">          <a href="#模块作用域的好处：" class="heading-link"><i class="fas fa-link"></i></a><a href="#模块作用域的好处：" class="headerlink" title="模块作用域的好处："></a><strong>模块作用域的好处：</strong></h4>      <pre><code class="txt">防止了全局变量污染的问题</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http模块</title>
      <link href="/2020/03/04/http%E6%A8%A1%E5%9D%97/"/>
      <url>/2020/03/04/http%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>path路径模块</title>
      <link href="/2020/03/03/path%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97/"/>
      <url>/2020/03/03/path%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>   <strong>●path.join()的方法可以把多个路径片段拼接为完整的路径字符串</strong></p><p><strong>Eg: const fp = path.join(__dirname, ‘/成绩.txt’)</strong></p><pre><code>path.join([...paths])    注：__dirname参数解读：⚫ ...paths &lt;string&gt; 路径片段的序列⚫ 返回值: &lt;string&gt;</code></pre><p>​     <strong>●path.basename()的方法，可以从一个文件路径中，获取到文件的名称部分</strong></p><pre><code>Eg:const fpath = '/a/b/c/index.html'var fullName = path.basename(fpath)--&gt;index.htmlvar fullName = path.basename(fpath,'.html')--&gt;index</code></pre><p><strong>●使用 path.extname() 方法，可以获取路径中的扩展名部分</strong>  <a id="more"></a></p><pre><code>Eg:const fpath = '/a/b/c/index.html'const fext = path.extname(fpath)--&gt;.html</code></pre><pre><code>path.extname(path)参数解读：⚫ path &lt;string&gt;必选参数，表示一个路径的字符串⚫ 返回: &lt;string&gt; 返回得到的扩展名字符串</code></pre><p>引入path路径模块</p><pre><code>cosnt fpath = reuire('path')</code></pre><p>   注：今后反涉及到fs模块操作指定路径的文件都要用__dirname进行路径的拼接，不要使用./或../</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fs文件动态路径拼接问题(了解)</title>
      <link href="/2020/03/03/fs%E6%96%87%E4%BB%B6%E5%8A%A8%E6%80%81%E8%B7%AF%E5%BE%84%E6%8B%BC%E6%8E%A5%E9%97%AE%E9%A2%98/"/>
      <url>/2020/03/03/fs%E6%96%87%E4%BB%B6%E5%8A%A8%E6%80%81%E8%B7%AF%E5%BE%84%E6%8B%BC%E6%8E%A5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>在使用 fs 模块操作文件时，如果提供的操作路径是以./ 或 ../ 开头的相对路径时，很容易出现路径动态拼接错误的问题。</p><p><strong>原因：</strong>代码在运行的时候，会以执行node 命令时所处的目录，动态拼接出被操作文件的完整路径。</p><a id="more"></a><p><strong>解决方案：</strong>在使用fs 模块操作文件时，直接提供绝对路径，不要提供./ 或 ../ 开头的相对路径，从而防止路径动态拼接的问题。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fs文件系统模块</title>
      <link href="/2020/03/03/fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%97/"/>
      <url>/2020/03/03/fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是fs文件系统模块？">          <a href="#什么是fs文件系统模块？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是fs文件系统模块？" class="headerlink" title="什么是fs文件系统模块？"></a><strong>什么是fs文件系统模块？</strong></h4>      <p><u><strong>fs模块是Node.js官方提供的、用来操作文件的模块</strong></u></p><p>​     <strong>●fs.readFile()方法,用来读取指定文件中的内容</strong></p><a id="more"></a><pre><code>fs.readFile(path[,options],callback)参数解读：⚫参数1：必选参数，指定文件路径的字符串，⚫参数2：可选参数，什么编码格式读取文件⚫参数3：必选参数，文件读取完成后，通过回调函数拿到读取结果注：箭头函数中(err,data)=&gt;{}  err---失败之后的错误对象 data---读取之后的文本</code></pre><p>​     <strong>●fs.writeFile()方法,用来向指定的文件中写入内容</strong></p><pre><code>fs.writeFile(file,data[,options],callback)参数解读：⚫ 参数1：必选参数，需要指定一个文件路径的字符串，表示要文件的存放路径。⚫ 参数2：必选参数，表示要写入的内容。⚫ 参数3：可选参数，表示以什么格式写入文件内容，默认值是utf8。⚫ 参数4：必选参数，文件写入完成后的回调函数。</code></pre><p>   <strong>导入js模块：</strong></p><pre><code>const fs = require('fs')  </code></pre><p>注：const 是常量</p><p>  <strong>● fs.readdir()方法，可以读取指定目录下所有文件的名称</strong></p><pre><code>fs.readdir(path[,options],callback)参数解读：⚫ 参数1：必选参数，表示要读取哪个目录下的文件名称列表。⚫ 参数2：可选参数，以什么格式读取目录下的文件名称，默认值是utf8。⚫ 参数3：必选参数，读取完成以后的回调函数。</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初始Node</title>
      <link href="/2020/03/03/%E5%88%9D%E5%A7%8BNode/"/>
      <url>/2020/03/03/%E5%88%9D%E5%A7%8BNode/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是Node-js">          <a href="#什么是Node-js" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是Node-js" class="headerlink" title="什么是Node.js"></a><strong>什么是Node.js</strong></h4>      <pre><code>Node.js是一个基于chrome v8引擎的JavaScript运行环境</code></pre><p>注：1浏览器是JavaScript的前端运行环境</p><p>​       2.Node.js是JavaScript的后端运行环境</p><pre><code>    3.Node.js中无法调用DOM和BOM等浏览器内置API</code></pre>        <h4 id="Node-js怎么学：">          <a href="#Node-js怎么学：" class="heading-link"><i class="fas fa-link"></i></a><a href="#Node-js怎么学：" class="headerlink" title="Node.js怎么学："></a><strong>Node.js怎么学：</strong></h4>      <p>   <strong>浏览器中JavaScript学习路径：</strong> <a id="more"></a></p><pre><code>JavaScript基础语法+浏览器内置API（DOM+BOM）+第三方库(JQuery、art-temloate等)</code></pre><p>​    <strong>Node.js的学习路径：</strong></p><pre><code>JavaScript基础语法+Node.js内置API模块（fs、path、http等）+第三方API模块（express、mysql等）</code></pre>        <h4 id="在Node-js环境中执行JavaScript代码方式：">          <a href="#在Node-js环境中执行JavaScript代码方式：" class="heading-link"><i class="fas fa-link"></i></a><a href="#在Node-js环境中执行JavaScript代码方式：" class="headerlink" title="在Node.js环境中执行JavaScript代码方式："></a><strong>在Node.js环境中执行JavaScript代码方式：</strong></h4>      <p>1.REPL中，输入JavaScript代码并执行（了解）</p><p><u>注：命令行不能在REPL环境中使用</u></p><p>2.通过命令行的形式，来执行指定JavaScript文件的代码</p>        <h4 id="命令快捷键：">          <a href="#命令快捷键：" class="heading-link"><i class="fas fa-link"></i></a><a href="#命令快捷键：" class="headerlink" title="命令快捷键："></a><strong>命令快捷键：</strong></h4>      <p>1.使用↑键，可以快速定位到上一次执行命令</p><p>2.使用tab键，能够快速补全全路径</p><p>3.使用esc键，能够快速清空当前已输入的命令</p><p>4.输入cls命令，可以清空终端</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>错误合集</title>
      <link href="/2020/03/01/%E9%94%99%E8%AF%AF%E5%90%88%E9%9B%86/"/>
      <url>/2020/03/01/%E9%94%99%E8%AF%AF%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Uncaught-SyntaxError-Unexpected-token-‘-‘">          <a href="#1-Uncaught-SyntaxError-Unexpected-token-‘-‘" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Uncaught-SyntaxError-Unexpected-token-‘-‘" class="headerlink" title="1.Uncaught SyntaxError: Unexpected token ‘{‘"></a>1.Uncaught SyntaxError: Unexpected token ‘{‘</h3>      <p>  我在引入css文件代码的时候，没注意把js引入当css引入来写了导致报错</p>        <h3 id="2-Failed-to-load-resource-net-ERR-SSL-PROTOCOL-ERROR">          <a href="#2-Failed-to-load-resource-net-ERR-SSL-PROTOCOL-ERROR" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Failed-to-load-resource-net-ERR-SSL-PROTOCOL-ERROR" class="headerlink" title="2.Failed to load resource: net::ERR_SSL_PROTOCOL_ERROR"></a>2.Failed to load resource: net::ERR_SSL_PROTOCOL_ERROR</h3>      <p>请求协议问题需将https换成http【注：插件】</p>        <h3 id="3-Uncaught-TypeError-Cannot-read-property-‘imports’-of-undefined">          <a href="#3-Uncaught-TypeError-Cannot-read-property-‘imports’-of-undefined" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Uncaught-TypeError-Cannot-read-property-‘imports’-of-undefined" class="headerlink" title="3.Uncaught TypeError: Cannot read property ‘imports’ of undefined"></a>3.Uncaught TypeError: Cannot read property ‘imports’ of undefined</h3>      <p>date写成data     dateFormat写成dataFormat  粗心导致 <a id="more"></a></p>        <h3 id="4-TypeError-Cannot-read-property-‘data’-of-undefined">          <a href="#4-TypeError-Cannot-read-property-‘data’-of-undefined" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-TypeError-Cannot-read-property-‘data’-of-undefined" class="headerlink" title="4.TypeError: Cannot read property ‘data’ of undefined"></a>4.TypeError: Cannot read property ‘data’ of undefined</h3>      <blockquote><p>stack: “TypeError: Cannot read property ‘cancelToken’ of undefined↵    at throwIfCancellationRequested (webpack-internal:///./node_modules/axios/lib/core/dispatchRequest.js:12:14)↵    at dispatchRequest (webpack-internal:///./node_modules/axios/lib/core/dispatchRequest.js:24:3)”</p><p>message: “Cannot read property ‘cancelToken’ of undefined”</p></blockquote><p>解决：判断如果当前有token就带token，如果没有反之</p><p>我判断了但是还是报错，发现在axios拦截器并没有加返回值也就是<code>return config</code></p>        <h4 id="5-清理npm缓存">          <a href="#5-清理npm缓存" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-清理npm缓存" class="headerlink" title="5.清理npm缓存"></a>5.清理npm缓存</h4>      <p> npm cache clean -f</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 错误 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios使用</title>
      <link href="/2020/02/26/axios%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/02/26/axios%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<pre><code>     引入axio文件     axios是一个用于进行ajax操作的js库        -体积小，功能独立，除了ajax以外没有其他的额外功能</code></pre><p>​    <a id="more"></a>  </p><p>​     <strong>下载地址：</strong></p><p>​    <em>- <span class="exturl"><a class="exturl__link" href="https://unpkg.com/axios@0.19.2/dist/axios.min.js" target="_blank" rel="noopener">https://unpkg.com/axios@0.19.2/dist/axios.min.js</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></em></p><pre><code class="js">发送get请求axios({    method:'get',    url:'接口',    params:{        name:'jack',        age:18,        gender:'男'    }}).then(function (res){    console.log(res);});发送post请求axios({    method:'post',    url:'接口',    data:{        name:'rose',        age:19,        gender:'女'    }}).then(function(res){    console.log(res);});</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ajax上传进度处理</title>
      <link href="/2020/02/26/ajax%E4%B8%8A%E4%BC%A0%E8%BF%9B%E5%BA%A6%E5%A4%84%E7%90%86/"/>
      <url>/2020/02/26/ajax%E4%B8%8A%E4%BC%A0%E8%BF%9B%E5%BA%A6%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<pre><code class="html">&lt;!-- 设置文件域和上传按钮 --&gt;  &lt;input type="file" id="ipt"&gt;  &lt;button id="btn"&gt;按钮&lt;/button&gt;  &lt;div class="progress" style="width:500px; margin: 10px 0;"&gt;    &lt;div class="progress-bar progress-bar-info progress-bar-striped active" id="percent" style="width:0%"&gt;      0%    &lt;/div&gt;  &lt;/div&gt;  &lt;script src="lib/jquery.js"&gt;&lt;/script&gt;  &lt;script&gt;    // 按钮点击    $('#btn').on('click', function () {      // 获取文件内容      var files = $('#ipt')[0].files;      var fd = new FormData();      fd.append('file', files[0]);      // 设置原生ajax请求，进行上传进度设置（如果使用jQuery，直接取网上找插件即可）      // 1 基本的ajax步骤      var xhr = new XMLHttpRequest();      xhr.open('post', 'http://www.liulongbin.top:3006/api/upload/avatar');      // 2 上传进度检测      //  - 上传中，onprogress事件会自动触发多次（具体次数不固定，取决于网速和文件大小）      //    - 我自己测试的次数：  60k左右的图片，触发3次，   30M左右的视频，触发几十次      xhr.upload.onprogress = function (e) {        // - e.lengthComputable 表示是否具有可计算的文件大小        //   - 布尔值，true表示文件可以使用        if (e.lengthComputable) {          // - e.total 上传文件的总大小          // - e.loaded 已上传大小          //   - toFixed() 保留指定位小数          var bili = (e.loaded / e.total * 100).toFixed(2) + '%';          // 根据上传进度，设置具体功能          //  - 设置进度条宽度和内容为比例          $('#percent').css('width', bili).text(bili);        }      };      // 3 上传完毕，修改显示效果      // upload.onload 事件会在上传操作完毕后触发      xhr.upload.onload = function () {        $('#percent').removeClass().addClass('progress-bar progress-bar-success');      };      xhr.send(fd);    });  &lt;/script&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非同源与http辅助演示</title>
      <link href="/2020/02/25/%E9%9D%9E%E5%90%8C%E6%BA%90%E4%B8%8Ehttp%E8%BE%85%E5%8A%A9%E6%BC%94%E7%A4%BA/"/>
      <url>/2020/02/25/%E9%9D%9E%E5%90%8C%E6%BA%90%E4%B8%8Ehttp%E8%BE%85%E5%8A%A9%E6%BC%94%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<p>  非同源地址进行跨域请求演示：</p><pre><code class="js"> var xhr = new XMLHttpRequest();xhr.open('get', '接口');    xhr.send();</code></pre>        <h3 id="http辅助演示文件：">          <a href="#http辅助演示文件：" class="heading-link"><i class="fas fa-link"></i></a><a href="#http辅助演示文件：" class="headerlink" title="http辅助演示文件："></a><strong>http辅助演示文件：</strong></h3>              <h4 id="http的get请求的请求报文组成演示：">          <a href="#http的get请求的请求报文组成演示：" class="heading-link"><i class="fas fa-link"></i></a><a href="#http的get请求的请求报文组成演示：" class="headerlink" title="http的get请求的请求报文组成演示："></a><strong>http的get请求的请求报文组成演示：</strong></h4>      <p>​      <strong>第一行为请求行</strong></p><p> GET /api/getbooksid=1&amp;bookname=%E8%A5%BF%E6%B8%B8%E8%AE%B0 HTTP/1.1         <a id="more"></a></p><p><strong>后面的部分为请求头</strong></p><ul><li><p>请求头是本次请求的相关信息</p></li><li><p>这些信息大部分都是浏览器自动设置的</p><p> 我们自己设置过一些： Content-Type</p></li><li><p>Host: 接口</p><p>Connection: keep-alive</p><p>Accept: <em>/</em></p><p>User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko)</p><p>Chrome/79.0.3945.79Safari/537.36</p><p>Origin: null</p><p>Accept-Encoding: gzip, deflate</p><p>Accept-Language: zh-CN,zh;q=0.9,en;q=0.8</p><p>If-None-Match: W/“91-hlrWKV2QmzU6DUa8qes2AyEeCbs”</p><p><strong><u>注：请求体是用来保存请求发送的数据使用的，get请求的请求参数都在url中发送，请求体为空</u></strong> </p></li></ul>        <h4 id="http的post请求的请求报文组成演示：">          <a href="#http的post请求的请求报文组成演示：" class="heading-link"><i class="fas fa-link"></i></a><a href="#http的post请求的请求报文组成演示：" class="headerlink" title="http的post请求的请求报文组成演示："></a><strong>http的post请求的请求报文组成演示：</strong></h4>      <p>   <strong>—-请求行—-</strong></p><p> POST /api/addbook HTTP/1.1</p><p><strong>—-请求头—-</strong></p><p> Host: 接口</p><p> Connection: keep-alive</p><p> Content-Length: 112</p><p> Accept: <em>/</em></p><p> User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.79</p><p> Safari/537.36</p><p> Content-Type: application/x-www-form-urlencoded; charset=UTF-8</p><p> Origin: null</p><p> Accept-Encoding: gzip, deflate</p><p> Accept-Language: zh-CN,zh;q=0.9,en;q=0.8</p><p> <u><strong>注：<em>post的请求参数是在请求体中发送的</em></strong></u></p><p><u><strong>之前在请求头中设置的Content-Type是用来指定请求体的内容类型的</strong></u></p>        <h3 id="响应报文演示：">          <a href="#响应报文演示：" class="heading-link"><i class="fas fa-link"></i></a><a href="#响应报文演示：" class="headerlink" title="响应报文演示："></a><strong>响应报文演示：</strong></h3>      <p><strong>—-状态行—–</strong></p><p>HTTP/1.1 200 OK</p><p><strong>—-响应头信息—-</strong></p><p>   响应头保存的是响应的相关信息</p><p> X-Powered-By: Express</p><p> Access-Control-Allow-Origin: </p><p> Date: Mon, 24 Feb 2020 08:59:57 GMT</p><p><strong>—响应报文中的Content-Type指的是响应的数据的内容类型—</strong></p><p> Content-Type: application/json; charset=utf-8</p><p> Content-Length: 145</p><p> ETag: W/“91-hlrWKV2QmzU6DUa8qes2AyEeCbs”</p><p><strong><u>注：响应体指的是服务器响应给客户端的数据，其实就是我们一直使用的res</u></strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSONP</title>
      <link href="/2020/02/25/JSONP/"/>
      <url>/2020/02/25/JSONP/</url>
      
        <content type="html"><![CDATA[<h3 id="JSONP的跨域方式：">          <a href="#JSONP的跨域方式：" class="heading-link"><i class="fas fa-link"></i></a><a href="#JSONP的跨域方式：" class="headerlink" title="JSONP的跨域方式："></a><strong>JSONP的跨域方式：</strong></h3>      <p>  同源策略限制了对非同源地址发送ajax请求</p><p>  JSONP与ajax无关，而是借助script标签对非同源地址进行请求</p><p>  步骤：</p><ul><li><p>1 设置script标签</p></li><li><p>2 将接口地址设置在script标签的src属性中</p></li><li><p>script接收的所有文字内容都会被自动当作js代码执行</p></li><li><p>服务器中会响应某个名称的函数调用形式</p></li><li><p>3 在src的接口地址后，以get请求参数形式，手动设置callback的参数<a id="more"></a></p></li><li><p>callback的值为本次设置的处理函数名称</p></li><li><p>4 在script之前，设置对应名称的处理函数</p></li><li><p>并且设置形参，接收服务器真正响应的数据</p></li><li><p>5 根据需求使用响应的数据即可</p></li></ul><hr><pre><code class="js">&lt;script&gt;    function success(res) {      console.log(res);    注：不能写在后面      console.log(res.data);    }  &lt;/script&gt;  &lt;script src="接口/?callback=success&amp;name=jack&amp;age=18"&gt;&lt;/script&gt;</code></pre>        <h3 id="JQuery发送jsonp请求方式：">          <a href="#JQuery发送jsonp请求方式：" class="heading-link"><i class="fas fa-link"></i></a><a href="#JQuery发送jsonp请求方式：" class="headerlink" title="JQuery发送jsonp请求方式："></a><strong>JQuery发送jsonp请求方式：</strong></h3>      <p>   <strong><u>注：JSONP和ajax没有任何关联</u></strong></p><p>JQuery为了方便操作，将jsonp的设置方式直接放在$.ajax()中</p><pre><code class="js">$.ajax({    type:'get',    url:'接口',    data:{        name:'jack',        age:18    },     // 设置dataType: 'jsonp'表示本次请求采用jsonp方式发送      // 通过调试工具看到，本次请求的type为script，确定是jsonp请求      // 页面中没有用于发送jsonp的script，是因为jQuery在使用完毕后进行了删除操作    dataType:'jsonp',    success:function(res){        console.log(res);    }});</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jsonp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封装函数ajax添加beforeSend和complete</title>
      <link href="/2020/02/25/%E5%B0%81%E8%A3%85%E5%87%BD%E6%95%B0ajax%E6%B7%BB%E5%8A%A0beforeSend%E5%92%8Ccomplete/"/>
      <url>/2020/02/25/%E5%B0%81%E8%A3%85%E5%87%BD%E6%95%B0ajax%E6%B7%BB%E5%8A%A0beforeSend%E5%92%8Ccomplete/</url>
      
        <content type="html"><![CDATA[<p>​      封装一个函数模拟$.ajax()的使用形式</p><div class="table-container"><table><thead><tr><th>–参数：配置对象形式</th></tr></thead><tbody><tr><td>–option</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>-type</th><th>-url</th><th>-data</th><th>-success</th><th>-beforeSend</th><th>-copmplete</th></tr></thead><tbody><tr><td>请求方式</td><td>请求地址</td><td>请求参数</td><td>请求成功时触发的回调函数</td><td>发送请求前触发的回调</td><td>响应完毕（不区分成功失败）时触发的回调</td></tr></tbody></table></div><p>​      <a id="more"></a></p><pre><code class="js">function ajax(option) {    请求触发前操作    option.beforeSend();    请求发送功能    var xhr = new XMLHttpRequest();    var type = option.type.toLowerCase();    var data = urlencoded(option.data);     if (type === 'grt'){     xhr.open('get', option.url + '?' + data);        xhr.send();      } else if (type === 'post') {        xhr.open('post', option.url);        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');        xhr.send(data);      }      // --- 响应处理功能      // 1 设置事件      xhr.onreadystatechange = function () {        // 2 检测响应下载完毕        if (xhr.readyState === 4) {          // 3 进行成功检测          if (xhr.status === 200) {            // 将JSON格式的数据转换为对象            var res = JSON.parse(xhr.responseText);            // 4 操作响应的数据，进行成功时的处理            option.success(res);          }          // --- 此位置确定响应下载完毕，而且不区分成功或失败，执行complete即可          option.complete();        }      };    }    // 功能测试：    /* ajax({      type: 'get',      url: 'http://www.liulongbin.top:3006/api/getbooks',      data: {        id: 1,        bookname: '西游记'      },      success: function (res) {        console.log('成功时接收的响应信息', res);      },      beforeSend: function () {        console.log('请求开始发送啦');      },      complete: function () {        console.log('请求处理完毕啦');      }    }); */    ajax({      type: 'post',      url: 'http://www.liulongbin.top:3006/api/addbook',      data: {        bookname: '张三自传',        author: '张三',        publisher: '张三出版社'      },      success: function (res) {        console.log(res);      },      beforeSend: function () {        console.log('请求开始发送啦');      },      complete: function () {        console.log('请求处理完毕啦');      }    });    // 之前准备的用于将对象转换为urlencoded的函数    function urlencoded(obj) {      // 1 遍历对象      var arr = [];      for (var key in obj) {        // 2 将当前属性拼接为 '名=值' 的格式        arr.push(key + '=' + obj[key]);      }      // 3 使用数组方法join()用&amp;连接每个元素即可      return arr.join('&amp;');    }} </code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git出现的错误</title>
      <link href="/2020/02/25/Git-%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF/"/>
      <url>/2020/02/25/Git-%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="可能出现的错误：">          <a href="#可能出现的错误：" class="heading-link"><i class="fas fa-link"></i></a><a href="#可能出现的错误：" class="headerlink" title="可能出现的错误："></a><strong>可能出现的错误：</strong></h3>              <h3 id="①git-push-出现Everything-up-to-date-解决方法">          <a href="#①git-push-出现Everything-up-to-date-解决方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#①git-push-出现Everything-up-to-date-解决方法" class="headerlink" title="①git push 出现Everything up-to-date 解决方法"></a>①git push 出现Everything up-to-date 解决方法</h3>      <p>   1.可能你没有git.add 和git commit</p><pre><code>     - git add .     - git commit -m 'message'     - git push origin master</code></pre><a id="more"></a>        <h3 id="2-无法推送远程仓库">          <a href="#2-无法推送远程仓库" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-无法推送远程仓库" class="headerlink" title="2.无法推送远程仓库"></a>2.无法推送远程仓库</h3>      <blockquote><p>​      error:src refspec master does not match any    |||   error:failed to push some refs to ‘仓库地址’</p></blockquote><p>​        暂存区没有文件</p><p>​       解决：</p><pre><code class="bash">git add .git commit -m "xxxx"  // xxx随意</code></pre>        <h3 id="3-显示没有权限">          <a href="#3-显示没有权限" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-显示没有权限" class="headerlink" title="3.显示没有权限"></a>3.显示没有权限</h3>      <p>​      可以添加公钥：</p><ol><li><p>ssh-keygen -t rsa -C ‘youremail’</p></li><li><p>然后一路Enter（回车）</p></li><li><p>系统盘—&gt;用户—&gt;你的文件—&gt;.ssh文件夹里 —&gt;id_rsa.pub(这是公共秘钥)</p><p><u><strong>注：切记！！！切记！！！切记！！！里面的id_rsa是私人秘钥不能给其它人看</strong></u></p><ol start="4"><li><p>打开github—&gt;点击你的头像settings—&gt;然后在点击SSH and GPG keys—&gt;点击Add deploy key新建一个ssh—&gt;Title随便写—&gt;Key里把id_rsa.pub里面的信息复制进去【注：是公共秘钥不要复制错误】</p><p>在git bash中输入<strong>ssh -T <span class="exturl"><a class="exturl__link" href="mailto:git@github.com">git@github.com</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong>  显示你的用户名就成功了</p></li></ol></li></ol>        <h3 id="4-推送远程仓库出现的问题">          <a href="#4-推送远程仓库出现的问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-推送远程仓库出现的问题" class="headerlink" title="4.推送远程仓库出现的问题"></a>4.推送远程仓库出现的问题</h3>      <p>hint: Updates were rejected because the remote contains work that you do<br>hint: not have locally. This is usually caused by another repository pushing<br>hint: to the same ref. You may want to first integrate the remote changes<br>hint: (e.g., ‘git pull …’) before pushing again.<br>hint: See the ‘Note about fast-forwards’ in ‘git push –help’ for details.</p><p><strong>问题原因：</strong></p><p>其他地方向同一远端库推送了代码，导致本地不是最新的</p><p><strong>解决方案：</strong></p><p>先从远端pull一下，执行：git pull</p>        <h3 id="5-git推送更新出现错误">          <a href="#5-git推送更新出现错误" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-git推送更新出现错误" class="headerlink" title="5.git推送更新出现错误"></a>5.git推送更新出现错误</h3>      <blockquote><p> ! [rejected]        master -&gt; master (fetch first)<br>error: failed to push some refs to ‘<span class="exturl"><a class="exturl__link" href="https://github.com/xxx/xxx.git'" target="_blank" rel="noopener">https://github.com/xxx/xxx.git'</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>hint: Updates were rejected because the remote contains work that you do<br>hint: not have locally. This is usually caused by another repository pushing<br>hint: to the same ref. You may want to first integrate the remote changes<br>hint: (e.g., ‘git pull …’) before pushing again.<br>hint: See the ‘Note about fast-forwards’ in ‘git push –help’ for details.</p></blockquote><p>解决办法：</p><p>​    如果本地代码无误后进行推送进行强制推送：</p><p>​          <font color="#1c896e">git push -f origin master</font> </p><p>对了不要直接执行上面的命令，别忘了初始化以及add和commotion -m (～￣▽￣)～</p><p>待更新中…</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2020/02/25/Git/"/>
      <url>/2020/02/25/Git/</url>
      
        <content type="html"><![CDATA[<h3 id="如何使用Git：">          <a href="#如何使用Git：" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何使用Git：" class="headerlink" title="如何使用Git："></a><strong>如何使用Git：</strong></h3>      <p>​          第一步： 连接远程仓库：git remote add [name] [URL仓库地址]</p><p>​           第二步： git init 初始化 【注：隐藏.git 不要动】  </p><p>​          <a id="more"></a></p><p>​           第三步： git add .将当前目录下所有文件添加</p><p>​            第四步： git commit -m ‘描述信息’  【注：初次使用会git会进行身份验证】 </p><blockquote><p>​          git config –global user.email ‘邮箱’</p></blockquote><blockquote><p>​        git config –global user.name ‘名字’</p></blockquote><pre><code>      不要问然后呢？没然后了...没有 之后就是git add .  git commit -m ......无限循环直到循环到小盒子里||o(*°▽°*)o|Ю [有人吗?] </code></pre>        <h3 id="git版本查看和版本穿梭：">          <a href="#git版本查看和版本穿梭：" class="heading-link"><i class="fas fa-link"></i></a><a href="#git版本查看和版本穿梭：" class="headerlink" title="git版本查看和版本穿梭："></a><strong>git版本查看和版本穿梭：</strong></h3>      <p>git log –oneline——查看版本</p><p>git reset  –hard 版本号 ——进行版本穿梭</p><p><del>有的时候手会滑，把git给关闭了，正好穿梭在旧版本中，</del>  想看更新的版本号，使用git reflog  注：前面的话不重要，重要的是git reflog。</p>        <h3 id="分支：">          <a href="#分支：" class="heading-link"><i class="fas fa-link"></i></a><a href="#分支：" class="headerlink" title="分支："></a><strong>分支：</strong></h3>      <p><strong><u>默认只有主分支 master</u></strong></p><p>​      一般来讲主分支需要保存的是没问题的，用于上线使用的代码</p><pre><code>   开发阶段的代码新建其它分支进行，不要在主分支上操作</code></pre><p>git branch 查看分支</p><p>git branch 【名字】  创建分支</p><p>git checkout 【名字】 切换分支</p><p>git checkout -b 【名字】 创建并切换</p><p>git push origin xxx:xxx  本地分支xxx作为远程xxx分支</p><p>git checkout -d 【名字】 删除分支    【注：不要把-b 和-d 搞混….   切记！！！切记！！！切记！！！】    </p><p>git clone -b &lt;指定分支名&gt; &lt;远程仓库地址&gt;   克隆分支代码</p><p><strong><u>【杂：这这是删除本地的分支】</u></strong></p><blockquote><p><strong>如果要查看远程分支则git branch -a即可</strong></p><p><strong>git push 库名 –delete  分支名</strong></p></blockquote><p>git merge 【名字】 合并分支</p><p>​    注：合并，是将指定分支合并到当前所处的分支下</p><pre><code>         Eg：当前在master，执行git merge dev，表示将dev合并到master中   </code></pre><p><del>应该是这样吧或许</del></p>        <h3 id="合并冲突：">          <a href="#合并冲突：" class="heading-link"><i class="fas fa-link"></i></a><a href="#合并冲突：" class="headerlink" title="合并冲突："></a><strong>合并冲突：</strong></h3>      <p><strong>出现的原因：</strong>多个分支修改同一个文件的同一块内容，然后进行了合并</p><p>  根据需要进行删除工作</p>        <h3 id="推送到远程仓库：">          <a href="#推送到远程仓库：" class="heading-link"><i class="fas fa-link"></i></a><a href="#推送到远程仓库：" class="headerlink" title="推送到远程仓库："></a><strong>推送到远程仓库：</strong></h3>      <p>git push </p><p><strong>将代码拉取更新到本地（本地有项目代码时使用）：</strong></p><p>git pull</p><p>也可以用可视化工具（看个人情况）</p><p>github desktop 软件</p><p>vscode插件   Gitlens</p>        <h3 id="如何克隆远程仓库：">          <a href="#如何克隆远程仓库：" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何克隆远程仓库：" class="headerlink" title="如何克隆远程仓库："></a><strong>如何克隆远程仓库：</strong></h3>      <ol><li><p>git clone http://仓库地址</p></li><li><p>git push 推送（注:第一次推送会输入密码和账号）</p></li><li><p>如果出现Everything up-to-date 则看 ①解决办法</p></li><li><p>git add.</p></li><li><p>git commit -m ‘message’</p></li><li><p>git push origin master</p>        <h3 id="如何连接远程仓库：">          <a href="#如何连接远程仓库：" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何连接远程仓库：" class="headerlink" title="如何连接远程仓库："></a><strong>如何连接远程仓库：</strong></h3>      <ol><li>git remote add   [name] [URL仓库地址]</li></ol></li></ol>        <h3 id="如何删除远程仓库链接">          <a href="#如何删除远程仓库链接" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何删除远程仓库链接" class="headerlink" title="如何删除远程仓库链接"></a><strong>如何删除远程仓库链接</strong></h3>      <p>   git remote rm origin</p>        <h3 id="如何创建子模块：">          <a href="#如何创建子模块：" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何创建子模块：" class="headerlink" title="如何创建子模块："></a><strong>如何创建子模块：</strong></h3>      <p>   <strong>添加：</strong>git submodule add 仓库地址 路径</p><p>   <strong>删除：</strong>要在“.gitmodules”文件中删除相应配置信息。然后，执行“git rm –cached ”命令将子模块所在的文件从git中删除</p><p>   <strong>更新？：</strong>git submodule update</p>        <h3 id="如何学习Git：">          <a href="#如何学习Git：" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何学习Git：" class="headerlink" title="如何学习Git："></a>如何学习Git：</h3>      <p>   推荐个网址：<a href="https://backlog.com/git-tutorial/cn/">猴子都能懂得GIT入门</a></p><p>   待更新中…</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xhr与FormData对象的使用</title>
      <link href="/2020/02/24/xhr%E4%B8%8EFormData%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/02/24/xhr%E4%B8%8EFormData%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="xhr的timeout和ontimeout和onload：">          <a href="#xhr的timeout和ontimeout和onload：" class="heading-link"><i class="fas fa-link"></i></a><a href="#xhr的timeout和ontimeout和onload：" class="headerlink" title="xhr的timeout和ontimeout和onload："></a><strong>xhr的timeout和ontimeout和onload：</strong></h2>      <p><strong>timeout和ontimeout：</strong></p><p>注①：-send()方法用于发送http请求，如果是异步请求（默认）则此方法会在请求后立即返回；如果是同步请求，则此方法直到响应到达后才会返回</p><p> -语法：XMLHttpRequest.send()              【xhr.send()】</p> <a id="more"></a><pre><code class="js"> 发送一个get请求 var xhr =new XMLHttpRequest();   xhr.open('get','接口')；   设置请求超时时间（毫秒单位）       -如果超过指定时间，请求会被取消，后续的操作不执行xhr.timeout = 30000;xhr.ontimeout = function () {    alert('超时了')};xhr.send();xhr.onreadystatechange = function () {    if(xhr.readyState === 4 &amp; xhr.status === 200) {        console.log(xhr.responseText);    }};</code></pre><p><strong>onload:</strong></p><pre><code class="js">发送请求var xhr = new XMLHttpRequest(); xhr.open('get','接口')； xhr.send(); 响应处理：    - xhr中提供了onload事件，直接用于表示xhr.readyState为4的情况，用于简化响应处理操作    - 但是还是需要进行xhr.status的判断处理xhr.onload = function () {    if (xhr.status === 200){        console.log(xhr.responseText);    }};</code></pre>        <h2 id="FormData对象的使用">          <a href="#FormData对象的使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#FormData对象的使用" class="headerlink" title="FormData对象的使用"></a><strong>FormData对象的使用</strong></h2>      <p>使用FormData模拟表单进行自定义数据上传</p><pre><code class="js">1创建一个空的FormData对象  var fd = new FormData();2给fd添加数据，使用fd的append()fd.append('name','jack');fd.append('age',18);注：无法直接输出fd查看数据，需要使用get方法操作 Eg：  consol.log(fd.get('name'));3通过ajax发送给对应接口    -注：FormData数据必须使用post请求方式发送  var xhr = new XMLHttpRequest();  xhr.open('post','端口');    -直接将FormData对象放入到send()参数中即可，也不需要设置requestHeader  xhr.send(fd);</code></pre>        <h3 id="使用FormData对表单数据进行处理：">          <a href="#使用FormData对表单数据进行处理：" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用FormData对表单数据进行处理：" class="headerlink" title="使用FormData对表单数据进行处理："></a><strong>使用FormData对表单数据进行处理：</strong></h3>      <p><strong>html结构：</strong></p><pre><code class="js"> &lt;form id="myForm"&gt;    用户名: &lt;input type="text" name="username"&gt;    &lt;br&gt;    密码: &lt;input type="password" name="psw"&gt;    &lt;br&gt;    性别: &lt;input type="password" name="gender"&gt;    &lt;br&gt;    学校: &lt;input type="password" name="school"&gt;    &lt;br&gt;    &lt;!-- 为了不产生表单提交效果，将按钮修改为普通按钮即可 --&gt;    &lt;button id="btn" type="button"&gt;提交&lt;/button&gt;  &lt;/form&gt;</code></pre><p><strong>js部分：</strong></p><pre><code class="js">var myForm = document.qureySelector("#myForm");1进行按钮操作document.getElementById('btn').onclick = function () {    2通过FormData对象获取表单所有数据      -给FormData传入参数，参数为form标签/DON对象    var fd = new FormData(mtForm);    注①    希望在表单元素的基础上，再格外上传一些数据，也可以使用append()    fd.append('girlFriend','rose');       -delete()删除某天数据       fd.delete('***')    3通过ajax发送     var xhr = new XMLHttpRequest();      xhr.open('post', '接口');      xhr.send(fd);}</code></pre>        <h3 id="文件的上传1：【有form】">          <a href="#文件的上传1：【有form】" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件的上传1：【有form】" class="headerlink" title="文件的上传1：【有form】"></a><strong>文件的上传1：【有form】</strong></h3>      <pre><code class="html">&lt;form id="myForm"&gt;    &lt;input type="text" name="username"&gt;    &lt;input type="password" name="pws"&gt;    &lt;textarea name="txt"&gt;&lt;/textarea&gt;    &lt;!-- 文件域：用于进行文件选取 --&gt;    &lt;input type="file" name="avatar"&gt;    &lt;button type="button" id="btn"&gt;按钮&lt;/button&gt;  &lt;/form&gt;  &lt;!-- 这个img用于显示上传后的线上图片 --&gt;  &lt;img src="" alt="" id="pic"&gt;&lt;script&gt;    // 1 按钮点击事件    var btn = document.getElementById('btn');    var myForm = document.getElementById('myForm');    var pic = document.getElementById('pic');    btn.onclick = function () {      // 2 使用fd管理表单数据      var fd = new FormData(myForm);      // 3 将表单提交给服务器（包含了要上传的文件）      var xhr = new XMLHttpRequest();      xhr.open('post', '接口');      xhr.send(fd);      // 响应内容中具有上传的图片文件的线上地址，可以进行访问      xhr.onload = function () {        if (xhr.status === 200) {          var res = JSON.parse(xhr.responseText);          pic.src = '接口' + res.url;        }      }    };  &lt;/script&gt;</code></pre>        <h3 id="文件上传2：【无form】">          <a href="#文件上传2：【无form】" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件上传2：【无form】" class="headerlink" title="文件上传2：【无form】"></a><strong>文件上传2：【无form】</strong></h3>      <pre><code class="html">&lt;!-- 如果要上传的是一个单独的表单域，没有form结构，需要进行单独处理 --&gt;  &lt;input type="file" id="ipt"&gt;  &lt;!-- 由于没有form，button就不存在提交的问题 --&gt;  &lt;button id="btn"&gt;提交&lt;/button&gt;  &lt;img src="" alt="" id="pic"&gt;  &lt;script&gt;    var btn = document.getElementById('btn');    var ipt = document.getElementById('ipt');    var pic = document.getElementById('pic');    // 1 设置点击按钮事件    btn.onclick = function () {      // 2 创建FormData对象      var fd = new FormData();      // 3 根据需求将数据添加到fd中      //   - 如何进行文件添加      //     - 1 找到文件域中选择的文件      //       - ipt.files[0] 代表了要上传的文件      //       - ipt.files.length 代表选择文件的个数，如果为0说明没选文件         //     - 2 使用append将文件添加到fd中即可      fd.append('fileUpload', ipt.files[0]);      // 4 发送请求      var xhr = new XMLHttpRequest();      xhr.open('post', '接口');      xhr.send(fd);      // 5 接收响应，可以将线上图片地址进行展示      xhr.onload = function () {        if (xhr.status === 200) {          pic.src = '接口' + JSON.parse(xhr.responseText).url;        }      }    };</code></pre>        <h3 id="JQuery发送FormData的方式：">          <a href="#JQuery发送FormData的方式：" class="heading-link"><i class="fas fa-link"></i></a><a href="#JQuery发送FormData的方式：" class="headerlink" title="JQuery发送FormData的方式："></a><strong>JQuery发送FormData的方式：</strong></h3>      <pre><code class="html"> &lt;!-- 如果要上传的是一个单独的表单域，没有form结构，需要进行单独处理 --&gt;  &lt;input type="file" id="ipt"&gt;  &lt;!-- 操作按钮 --&gt;  &lt;button id="btn"&gt;提交&lt;/button&gt;  &lt;!-- 用于展示线上的图片地址 --&gt;  &lt;img src="" alt="" id="pic"&gt;  &lt;script src="./lib/jquery.js"&gt;&lt;/script&gt;  &lt;script&gt;    // 1 设置按钮的点击事件    $('#btn').on('click', function () {      // 2 获取文件域的文件信息      var files = $('#ipt')[0].files;      console.log(files);      // 3 检测是否上传了文件      if (files.length === 0) {        return;      }      // 4 创建FormData对象      var fd = new FormData();      fd.append('uploads', files[0]);      // 5 通过jQuery的ajax发送这个FormData      $.ajax({        type: 'post',        url: '接口',        // 将fd直接设置给data        data: fd,        // 如果要发送FormData，必须设置以下属性        contentType: false, // 无需jQuery设置请求参数的内容类型        processData: false, // 无需jQuery进行数据处理        success: function (res) {          if (res.status === 200) {            $('#pic').prop('src', '接口' + res.url)          }        }      });    });  &lt;/script&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xhr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON在js转换方法</title>
      <link href="/2020/02/24/JSON%E5%9C%A8js%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/"/>
      <url>/2020/02/24/JSON%E5%9C%A8js%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<pre><code class="js">JSON.parse()将JSON转换为js对象JSON.stringify()将js对象转换为JSON</code></pre><p>注：JSON的格式</p><ul><li>属性名必须使用双引号包裹</li><li>字符串类型的值必须使用双引号包裹</li><li>JSON 中不允许使用单引号表示字符串</li><li>JSON 中不能写注释</li><li>JSON 的最外层必须是对象或数组格式</li><li>不能使用 undefined 或函数作为 JSON 的值<a id="more"></a></li><li>JSON 的作用：在计算机与网络之间存储和传输数据。</li><li>JSON 的本质：用字符串来表示 Javascript 对象数据或数组数据</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封装Ajax函数</title>
      <link href="/2020/02/23/%E5%B0%81%E8%A3%85Ajax%E5%87%BD%E6%95%B0/"/>
      <url>/2020/02/23/%E5%B0%81%E8%A3%85Ajax%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="封装Ajax函数">          <a href="#封装Ajax函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#封装Ajax函数" class="headerlink" title="封装Ajax函数"></a><strong>封装Ajax函数</strong></h2>              <h3 id="封装准备工作-封装将对象转换为urlencoded函数">          <a href="#封装准备工作-封装将对象转换为urlencoded函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#封装准备工作-封装将对象转换为urlencoded函数" class="headerlink" title="封装准备工作_封装将对象转换为urlencoded函数"></a><strong><u>封装准备工作_封装将对象转换为urlencoded函数</u></strong></h3>      <p><strong>方式1：</strong></p><pre><code class="js">  function urlencoded(obj) {     1 遍历对象obj     var str = '';     for (var key in obj) {         2将当前属性拼接为 '名=值' 的格式         str += key + '=' + obj[key] + '&amp;';     }     3将字符串最后多余的&amp;去除     //str = str.slice(0,str.length - 1);     str = str.slice(9,-1);    4设置返回值即可 return str;       }</code></pre><p><strong>方式2：</strong> <a id="more"></a></p><pre><code class="js">function urlencoded(obj) {    1遍历对象    var arr = [];    for (var key in obj) {     2 将当前属性拼接为 '名=值' 的格式     arr.push(key + '=' + obj[key]);    }     3 使用数组方法join()用&amp;连接每个元素即可    return arr.join('&amp;');}</code></pre><p><strong>多功能目标的演示：</strong></p><pre><code class="js">var result = urlencoded({      name: 'jack',      age: 18,      gender: '男'    });    console.log(result);</code></pre>        <h3 id="封装Ajax函数-1">          <a href="#封装Ajax函数-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#封装Ajax函数-1" class="headerlink" title="封装Ajax函数"></a><strong><u>封装Ajax函数</u></strong></h3>      <pre><code class="js">封装一个函数模拟$.ajax()的使用形式     参数：配置对象形式       - option       - type 请求方式       - url 请求地址       - data 请求参数       - success 回调函数       function ajax(option) {           ---请求发送功能---               1初始化               var xhr = new XMLHttpRequest();               2 由于后续请求发送功能的get和post操作不同，根据请求方式进行分别设置                  - 因为请求方式名不区分大小写，可以进行统一转换                     - toLowerCase() 用于将字符串中的字母转换为小写               var type = option.type.toLowerCase();                  -将data统一转换为urlencoded               var data = urlencoded(option.data);           if (type === 'get') {               2.1 设置get请求的open和send功能               xhr.open('get',option.url + '?' + data);               xhr.send();           } else if (type === 'post') {               2.2 设置post请求的open和send功能               xhr.open('post',option.url);               xhr.setRequestHeader('Content-Type','application/x-ww-form-uelencoded');               xhr.send(data);           }           ---响应处理功能---               1 设置事件               xhr.onreadystatechange = function () {                   2 检测状态                   if(xhr.readyState === 4 &amp; xhr.status === 200) {                       3 将JSON格式的数据转换为对象                        varres = JSON.parse(xhr.responseText);                       4 操作响应的数据                       option.success(res)                   }               };       }</code></pre>        <h5 id="准备用于将对象转换为urlencoded的函数：">          <a href="#准备用于将对象转换为urlencoded的函数：" class="heading-link"><i class="fas fa-link"></i></a><a href="#准备用于将对象转换为urlencoded的函数：" class="headerlink" title="准备用于将对象转换为urlencoded的函数："></a><strong>准备用于将对象转换为urlencoded的函数：</strong></h5>      <pre><code class="js">function urlencoded(obj) {      1 遍历对象      var arr = [];      for (var key in obj) {       2 将当前属性拼接为 '名=值' 的格式        arr.push(key + '=' + obj[key]);      }      3 使用数组方法join()用&amp;连接每个元素即可      return arr.join('&amp;');    }</code></pre><blockquote><p> <em>// 代码纯属演示：</em></p><p>  <em>// - 用于说明jQuery的get请求本质与原生操作相同，因为就是基于原生封装的</em></p><p>  <em>// - 直接将get参数拼接在url后面一样可以正常发送</em></p><p>  $.get(‘网址+?id=1&amp;bookname=西游记’, function (<em>res</em>) {</p><p>   console.log(res);</p><p>  });</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>get请求与post请求的区别</title>
      <link href="/2020/02/23/get%E8%AF%B7%E6%B1%82%E4%B8%8Epost%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/02/23/get%E8%AF%B7%E6%B1%82%E4%B8%8Epost%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="总结">          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2>              <h3 id="get请求与post请求的区别：">          <a href="#get请求与post请求的区别：" class="heading-link"><i class="fas fa-link"></i></a><a href="#get请求与post请求的区别：" class="headerlink" title="get请求与post请求的区别："></a><strong>get请求与post请求的区别：</strong></h3>      <p><strong>1.语义区别:</strong></p><div class="table-container"><table><thead><tr><th>-get</th><th>-post</th></tr></thead><tbody><tr><td>请求用于获取数据</td><td>请求用于发送数据</td></tr></tbody></table></div><a id="more"></a><p><strong>2.请求参数的发送位置有区别：</strong></p><p>  -get请求的参数，在URL中传递</p><p>  -post请求的请求参数，无法看到传递位置</p><p><strong>3.可发送数据大小不同</strong></p><p>   -get请求参数在URL中发送，浏览器限制了URL的长度，不同浏览器限制不同</p><p>​        -可发送数据大小为2k</p><p>​    -post请求，理论上没有大小限制（都是由服务器限制）</p><p>​         -根据需求进行限制设置</p><p>​         -根据服务器处理能力进行限制设置</p><p><strong>4.可发送内容格式不同</strong></p><p>​    -get只能发送文字数据</p><pre><code> -post可以发送各种类型数据</code></pre><p><strong>get请求参数的形式：</strong></p><p>格式为：接口地址？请求参数</p><p>​          形式为：</p><pre><code>       请求参数：名=值&amp;名=值&amp;名=值......【注：某个值为中文，中文会自动进行编码处理】</code></pre><p>（network-&gt;点击某个get请求-&gt;headers-&gt;Query String Parameters-&gt;可以查看所参数）</p><p><strong>post请求参数形式：</strong></p><p>形式为：</p><p>​    URL编码形式urlencoded，只是与get发送位置不同，数据的形式相同</p><p>   （network-&gt;点击某个post请求-&gt;headers-&gt;Form Data-&gt;可以查看所有参数）</p>        <h3 id="原生的ajax发送get请求的使用：">          <a href="#原生的ajax发送get请求的使用：" class="heading-link"><i class="fas fa-link"></i></a><a href="#原生的ajax发送get请求的使用：" class="headerlink" title="原生的ajax发送get请求的使用："></a><strong>原生的ajax发送get请求的使用：</strong></h3>      <p>浏览器提供XMLHttpRequest构造函数，用于创建可以发送ajax对象</p>        <h4 id="—–请求发送功能—–">          <a href="#—–请求发送功能—–" class="heading-link"><i class="fas fa-link"></i></a><a href="#—–请求发送功能—–" class="headerlink" title="—–请求发送功能—–"></a><strong>—–请求发送功能—–</strong></h4>      <pre><code class="js">1创建xhr实例var xhr = new XMLMLHttpRequest();2调用open()用于建立与服务器的链接    -设置请求方式和请求地址    -参数1：请求方式，get或者post    -请求地址xhr.open('get','地址')；3调用send()，用于将请求发送出去，这一句send()是异步代码xhr.send();</code></pre>        <h4 id="—–响应处理功能—–">          <a href="#—–响应处理功能—–" class="heading-link"><i class="fas fa-link"></i></a><a href="#—–响应处理功能—–" class="headerlink" title="—–响应处理功能—–"></a><strong>—–响应处理功能—–</strong></h4>      <pre><code class="js">由于send()是异步操作，所有不能直接在send()之后直接写代码获取响应内容- xhr.readyState 用于表示ajax对象的操作状态     - 0 初始化阶段：创建了xhr实例     - 1 调用open：建立与服务器的连接     - 2 调用send：请求发送了     - 3 下载中     - 4 下载完毕：确定下载完毕，还能使用响应的数据  1设置事件，监测响应的状态 xhr.onreadystatechange = function () {     2检测响应下载完毕，还应当确保本次请求是成功的请求状态，这样响应才有意义       - xhr.status 本次请求的状态码         - 200 成功  404没有找到对应资源          if (xhr.status === 4　&amp;&amp; xhr.status === 200) {            3 获取响应内容        // console.log(xhr.responseText);            var data = xhr.responseText;         4 将JSON格式的数据转换为js对象          由于是原生写法，没有人帮我们进行数据类型处理，我们需要自己进行数据处理        data = JSON.parse(data);        console.log(data);         } };</code></pre>        <h3 id="发送带有参数的get请求：">          <a href="#发送带有参数的get请求：" class="heading-link"><i class="fas fa-link"></i></a><a href="#发送带有参数的get请求：" class="headerlink" title="发送带有参数的get请求："></a><strong>发送带有参数的get请求：</strong></h3>              <h4 id="—-请求发送功能—">          <a href="#—-请求发送功能—" class="heading-link"><i class="fas fa-link"></i></a><a href="#—-请求发送功能—" class="headerlink" title="— 请求发送功能—"></a><strong>— 请求发送功能—</strong></h4>      <pre><code class="js">    1 初始化xhr对象    var xhr = new XMLHttpRequest();    2 调用open       - get请求参数以?连接，拼接在url后面，形式为urlencoded    xhr.open('get', 'http://www.liulongbin.top:3006/api/getbooks?id=2&amp;bookname=红楼梦');    3 调用send    xhr.send();</code></pre>        <h4 id="—响应处理—">          <a href="#—响应处理—" class="heading-link"><i class="fas fa-link"></i></a><a href="#—响应处理—" class="headerlink" title="—响应处理—"></a><strong>—响应处理—</strong></h4>      <pre><code class="js">     1 设置事件    xhr.onreadystatechange = function () {     2 检测响应是否下载完毕/请求是否成功      if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) {     3 接收响应内容        var res = xhr.responseText;      4 将JSON转换为js对象        res = JSON.parse(res);        console.log(res);      }    };</code></pre>        <h3 id="发送post请求：">          <a href="#发送post请求：" class="heading-link"><i class="fas fa-link"></i></a><a href="#发送post请求：" class="headerlink" title="发送post请求："></a><strong>发送post请求：</strong></h3>      <pre><code class="js">    1 初始化xhr对象    var xhr = new XMLHttpRequest();     2 调用open    xhr.open('POST', 'http://www.liulongbin.top:3006/api/addbook');     3 设置本次请求发送的内容类型（告诉服务器请求参数的类型）       - 设置内容类型为urlencoded即可       - setRequestHeader() 用于设置请求头的信息         - 请求头：是请求发送的一些额外信息，这些额外信息用于确保请求发送的数据可以正确被服务器接收使用    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');     4 发送请求       - post请求的请求参数为urlencoded形式，传入到send()中即可    xhr.send('bookname=老人与海&amp;author=海明威&amp;publisher=机械工业出版社');</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图书管理</title>
      <link href="/2020/02/22/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86/"/>
      <url>/2020/02/22/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><strong>html部分：</strong></p><p>只是一段代码没注释也不是很多</p><p>enter编码13  </p> <a id="more"></a><pre><code class="html">&lt;head&gt;        &lt;meta charset="UTF-8"&gt;        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;        &lt;title&gt;Document&lt;/title&gt;        &lt;link rel="stylesheet" href="./lib/bootstrap.css" /&gt;    &lt;/head&gt;    &lt;body style="padding: 15px;"&gt;        &lt;!-- 添加图书的Panel面板 --&gt;        &lt;div class="panel panel-primary"&gt;            &lt;div class="panel-heading"&gt;                &lt;h3 class="panel-title"&gt;添加新图书&lt;/h3&gt;            &lt;/div&gt;            &lt;div class="panel-body form-inline"&gt;                &lt;!-- 顶部进行图书新增的结构部分 --&gt;                &lt;div class="input-group"&gt;                    &lt;div class="input-group-addon"&gt;书名&lt;/div&gt;                    &lt;input type="text" class="form-control" id="iptBookname" placeholder="请输入书名"&gt;                &lt;/div&gt;                &lt;div class="input-group"&gt;                    &lt;div class="input-group-addon"&gt;作者&lt;/div&gt;                    &lt;input type="text" class="form-control" id="iptAuthor" placeholder="请输入作者"&gt;                &lt;/div&gt;                &lt;div class="input-group"&gt;                    &lt;div class="input-group-addon"&gt;出版社&lt;/div&gt;                    &lt;input type="text" class="form-control" id="iptPublisher" placeholder="请输入出版社"&gt;                &lt;/div&gt;                &lt;!-- 点击添加新图书 --&gt;                &lt;button id="btnAdd" class="btn btn-primary"&gt;添加&lt;/button&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;!-- 图书的表格 --&gt;        &lt;table class="table table-bordered table-hover"&gt;            &lt;thead&gt;                &lt;tr&gt;                    &lt;th&gt;Id&lt;/th&gt;                    &lt;th&gt;书名&lt;/th&gt;                    &lt;th&gt;作者&lt;/th&gt;                    &lt;th&gt;出版社&lt;/th&gt;                    &lt;th&gt;操作&lt;/th&gt;                &lt;/tr&gt;            &lt;/thead&gt;            &lt;tbody id="tb"&gt;                &lt;!-- 用于放置图书信息的tbody标签 --&gt;            &lt;/tbody&gt;        &lt;/table&gt;    &lt;/body&gt;</code></pre><p><strong>js部分：</strong></p><pre><code class="js">        &lt;script src="./lib/jquery.js"&gt;&lt;/script&gt;        &lt;script&gt;            renderBook();            $('#btnAdd').on('click', function() {                var val1 = $('#iptBookname').val().trim();                var val2 = $('#iptAuthor').val().trim();                var val3 = $('#iptPublisher').val().trim();                if (val1 === '' || val2 === '' || val3 === '') {                    alert('请输入完整的数据');                    return;                }                var kids = '添加书的接口addbooks';                $.post(kids, {                    bookname: val1,                    author: val2,                    publisher: val3                }, function(res) {                    if (res.status === 201) {                        renderBook();                        $('#bookname').val();                        $('#author').val();                        $('#publisher').val();                    }                })            });            function renderBook() {                var kid = '获取书的接口getbooks';                $.get(kid, function(res) {                    if (res.status !== 200) {                        return;                    };                    var data = res.data;                    console.log(data)                    var str = '';                    $.each(data, function(k, r) {                        str +=                            ' &lt;tr&gt;\                            &lt;td&gt;' + r.id + '&lt;/td&gt;\                            &lt;td&gt;' + r.bookname +                            '&lt;/td&gt;\                            &lt;td&gt;' + r.author + '&lt;/td&gt;\                            &lt;td&gt;' + r.publisher +                            '&lt;/td&gt;\                            &lt;td&gt;&lt;a href="javascript:;"&gt;删除                                                           &lt;/a&gt;&lt;td&gt;\                        &lt;/tr&gt;; '                    });                    $('#tb').html(str);                });            }        &lt;/script&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 应用与插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 案例（一） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax（总结）</title>
      <link href="/2020/02/22/Ajax(%E6%80%BB%E7%BB%93)/"/>
      <url>/2020/02/22/Ajax(%E6%80%BB%E7%BB%93)/</url>
      
        <content type="html"><![CDATA[<h1 id="总结">          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h1>      <p>Ajax是一种技术，这种技术通过执行一段js代码就可以实现【Asynchronous JavaScript And XML（也就是异步 JavaScript和XML）】</p><p>前端、后端交互的技术也就是【发送请求】与【接受响应结果】</p><a id="more"></a><p><img src="C:%5CMyBolg%5CMyBolg%5Csource_posts%5Cpost-name%5C1.png" alt=""></p><p>前端需要做的就是写JS代码发送请求、接受服务器返回的结果，并处理【<u>切记接口是后端的事</u>】</p>        <h3 id="关于Ajax代码有两种：">          <a href="#关于Ajax代码有两种：" class="heading-link"><i class="fas fa-link"></i></a><a href="#关于Ajax代码有两种：" class="headerlink" title="关于Ajax代码有两种："></a>关于Ajax代码有两种：</h3>      <p><strong>使用工具JQuery：</strong>        【别人封装好的，按语法使用】</p><div class="table-container"><table><thead><tr><th>$.get()</th><th>$.post()</th></tr></thead><tbody><tr><td>获取服务器中的资源</td><td>用于向服务器发送资源</td></tr><tr><td>方式：a标签的href、link/script:src/video……</td><td>发送post请求的方式</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>$.ajax()</th></tr></thead><tbody><tr><td>请求操作但不跳转功能；</td></tr><tr><td>network判断请求资源类型方式；</td></tr><tr><td>type判断请求资源类型；</td></tr><tr><td>xhr代表请求ajax |  document:请求html页面 jpeg/img……</td></tr></tbody></table></div><p><strong>使用原生的js：</strong>                   </p><pre><code class="js">var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () {     //this.responseTwxt;服务器返回的结果 }xhr.open();//post方式。注：加请求头xhr.send();</code></pre>        <h3 id="模版引擎：">          <a href="#模版引擎：" class="heading-link"><i class="fas fa-link"></i></a><a href="#模版引擎：" class="headerlink" title="模版引擎："></a><strong>模版引擎：</strong></h3>      <p><strong>加载：</strong></p><p>   引入template-web.js</p><p><strong>设置模版</strong>：</p><p>type = ‘text/template’    id = ‘xxx’</p><p><strong>JS代码 ：</strong></p><p>准备数据，实际多数都是服务器返回的数据</p><p>调用template函数 ：参数1：模版id 参数2：需要展示的数据 返回值：拼接好一段HTML</p><p><strong>模版语法：</strong>          【｛｛｝｝英文的花括号】</p><div class="table-container"><table><thead><tr><th><strong></strong></th><th><strong></strong></th><th><strong></strong></th></tr></thead><tbody><tr><td>$data代表template()传入参数2，数据对象</td><td>$data可以正常的进行属性访问</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>如果访问￥data的属性,可以不写$data</td><td></td><td>填充内容是结构字符串，并且进行结构生成，在内容前书写@</td></tr></tbody></table></div><p>重点：</p><p>1.接口是后端写的，提供接口文档</p><p>2.必须按照接口文档来发送请求【注：①接口规定是什么请求方式，必须用该请求方式，哪怕看着不顺眼②接口要什么请求参数，必须给对象的请求参数】</p>        <h3 id="细节：">          <a href="#细节：" class="heading-link"><i class="fas fa-link"></i></a><a href="#细节：" class="headerlink" title="细节："></a><strong>细节：</strong></h3>      <p><strong>同步异步：</strong></p><p><strong>同步：</strong>大多数js功能都是同步任务，会按照代码书写顺序执行。</p><p><strong><u>注:某些任务较为耗时或执行时间不确定，如果采用同步任务，会导致后续的任务等待</u></strong></p><p><strong>异步：</strong>异步任务总是在同步任务之后执行，不会导致其它任务进行等待。</p><pre><code>--------常见的异步任务有：定时器 / AJAX</code></pre><p><strong>请求参数写法：</strong></p><p>JQuery封装的三个方法 对象形式：{参数:值,参数:值,…}</p><p>原生的JS——-参数=值&amp;参数=值&amp;…..</p><p><strong>两种请求方式的区别：</strong></p><p>意义不同</p><p>传递数据大小不同</p><p>参数位置不同</p><p>接受到服务器返回的数据，如何渲染【模版引擎】</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何有效阅读一本书（六）</title>
      <link href="/2020/01/29/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6(%E5%85%AD)/"/>
      <url>/2020/01/29/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6(%E5%85%AD)/</url>
      
        <content type="html"><![CDATA[<p>读书笔记是一种升华工具，可以让读书活动完成从生搬硬套到独创思维的飞跃。</p><p>固定场景中重读笔记【另一方面要养成重读笔记—量化重读漂频率】</p><p>积极输出促进思想内化</p><p>杂：我想了一下，好像什么都没记住，我感觉预习也很重要。不不不应该很重要。对没错，是这样。。。哦对了还有一点是切勿眼高手低  <a id="more"></a></p><p>通过重读为思想增色</p><p>1.想要简单回顾是—-重读读书笔记</p><p>2.想要回忆起更多时—-参考书中的重点段落</p><p>3.想从头开始看起时—–重读原书</p><p>等待….</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 基础（一）</title>
      <link href="/2020/01/21/js-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/01/21/js-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="js的语法基础：（ECMASCRIPT）">          <a href="#js的语法基础：（ECMASCRIPT）" class="heading-link"><i class="fas fa-link"></i></a><a href="#js的语法基础：（ECMASCRIPT）" class="headerlink" title="js的语法基础：（ECMASCRIPT）"></a><strong>js的语法基础：（ECMASCRIPT）</strong></h3>      <div class="table-container"><table><thead><tr><th>js的书写位置：</th><th>内嵌式写法：</th><th>外联式写法：【大项目】</th></tr></thead><tbody><tr><td>eg：参照css的书写位置（1.行内式2.内嵌式3.外联式）</td><td>1.最好写在body的后面外联式写法：【大项目】</td><td>1.新建js文件（后缀名就是.js）【直接写js 】</td></tr></tbody></table></div><pre><code class="js">通过&lt;script src='js文件路径'&gt;&lt;/script&gt;引用js文件</code></pre><p>行内式写法：（了解）</p><pre><code>1.点击事件onclick</code></pre><p>js输出消息：<a id="more"></a></p><p>●为什么学习js输出消息的方式？</p><pre><code>   展示的结果给用户查看</code></pre><p>在控制台中输出消息：</p><div class="table-container"><table><thead><tr><th>console．log（）</th></tr></thead><tbody><tr><td>注意：在程序中遇到的任何一个特殊符号，都必须是英文输入法下的符号。</td></tr></tbody></table></div><p>在浏览器弹出一个新窗口【alert();】</p>        <h3 id="js变量">          <a href="#js变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#js变量" class="headerlink" title="js变量"></a><strong>js变量</strong></h3>      <p>字面意思：</p><pre><code class="js">变量：变化的值</code></pre><p>程序角度：</p><pre><code class="js">保存数据的一个容器</code></pre><p>变量的定义：</p><pre><code class="js">var 自定义变量名注意：定义变量必须写 var</code></pre><p>变量的赋值：</p><pre><code class="js">1.var 变量名 = 值;2.var 变量名;  变量名 = 值;注意：'='赋值运算符  将'='右侧的值赋给左侧的变量</code></pre><p>备注：如果在程序中输出一个值，如果该值是一个变量，不需要加引号。</p><p>备注：程序输出一个值，如果该值是一个变量，不需要加引导。如果不是则需要加。</p><p>​             一个变量可以重复赋值，但是一个变量只能一个值，而且是最后一次赋值的结果。</p><p>备注:  ‘=’两边都需要加个空格</p>        <h3 id="变量名的命名规则">          <a href="#变量名的命名规则" class="heading-link"><i class="fas fa-link"></i></a><a href="#变量名的命名规则" class="headerlink" title="变量名的命名规则"></a>变量名的命名规则</h3>      <p>1.变量名在合法的时候还要具有一定的语义</p><p>2.不能用关键字命名【关键字不能作为变量名】—–关键字—–在js中有特殊含义</p><p>3.不能数字开头命名【不能以特殊符号开头，‘_’ ,’$’除外】</p><p>4.变量中不能出现空格</p><p>5.不能使用汉字定义变量</p><p>6.不建议直接使用‘name’作为变量名，容易和属性冲突</p><p>7.不建议使用js中的<strong>保留字</strong>作为变量名————在当前版本没有特殊含义，但是js其它版本或以后版本中具有关键字的作用</p>        <h3 id="练习1">          <a href="#练习1" class="heading-link"><i class="fas fa-link"></i></a><a href="#练习1" class="headerlink" title="练习1:"></a><strong>练习1:</strong></h3>      <p>让用户输入任意的摄氏度,得到对应的华氏度.[华氏度=9/5*摄氏度+32]</p><pre><code class="js">var kid =  prompt('请输入摄氏度...');var kids = 9/5*kid+32;  document.write(kids);</code></pre>        <h3 id="练习2">          <a href="#练习2" class="heading-link"><i class="fas fa-link"></i></a><a href="#练习2" class="headerlink" title="练习2:"></a><strong>练习2:</strong></h3>      <p>交换两个变量的值</p><pre><code class="js">水杯问题:var a = 1;var b = 2;var c = a;a=b;b=c;document.write(a,b);</code></pre>        <h3 id="练习3">          <a href="#练习3" class="heading-link"><i class="fas fa-link"></i></a><a href="#练习3" class="headerlink" title="练习3:"></a><strong>练习3:</strong></h3>      <p>求和</p><pre><code class="js">var kid = 3;  //var kid = '3';var kids = 2;var kll = kid + kids;console.log(kll);</code></pre>        <h3 id="数据类型">          <a href="#数据类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h3>      <p><strong>1.简单数据类型</strong>【掌握】</p><p> ●数字类型number</p><p>●字符串类型string</p><p>●布尔类型boolean</p><p>●undefined类型</p><p><strong>2.复杂类型【注】</strong></p><p>object</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级（三）</title>
      <link href="/2020/01/17/js%E9%AB%98%E7%BA%A7%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/01/17/js%E9%AB%98%E7%BA%A7%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>  this的使用：</p><p>●this是特殊的标识符，代表某个对象值。取值根据函数的调用方式会发生变化</p><p>●全局中直接访问this，默认window</p><p>构造函数中this，默认为实例对象</p><p>方法中的this，默认为调用者</p>        <h3 id="自调用函数与模块化">          <a href="#自调用函数与模块化" class="heading-link"><i class="fas fa-link"></i></a><a href="#自调用函数与模块化" class="headerlink" title="自调用函数与模块化"></a><strong>自调用函数与模块化</strong></h3>      <p>模块：块、部分意思。</p><p> 模块化：指的是，将没进行</p><p>依赖：就是使用的意思   【文件不能划分全局作用域】<a id="more"></a></p><p>回调函数：作为函数参数使用的函数</p><p>forEach():遍历到数组的每个元素</p><p>注：return 不能结束</p><p>注：qAll的结果为NList伪数组对象具有forEach</p><p>数组其它回调函数到方法：</p><p>map（）every（）some（）reduce（）filter（）find（）findIndex（）</p><p>查文档自学上述方法【寒假作业】</p>        <h1 id="mdn">          <a href="#mdn" class="heading-link"><i class="fas fa-link"></i></a><a href="#mdn" class="headerlink" title="mdn"></a><strong>mdn</strong></h1>      <p>局部变量（私有变量）确保数据安全性</p><p>如果将变量设置为私有变量，就可以确保数据安全性，不会被外界操作修改。</p><p>​      →  问题是：不仅不能修改，也无法访问</p><p>作用域。。接受返回值（返回值是函数）</p><p>确保数据安全性—-闭包函数作用</p>        <h4 id="函数只能返回一个返回值">          <a href="#函数只能返回一个返回值" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数只能返回一个返回值" class="headerlink" title="函数只能返回一个返回值"></a><strong>函数只能返回一个返回值</strong></h4>      <p>递归函数：</p><p>为什么   5：5？  【注：06|||||||||||||】</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前言</title>
      <link href="/2020/01/16/%E5%89%8D%E8%A8%803/"/>
      <url>/2020/01/16/%E5%89%8D%E8%A8%803/</url>
      
        <content type="html"><![CDATA[<p>读书笔记是自己和书的对话，所以不需要别人的观点，但如果在做完读书笔记以后可以重读书评，就可以参考“第三方的观点”，换个角度审视自己的这次读书体验。于是你会发现，原来对自己来说有着某种意义的书，在这个人眼里是这样的。</p><p>从某种意义上说，所有的艺术都带有一些自传体性质，你只能唱自己的歌画自己的画；只能做一个由自己的经验，环境和家庭所造成的你。无论好坏都的在生命的交响乐中演奏自己的小乐器。</p><p>明白不代表理解，理解不代表会应用，会应用不代表做的对，对不代表省时省力，中间的每一个环节考的就是这两个东西。</p><p>😸一个是练习      😸一个是不断总结</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何有效阅读一本书（五）</title>
      <link href="/2020/01/16/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2020/01/16/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="如何有效阅读一本书（五）">          <a href="#如何有效阅读一本书（五）" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何有效阅读一本书（五）" class="headerlink" title="如何有效阅读一本书（五）"></a>如何有效阅读一本书（五）</h2>              <h3 id="剪报式读书笔记">          <a href="#剪报式读书笔记" class="heading-link"><i class="fas fa-link"></i></a><a href="#剪报式读书笔记" class="headerlink" title="剪报式读书笔记"></a><strong>剪报式读书笔记</strong></h3>      <div class="table-container"><table><thead><tr><th>复印粘贴以备重读</th></tr></thead><tbody><tr><td>ps：可能会用不到，因为我大部分都是在kindle里面看 ：）</td></tr></tbody></table></div>        <h3 id="贴什么？">          <a href="#贴什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#贴什么？" class="headerlink" title="贴什么？"></a><strong>贴什么？</strong></h3>      <p> 抄——-这一页，正是这本书里最具代表性的一页。</p><p>①书腰</p><p>②信息卡片</p><p>③书签</p><p>④其它</p><blockquote><p>引：“如果一个人总是把死亡的觉悟挂在嘴边，总让人感觉有些虚伪。”</p></blockquote><p>杂：一切都会好起来的。不要想太多。 <a id="more"></a></p>        <h3 id="重读书评以加深思考">          <a href="#重读书评以加深思考" class="heading-link"><i class="fas fa-link"></i></a><a href="#重读书评以加深思考" class="headerlink" title="重读书评以加深思考"></a><strong>重读书评以加深思考</strong></h3>      <p>ps：不过有些书评简直是<del>惨不忍睹</del>。那也是书评，区分那些是好的那些是坏的。</p><blockquote><p>引：“实际上我们常常因为虚荣心过剩，过度表现自己而苦恼有时候连退一步只做到自爱都就觉得索然无味。”</p></blockquote><p>读书体验比书本身更重要，通过读重读笔记提高自我 【注：笔记—学以致用的读书体验】</p><p>概念：吸收精华—-原封不动地吸收书上的知识。</p><p>读书体验—以此契机我想到某件事（或如何理解）</p><p>杂：感觉有点心烦。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>阶段提问</title>
      <link href="/2020/01/16/%E9%98%B6%E6%AE%B5%E6%8F%90%E9%97%AE/"/>
      <url>/2020/01/16/%E9%98%B6%E6%AE%B5%E6%8F%90%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="阶段提问">          <a href="#阶段提问" class="heading-link"><i class="fas fa-link"></i></a><a href="#阶段提问" class="headerlink" title="阶段提问"></a><strong>阶段提问</strong></h2>      <p>项目：html css js 动画    移动端   iPad【添加后面的代码】</p><p>基础：每日反馈   学历：    webapi：   js高级：   动画：  矢量图标：  它们的语法格式：</p><p>innerTxet 和innerHTML的区别？  移动端的触摸事件：</p><p>tranform和translate：</p><p>js中注册事件：<a id="more"></a></p><p>事件委托：</p><p>冒泡的阻止发法：</p><p>dom事件的三个阶段：</p><p>bom？</p><p>什么是视口？</p><p>事件按键：</p><p>flex布局：</p><p>如何定义弹性盒子：</p><p>栅格系统（12列）</p><p>全局作用域（）；局部作用域</p><p>不同事件this指向会发生改变吗?</p><p>浏览器的关闭与存储：</p><p>让盒子居中：</p><p>rem适配： </p><p>媒体查询：</p><p>响应式布局：</p><p>js事件三个阶段：</p><p>less的用法：；变量</p><p>js数组函数方法？</p><p>break与区别？</p><p>js中的形参和实参区别？</p><p>js遍历方法？   【forEach】</p><p>let与var区别？</p><p>js中如何操作元素属性？</p><p>2d转换属性：；3d转化属性</p><p>流式布局？</p><p>设置获取本地存储？</p><p>字符串的用法？</p><p>less定义变量？</p><p>控制台菜单问题？</p><p>1.对于概念性问题是否深入？</p><p>2.实例对象？构造函数</p><p>【注：任何问题在上课先记下，不要研究，避免跟不上思路】</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防御机制（四）</title>
      <link href="/2020/01/16/%E5%BF%83%E7%90%86%E9%98%B2%E5%BE%A1%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2020/01/16/%E5%BF%83%E7%90%86%E9%98%B2%E5%BE%A1%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>就算有一万个做错的理由也不能改变一件做错的事实否则在这个世上千千万万的可怜人是不是都有踏入歧途的正当理由</p><p>事到如今，后悔有什么用，时间不会回头，过去也没办法改变，但你还有未来要面对</p><p>人，总是要跨出那一步才会真的知道后续的路该怎么走下去</p> <a id="more"></a>        <h3 id="我们的情绪地图">          <a href="#我们的情绪地图" class="heading-link"><i class="fas fa-link"></i></a><a href="#我们的情绪地图" class="headerlink" title="我们的情绪地图"></a><strong>我们的情绪地图</strong></h3>      <p>接纳自己的需求，忍受强烈的情感以及发展出自我价值。就意味着面对并接纳自己的各色情绪，拥有独立的自我与世界，强烈的自尊关乎着快乐与成就，相对的羞耻感，却是我们所知的一种最痛苦的感觉。我们生而为人，就要面对难以回避的诸多情绪。许多人难以承受他们的痛苦体验。承受：忍受特别是不可避免的感受。他们会赶快摆脱自己的感受（哈我想应该是酒与烟吧），分散注意力，甚至欺骗自己，怀疑他们的真实感受—-诉诸各种各样的防御机制。通常致使我们穿上防御盔甲的，正是这些最痛苦的情绪。</p><p>基本情感七对相对情绪：</p><p>1.愤怒与冷静</p><p>2.仇恨与爱</p><p>3.恐惧与自信</p><p>4.耻辱与无耻</p><p>5.感恩与对其的缺失</p><p>6.同情与愤慨</p><p>7.嫉妒与效法</p><p>一些最令我们感到痛苦，可能花一辈子时间都无法应对的情感，恰恰是那些我们初次感受到的情感。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 爱好心理学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 防御机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防御机制（三）</title>
      <link href="/2020/01/15/%E9%98%B2%E5%BE%A1%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/01/15/%E9%98%B2%E5%BE%A1%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>在阅读本书的过程中，随身携带一个笔记本，记录下自己的反应，并将之存放在一个安全的地方，确保除自己以外的任何人都查看不了。【注：尽你所能地对自己诚实，不批判自己，试着知、只将焦点放在事实本身，即你的实际感受，你未经大脑篡改的反应，而不是你认为自己应该采取的回应。不要逼迫自己改变什么。】</p><p>练习：</p><p>1.不能，并没有在意或并没有发现。人多的时候。</p><p>2.有过，不是很好，的确令人不安。</p><p>3.没人对我讲起过，但我无意中听到过，确实如此，确实事实。</p><p>【注：每个人都在试图回避痛苦真相时用到的方式。】 <a id="more"></a></p><p>要开始学会问自己，那些不愉快的事实是你也不愿面对的。ps：眼睛与心态吧。</p><p>需要：</p><p>1.将需求与依赖当作关系中必不可少的部分；</p><p>2.学习管理自己强烈的情感；</p><p>3.培养自尊感（而不是羞耻感或损伤自己的感受）</p><p>【学会对自己养成一种如是的诚实————在评估自己的时候，即不要太严苛，也不要太随意——这是解除自己防御的必要步骤，学着尽可能客观地评价自己。】</p><p>一下是问题：</p><p>想把事情办好就得亲自动手 </p><p>有时我太依赖他人了</p><p>遇到问题时，我总是幻想着别人替我“解决”</p><p>似乎我对别人的重视胜过他们对我的重视</p><p>我很少生气，从不会发火；</p><p>我超级会说话；</p><p>我时常尝试新事物，但总是三分钟热度；</p><p>我总是担心稍不留意就会有不花哦的事情发生</p><p>我经常反应过度，随之又懊悔不已</p><p>我希望自己没有情绪上的波动</p><p>我容易对自己犯下的错误过分自责</p><p>我害怕被人看低</p><p>我接受不了批判并对此十分抗拒</p><p>我希望自己是另一个人。</p><p><u><strong>【注：这里重点并不是为了把自己归类，而是为了了解你要面对的心理挑战是什么，并作为识别自身防御机制的前奏。这一点尤为重要。切记！！！】</strong></u>  </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 爱好心理学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级（二）</title>
      <link href="/2020/01/15/js%E9%AB%98%E7%BA%A7%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/01/15/js%E9%AB%98%E7%BA%A7%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="三个对象：">          <a href="#三个对象：" class="heading-link"><i class="fas fa-link"></i></a><a href="#三个对象：" class="headerlink" title="三个对象："></a>三个对象：</h3>      <p>1.构造函数2.原型对象3.实例对象</p>        <h3 id="三者关系小结：">          <a href="#三者关系小结：" class="heading-link"><i class="fas fa-link"></i></a><a href="#三者关系小结：" class="headerlink" title="三者关系小结："></a>三者关系小结：</h3>      <p>1.构造函数：都是prototype属性，就是原型对象</p><p>2.实例对象：都是有_ _ proto _ _属性，也是原型对象</p><p>3.原型对象：具有constructor属性，也就是构造函数</p><p><strong>注：两个对象同名不覆盖、不冲突</strong></p>        <h3 id="对象访问规则：">          <a href="#对象访问规则：" class="heading-link"><i class="fas fa-link"></i></a><a href="#对象访问规则：" class="headerlink" title="对象访问规则："></a>对象访问规则：</h3>      <p>对象进行属性访问，先查找自身，如果没有再找<strong>opsiodfoa</strong>,并一直重复此过程<a id="more"></a></p><p>查找ob.pro中如果还没有结果为undefined</p><p>这种由多个-型组成的结构，称为原型链</p><p>原型链的终点为Object.prototype</p><p>简单的说：就是 沿原型链查找【】</p>        <h3 id="构造函数的继承操作：">          <a href="#构造函数的继承操作：" class="heading-link"><i class="fas fa-link"></i></a><a href="#构造函数的继承操作：" class="headerlink" title="构造函数的继承操作："></a><strong>构造函数的继承操作：</strong></h3>      <p><strong>创建子类、同时继承父类</strong></p><p>  ●使用构造函数进行集成时，属性和原型方法需要分别处理</p><p><strong>继承父类属性：</strong></p><p>   xx.call（this）的部分是固定形式，后面的参数按需修改</p><p>还可以进行新的属性设置，而且新的属性设置和继承操作没有顺序要求</p><p><strong>2.继承父类原型的方法</strong></p><p>   由于原型继承操作是通过覆盖方式实现的，导致xxx.prototype自身不具有constructor</p><p>为了避免问题，自己添加个constructor；属性即可</p><p>设置原型方法时，必须在继承操作之后设置，否则也会被覆盖，相对于没写</p>        <h3 id="多态设置：">          <a href="#多态设置：" class="heading-link"><i class="fas fa-link"></i></a><a href="#多态设置：" class="headerlink" title="多态设置："></a><strong>多态设置：</strong></h3>      <p>构造函数进行多态设置，只能进行覆盖设置，无法像class一样对父类功能进行扩展 </p><p>……..</p>        <h3 id="观察class与构造函数的关系：">          <a href="#观察class与构造函数的关系：" class="heading-link"><i class="fas fa-link"></i></a><a href="#观察class与构造函数的关系：" class="headerlink" title="观察class与构造函数的关系："></a>观察class与构造函数的关系：</h3>      <p>class操作的结果还是通过原型prototype进行处理的</p><p>只不过语法更简单</p>        <h3 id="给内置对象添加功能的方式">          <a href="#给内置对象添加功能的方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#给内置对象添加功能的方式" class="headerlink" title="给内置对象添加功能的方式"></a>给内置对象添加功能的方式</h3>      <p>内置方法的使用方式：</p><p>内置对象和我们之前的自定义对象设置方式相同，都是将方法设置在原型中</p><p>如果希望给内置对象设置新方法，设置在原型中即可</p><p>书写方式arr.xxx() 注：可读性更强</p>        <h3 id="函数进阶内容：-【this可以复用】">          <a href="#函数进阶内容：-【this可以复用】" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数进阶内容：-【this可以复用】" class="headerlink" title="函数进阶内容：  【this可以复用】"></a><strong>函数进阶内容：</strong>  【this可以复用】</h3>      <p>1.函数的属性和方法（属性了解，使用方法重点）</p><p>2.函数的其它使用方式</p><p> ●自调用函数（立即执行函数）</p><p>●回调函数</p><p>●闭包函数</p><p>●递归函数</p><p>2.函数方法   </p><p>1.call（）【用于调用函数，并设置本次掉用中的this】</p><p>   ●参数1：要设置的this值，对象结构</p><p>   ●后续参数：表示传入的实参，个数不限  </p><p>书写方式：xx.类名.（｛｝，x，x，x）</p><p>2.apply（）</p><p>apply用于调用函数，可以设置函数中的this</p><p>  ●参数1：用来设置函数中的this</p><p>●参数2：数组，用来保存实参</p><p>书写方式：xx.apply({},[]);</p><p>3.bind（） </p><p>bind含义为绑定。</p><p>call和apply可以设置this，但都是临时设置，只有本次调用有效</p><p>如果 希望this长期被设置为某个对象，可以通过bind方法进行操作</p><p>●参数1：需要绑定的this、值，对象</p><p>●后续参数：需要绑定的实参值</p><p>●返回值：绑定了this或实参的函数副本</p><pre><code class="js">function fun（a,b,c){consloe.log(this);consloe.log(a,b,c);}//调用bind后，需要对返回的函数副本进行操作var f1 = fun.bind({name:'啥啥啥'});f1（）；f1.call({})//绑定的实参如果与形参个数不同，进行调用时的传入方式也不一样</code></pre><p>绑定this和实参用返回值（</p><p>后续参数：需要绑定实参值</p><p>返回值：绑定了this或实参的函数副本</p><p>数组借用Math方法</p><hr><p>call 和apply区别：</p><p>call–传入实参是单个传入方式</p><p>apply–传入实参采用数组整体传入方式</p>        <h3 id="函数的声明方式：">          <a href="#函数的声明方式：" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数的声明方式：" class="headerlink" title="函数的声明方式："></a><strong>函数的声明方式：</strong></h3>      <p>1.函数声明语句</p><p>2.函数表达式</p><p><strong>两种声明方式的区别：</strong></p><p>1.参与预解析时规则不同</p><p>2.函数声明语句对使用位置有一些要求（特殊环境不推荐使用）</p><ul><li><p>不推荐在if语句中进行函数声明语句的设置（不同浏览器对这个操作的域解析结果不同）</p>        <h3 id="自调用函数">          <a href="#自调用函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#自调用函数" class="headerlink" title="自调用函数"></a><strong>自调用函数</strong></h3>      </li></ul><p>自调用函数、立即执行函数</p><p>效果：在当前位置执行一次后结束</p><p>作用：</p><p> ●将大功能分成小部分，每部分代码包裹一个自调用函数，可以形成独立的作用域</p><p>●可以避免多个功能的代码出现冲突（变量命名重复导致修改的问题）【多人开发时名称冲突的问题】</p><p><strong><u>书写注意点：每个自调用函数后的分号，必须加，否则，多个自调用函数连起来书写会报错</u></strong></p><pre><code>Eg：;(function(){})();</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防御机制（二）</title>
      <link href="/2020/01/14/%E5%BF%83%E7%90%86%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/01/14/%E5%BF%83%E7%90%86%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>​           当我们拒绝接纳自身大部分的情感经历时，我们会消耗自己，同时消弱自己面对这个世界的力量与能力。当你封闭了对自己需求的觉知，你就不肯能与TA人发展出真正的亲密关系。</p><p>注：abwehr指译为“避开”或“抵挡”要比“防御”更准确。就其本质而言，一切防御机制都是我们逃避痛苦而向自己撒的谎。</p><p>防御机制只顾眼下一刻，而不计后果，是一个人思虑不周的反射性行为，只是为了规避当下一刻的痛苦，却不考虑由此带来的长期损失。注：人类是受习惯约束的动物，这样一来，改变便显得尤其困难。一般来说我们极容易养成自己特有的或习惯性的防御模式，而这些规避痛苦的惯用方法则会对我们性格的塑造产生影响。一个人的个性或者’全部的性格特征都可以称为浓缩版的防御机制‘【人的应为举止，说话走路方式等】 <a id="more"></a></p><p>当某一种人格障碍被大众所熟悉时，却也定义了一个人的性格，框定了他/她的人际关系。</p><p>根据自身采取的防御机制，将会塑造我们的个性。也会影响人际关系。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 爱好心理学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 防御机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扩展</title>
      <link href="/2020/01/14/%E6%89%A9%E5%B1%95/"/>
      <url>/2020/01/14/%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<p>for(in):?【重要      】concat:?slice:?</p><p>var/let（过年后会讲）/const：？           严格模式：？【没人用】  块级作用域：？   dom：进程减少次数</p><p>事件委托：   减少事件的个数    动态处理？   _ _ proto _ _:       |  什么constructor原型  &lt;——&gt;people</p><p>先找自己后找内部？？？？</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级（一）</title>
      <link href="/2020/01/14/JavaScript%E9%AB%98%E7%BA%A7/"/>
      <url>/2020/01/14/JavaScript%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript高级（基础）">          <a href="#JavaScript高级（基础）" class="heading-link"><i class="fas fa-link"></i></a><a href="#JavaScript高级（基础）" class="headerlink" title="JavaScript高级（基础）"></a>JavaScript高级（基础）</h2>      <p>注：浏览器展示的小问题：</p><p>复杂类型在控制台输出是，进行展看操作后，会读取的最新值</p><p><strong>浏览器重要组成部分：</strong></p><p>内核（渲染引擎）： html /css—webAPI(DOM/BOM)</p><p>W3C规范</p><p>js解析器（Javascript引擎）： ECMScript   <a id="more"></a></p><p>ECMA规范</p><p>执行过程：</p><p>域解析：全局、函数 </p><p><strong>基本类型：</strong></p><p>字符串类型</p><p>数值类型</p><p>布尔类型</p><p>未定义类型——–undefined默认的，用来表示存储区域未使用</p><p>空类型 null———主动设置，清除存储区域</p><p>复杂类型：</p><p> objrct对象</p><p>array数组</p><p>date日期</p><p>functiion函数———代码重复使用【存储代码】</p><p>循环—-某个地方执行</p><p>math数学</p><p><strong>基本和复杂区别：</strong></p><p>存储个数不同</p><p><strong>内存存储方式不同</strong></p><p>​          ●基本—内存单元中存储是<strong>具体值</strong></p><p>​           ●复杂—内存单元中存储的<strong>地址</strong></p><p><strong>复制方式不同：</strong></p><p>​          ●基本——赋值=方式复制</p><p>​          ●复杂——-遍历拷贝（内置对象方法）</p><p><strong>复杂类型进行比较：（== /===）</strong></p><p>都是地址比较</p><p>注：两个复杂类型长得一样不一定相等/全等</p><p>包装对象：string  number  boolean   </p><p><strong>狭义（单个）：</strong></p><p>【任意对象都可以】</p><p>构造函数（需要复用）：</p><p>对象字面量：</p><p>数据存储</p>        <h3 id="面向对象与面向过程">          <a href="#面向对象与面向过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#面向对象与面向过程" class="headerlink" title="面向对象与面向过程"></a>面向对象与面向过程</h3>      <p>面向对象【分装功能使用方法调用】</p><p>注：面向对象和面向过程没有可比性</p><p><strong>封装性:</strong></p><p>  ●将面向过程的代码根据大功能划分后，封装多个函数，再将多个函数封装到对象中即可。</p><p>   ●<strong>将功能封装为对象。</strong></p><p><strong>继承性：</strong></p><p> ●<strong>继承操作，进行功能复用</strong></p><p><strong>多态性：</strong></p><p>某个功能被不同对象使用是的功能性不同，称多态【增强功能的灵活】</p><p><strong>面向对象操作：</strong></p><p><strong>class（重点） ———es6</strong>       【】</p><p><strong>首字母大写</strong></p><pre><code>class 类名 ｛constructor（需要参数）｛this.属性名 = 属性值；｝方法名（）｛｝｝var 实名类 =  new  类（）</code></pre><p>注：如果设置的子类方法与父类方法同名，会</p><pre><code class="htnl">class  子类 extends  person｛constructor（）｛  super（）  this.｝方法（）；｝var 变量 = new 。。。（）；</code></pre>        <h3 id="class继承">          <a href="#class继承" class="heading-link"><i class="fas fa-link"></i></a><a href="#class继承" class="headerlink" title="class继承"></a>class继承</h3>      <pre><code class="mjs">class Person {  constructor() {    this. = ;    this. = ;  }  名字() {    console.log('' + this.)；  }}class xxx extends Person{  constructor( xxx) {    super(xxx);    this.xxx = xxx;    this.xxx = xxx;  }  覆盖方法：  super.名字（）；【1.多态方法做扩展2.调】</code></pre><p> <strong>构造函数</strong>：——-函数名大写</p><p>多个实例对象设置的方法值不是同一个函数，将匿名函数设置为命名函数</p><p>统一对象的存储方式，可以减少在全局作用域名称数量</p><p>原型：</p><p>prototype原型对象———-<strong>函数优化</strong></p><p> constructor除了可以检测自定义实例对象的类型检测，也可以内置对象进行类型检测。【作用：类型确定功能】</p><p>typeof检测复杂类型只能得到object。。。。。。。。使用。。。。。。即可</p><p>零落满玉尘，霜打清浮册，墨染成瀑，清飞寒酥雪。忽沥薄阳起白风，展书一卷，读不尽满目苍凉</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前言</title>
      <link href="/2020/01/13/%E5%89%8D%E8%A8%80/"/>
      <url>/2020/01/13/%E5%89%8D%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<p>​          <strong>巴纳姆效应，巴纳姆效应是1948年由心理学家伯特伦·富勒通过试验证明的一种心理学现象，以杂技师巴纳姆的名字命名，认为每个人都会很容易相信一个笼统的、一般性的人格描述特别适合他。即使这种描述十分空洞，仍然认为反映了自己的人格面貌，哪怕自己根本不是这种人。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 爱好心理学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防御机制（一）</title>
      <link href="/2020/01/13/%E9%98%B2%E5%BE%A1%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/01/13/%E9%98%B2%E5%BE%A1%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="一切防御机制都是我们为逃避痛苦而向自己撒的谎">          <a href="#一切防御机制都是我们为逃避痛苦而向自己撒的谎" class="heading-link"><i class="fas fa-link"></i></a><a href="#一切防御机制都是我们为逃避痛苦而向自己撒的谎" class="headerlink" title="一切防御机制都是我们为逃避痛苦而向自己撒的谎"></a><strong>一切防御机制都是我们为逃避痛苦而向自己撒的谎</strong></h2>      <p><strong><u>注：阅读前请花几分钟阅读一下前言</u></strong></p><p>我们的内外一致性越高，对自我判断也就会越准确，越能抵消落差感，心理也就越成熟、越健康，提升自尊，增强自己面对这个世界的能力。真正的成长发生在一言一行之间，通常要在很长一段时间后才有质的飞跃，虽然在感受到威胁时勇往直前很重要，但也不要太过逼迫自己，或过高要求自己。再微小的自我觉知，再小的进步，都有其价值所在。</p> <a id="more"></a>        <h3 id="缺少自知之明：那个不认识的自己">          <a href="#缺少自知之明：那个不认识的自己" class="heading-link"><i class="fas fa-link"></i></a><a href="#缺少自知之明：那个不认识的自己" class="headerlink" title="缺少自知之明：那个不认识的自己"></a>缺少自知之明：那个不认识的自己</h3>      <p>人类通常终其一生都会认为那个拥有意识体验的TA们就是真实的自己，事实上，我们依旧对重要的情感世界所知不多。讲话人出现的口误，其实泄露的是Ta自己潜意识里的真实意愿。“忘记”：事实上并不是那个人故意疏忽不去兑现说过的承诺，忘记这一行为本身泄露了Ta自始至终就不愿去做那件事。 当我们无法看清自己，而Ta人却看得清清楚楚时，这对多数人而言时一件非常不越快的体验。如果被朋友说中了，我们会坚持称自己的口误（有时候一时的口误也当真别无他意）为语言故障，没有任何意义。 疏忽和出错往往揭露了一些事实，也就就是我们未能意识到，甚至对自己都不愿坦诚的真相。</p><p>心理防御机制都是一些无形的应对方式，通过它们，我们得以将那些无法接受的想法与感受排除在外。但它会以微妙的方式扭曲我们对现实的看法，这也包括人际关系和内心的情感领域</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 爱好心理学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环结构</title>
      <link href="/2020/01/13/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/"/>
      <url>/2020/01/13/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="循环语句">          <a href="#循环语句" class="heading-link"><i class="fas fa-link"></i></a><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2>      <p><strong>for-in循环</strong>———-知道循环几次用</p><p><strong>while循环</strong>————构造不知道循环次数的循环结构 使用while循环</p><p>while循环能产生或转出bool值来表达控制循环，即True循环继续False循环结束。</p><p>range（）【函数】</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 语言与Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分支结构</title>
      <link href="/2020/01/12/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/"/>
      <url>/2020/01/12/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="分支结构">          <a href="#分支结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h1>      <p><strong>if语句的使用【构造分支结构的关键字】</strong></p><p><strong>①if</strong> <strong>②elif</strong> <strong>③else</strong></p><p>注：和c/c++、Java等语言不同，Python中没有花括号构造代码而是使用了缩进的方式来设置的层次结构【连续的代码如果保持了相同的缩进那么它们属于同</p><p>一个代码块，相当于是一个执行的整体】。</p><p>构造跟多的分支则：【if…elif…else】结构。</p><p><strong>练习1：英制单位英寸与公制单位厘米互换。</strong> <a id="more"></a></p><pre><code class="python">kid = float（input（'请输入长度：'））kids = input（‘请输入单位：’）if kids ==‘in’ or kid ==‘英寸’：print（’%f英寸 =%f厘米‘ % （kid，kid*2.54））else kids ==‘cm’ or kids ==‘厘米’：print（‘%f厘米=%f英寸’%（kid，kid/2.54））else：  print（‘请输入有效单位’）</code></pre><p><strong>练习2：百分制成绩转换为等级制成绩。</strong></p><blockquote><p><strong>要求</strong>：如果输入的成绩在90分以上（含90分）输出A；80分-90分（不含90分）输出B；70分-80分（不含80分）输出C；60分-70分（不含70分）输出D；60分以下输出E。</p></blockquote><pre><code class="python">kid = input（'请输入成绩。。。'）；if  kid &gt;= 90:kids = 'A'elif  kid &gt;= 80 and kid &lt; 90:kids='B'elif  kid &gt;= 70 and kid &lt; 80:kids='C'elif  kid &gt;= 60 and kid &lt; 70:kids='D'ekse:   kids='E'   print('对应等级是：'，kids)</code></pre><p><strong>练习3：输入三条边长，如果能构成三角形就计算周长和面积。</strong></p><pre><code class="python">a = float(input('a='))b = float(input('b='))c = float(input('c'))if a+b&gt;c and a+c&gt;b and b+c&gt;a:print('周长：%.2f' % (a+b+c))p =(a+b+c)/2area =(p*(p-a)*(p-b)*(p-c))**0.5  //海伦公式print('面积：%.2f' % (area))else:    print('不能构成三角形')</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 语言与Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回顾 + BOM模型最后一部分</title>
      <link href="/2020/01/12/%E5%9B%9E%E9%A1%BE/"/>
      <url>/2020/01/12/%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="回顾">          <a href="#回顾" class="heading-link"><i class="fas fa-link"></i></a><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2>      <p>xx元素.style.left  =   -   200 * i  +   ‘px’</p><p>xx元素.style.left=’translateX(  - ‘  +  24*i  + ‘  % )’</p><p>定时器设置全局变量以防反复创建</p><p>assign（url）</p><pre><code> localStorage.setlten对象</code></pre><p>sessionStorage对象<a id="more"></a></p><div class="table-container"><table><thead><tr><th><strong>history对象：</strong>     【了解：浏览器历史记录】</th><th></th><th></th></tr></thead><tbody><tr><td>history.back:后退一步</td><td></td><td></td></tr><tr><td>.forward():前进一步</td><td></td><td></td></tr><tr><td>.go(n)：后退（n为负时）或前进（n为正时）n步</td><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>navigator对象：  【了解：浏览器的名字版本号。。。。。】</th></tr></thead><tbody><tr><td>使用：navigator.userAgent：获取到浏览器的信息（字符串）</td></tr></tbody></table></div>        <h3 id="ocalStorage对象">          <a href="#ocalStorage对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#ocalStorage对象" class="headerlink" title="ocalStorage对象"></a><strong>ocalStorage对象</strong></h3>      <div class="table-container"><table><thead><tr><th>localStorage.setItem( ‘key名称’, ‘值’ )以给定的键（key）存储一个数据【只能存字符串】</th></tr></thead><tbody><tr><td><strong>localStorage.getItem( ‘key名称’ )获取指定键（key）对应的数据</strong></td></tr><tr><td><strong>localStorage.removeItem( ‘key名称’ )删除（key）对应的数据</strong></td></tr></tbody></table></div>        <h3 id="client系列：（不属于html属性？div？）">          <a href="#client系列：（不属于html属性？div？）" class="heading-link"><i class="fas fa-link"></i></a><a href="#client系列：（不属于html属性？div？）" class="headerlink" title="client系列：（不属于html属性？div？）"></a><strong>client系列：</strong>（不属于html属性？div？）</h3>      <p>除了：scrollTop 和scrollLeft——只读不可修改</p><p>xx元素.clientWidth:  盒子padding范围（含padding）的宽度</p><p>xx元素.clientHeight:盒子padding范围（含padding）的高度</p><p>xx元素.clientLeft:</p>        <h3 id="offset系列：（不可修改？）">          <a href="#offset系列：（不可修改？）" class="heading-link"><i class="fas fa-link"></i></a><a href="#offset系列：（不可修改？）" class="headerlink" title="offset系列：（不可修改？）"></a><strong>offset系列：</strong>（不可修改？）</h3>              <h3 id="scroll系列：">          <a href="#scroll系列：" class="heading-link"><i class="fas fa-link"></i></a><a href="#scroll系列：" class="headerlink" title="scroll系列："></a><strong>scroll系列：</strong></h3>      <p>top（有用，定位用。滑块位置没有单位）</p>        <h3 id="移动端">          <a href="#移动端" class="heading-link"><i class="fas fa-link"></i></a><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3>      <p>原生：</p><p>touchstart： 触摸开始事件</p><p>touchmove： 触摸移动事件</p><p>touchend： 触摸结束事件</p><p>【不会用到】</p><p>移动端事件绑定推荐用addEventListener（）方式</p><p>’使用第三方封装‘</p><p>触摸点信息的途径或方式：</p><p>事件处理函数传入参数（event）event.触摸点[i]【是个伪数组】</p>        <h3 id="三个触摸集合：">          <a href="#三个触摸集合：" class="heading-link"><i class="fas fa-link"></i></a><a href="#三个触摸集合：" class="headerlink" title="三个触摸集合："></a><strong>三个触摸集合：</strong></h3>      <p>e.touches:代表所有触摸点，是一个集合</p><p>e.targetTouches:代表当前绑定事件的某个元素（对象）上的所有触摸点，是一个集合。</p><p>e.changedTouches: 代表当前变换了的触摸点</p><p>总结：</p><p>关于移动端获取事件的信息的基本对象层级结构：</p><p> event对象》》触摸点集合》》触摸点》》触摸点属性</p>        <h3 id="封装tap事件">          <a href="#封装tap事件" class="heading-link"><i class="fas fa-link"></i></a><a href="#封装tap事件" class="headerlink" title="封装tap事件"></a>封装tap事件</h3>      <p><strong>tap事件的特征是：</strong>x坐标和y坐标的差值，都足够小</p><p><strong>左划事件:</strong>  x    y 差值，&lt; - 15;</p><p><strong>右划事件：</strong>x    y 差值    &gt; 15;</p><p>触摸开始</p><p>触摸接触</p>        <h3 id="transitionend（过渡完成）事件：">          <a href="#transitionend（过渡完成）事件：" class="heading-link"><i class="fas fa-link"></i></a><a href="#transitionend（过渡完成）事件：" class="headerlink" title="transitionend（过渡完成）事件："></a>transitionend（过渡完成）事件：</h3>      <p>过渡：表示过渡效果执行完成的那个时刻。</p><p>xx元素.children.length图片个数长度</p>        <h3 id="swiper轮播插件：">          <a href="#swiper轮播插件：" class="heading-link"><i class="fas fa-link"></i></a><a href="#swiper轮播插件：" class="headerlink" title="swiper轮播插件："></a>swiper轮播插件：</h3>      <p> <span class="exturl"><a class="exturl__link" href="https://www.swiper.com.cn" target="_blank" rel="noopener">https://www.swiper.com.cn</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回顾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语言元素</title>
      <link href="/2020/01/12/%E8%AF%AD%E8%A8%80%E5%85%83%E7%B4%A0/"/>
      <url>/2020/01/12/%E8%AF%AD%E8%A8%80%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="语言元素">          <a href="#语言元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#语言元素" class="headerlink" title="语言元素"></a>语言元素</h2>      <div class="table-container"><table><thead><tr><th>整数元素：</th><th>浮点类型：</th><th>字符串型：</th><th>布尔型：</th><th>复数型：</th></tr></thead><tbody><tr><td>int</td><td>float</td><td>str</td><td>true /false</td><td>3+4j（不常用）</td></tr></tbody></table></div><p><strong>变量命名：</strong></p>        <h3 id="硬性规则：">          <a href="#硬性规则：" class="heading-link"><i class="fas fa-link"></i></a><a href="#硬性规则：" class="headerlink" title="硬性规则："></a>硬性规则：</h3>      <p>1.字母数字和下划线构成（数字不能开头）</p><p>2.大小写的敏感</p><p>3.关键字 <a id="more"></a></p>        <h3 id="PEP-8要求：">          <a href="#PEP-8要求：" class="heading-link"><i class="fas fa-link"></i></a><a href="#PEP-8要求：" class="headerlink" title="PEP 8要求："></a>PEP 8要求：</h3>      <p>1.用小字母拼写</p><p>命名书见名知意</p><p>变量的使用：</p><p>输出：type</p><p>int():将一个数值或字符串转换成整数，可以制定进制</p><p>float():将一个字符串转换成浮点数。</p><p>str()：将指定的对象转换成字符串形式，可以指定编码</p><p>chr():将整数转换成该编码对应的字符串（一个字符）。</p><p>ord():将字符串（一个字符）转换成对应的编码（整数）。</p>        <h3 id="输出的字符串是占位符语法">          <a href="#输出的字符串是占位符语法" class="heading-link"><i class="fas fa-link"></i></a><a href="#输出的字符串是占位符语法" class="headerlink" title="输出的字符串是占位符语法"></a>输出的字符串是占位符语法</h3>      <p>①%d–整数     ②  %f–浮点数     ③%%–表示百分比【注：字符串之后%的变量会替换掉占位符】</p><p>运算符象html中一样除了【is ，is not（身份运算符）】【in，not in（成员运算符）】 【not，or，and（逻辑运算符）】</p><p><strong>练习1：华氏温度装换为摄氏温度</strong></p><pre><code class="python">   k = int(input(''));   n = (k-32)/1.8   print('%d=%d',(k,n))   //缩进问题</code></pre><p><strong>练习2：输入圆的半径计算周长和面积</strong></p><pre><code class="python">import math  gh=flost(input(''));  io=math.pi*gh;  kl= math*gh*gh;   print('周长：%.2f % io‘)   print('面积：%.2f % kl')</code></pre><p><strong>练习3：输入年份判断是不是闰年。</strong></p><pre><code>year=int(input(''));yu=(year % 4 == 0 and year % 100 !=0) or( year % 400 == 0 )print(yu);</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 语言与Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回顾知识点</title>
      <link href="/2020/01/11/%E6%A0%B8%E5%BF%83%E7%82%B9/"/>
      <url>/2020/01/11/%E6%A0%B8%E5%BF%83%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="回顾">          <a href="#回顾" class="heading-link"><i class="fas fa-link"></i></a><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2>      <p>1.事件的三要素</p><p>2.BOM核心【window对象】</p><p>xx元素.onxx事件=function（）｛….｝</p>        <h3 id="增-删-查-改">          <a href="#增-删-查-改" class="heading-link"><i class="fas fa-link"></i></a><a href="#增-删-查-改" class="headerlink" title="增    删    查    改"></a>增    删    查    改</h3>      <p>xx元素.addEventListener(’xx事件‘，function（）｛｝)</p><p>1.可以多次绑定</p><p>2.可以设定冒泡或捕获【基本用不到】两种形式的事件。<a id="more"></a></p><p>this绑定【形式】元素的本身</p><p>event是一个对象，存储了事件发生的那个时候的有些信息（属性）</p><p>e.target  e.type  keyCode【按键代码】 e.clientX/Y  e.pageX/Y</p><p>e.preventDefault()  a 表单</p><p>e.stopPropagation() 阻止冒泡？</p><p>事件的委托：</p><p>作用：</p><p>1.简化绑定行为，节省内存消耗</p><p>2.可以对页面初始不存在的元素去设定事件绑定</p>        <h3 id="遗留的问题：">          <a href="#遗留的问题：" class="heading-link"><i class="fas fa-link"></i></a><a href="#遗留的问题：" class="headerlink" title="遗留的问题："></a>遗留的问题：</h3>      <p>1.排他思想</p><p>2、window.alert() .confirm() .prompt()?</p><p>3.如何解决定时器会反复创建的问题？</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梦</title>
      <link href="/2020/01/11/%E6%A2%A6/"/>
      <url>/2020/01/11/%E6%A2%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="梦">          <a href="#梦" class="heading-link"><i class="fas fa-link"></i></a><a href="#梦" class="headerlink" title="梦"></a>梦</h2>      <p>​        做梦就是在保护我们的生活模式不被现实和常识的要求所威胁。也就是说，如果一个人在现实生活中不想用公知的常理去解决某个问题，那么他就会在梦中表现出来，引起某个让他坚持自己想法的感觉。梦主要是由隐喻和象征构成的。梦的目的在于自欺欺人，让我们自己陶醉其中。一般人在梦中的目标和白天的目标是一致的，就像人在梦中也在努力追求白天追求的优越感一样，梦是我们生命意义的另一种表达方式，同时也有利于我们生命意义的塑造和达成。</p> <a id="more"></a><p>​    每一个梦我们都是在自我陶醉、自我催眠。它的目的就是引起我们某种感觉，这中感觉能为我们清醒状态时候想要解决问题的方法提供支持。</p><p>隐喻是能让人充满想象的，但是必须注意：对于一个在生命意义方面已经偏差了的人来说，运用隐喻和符号来解决问题是一件很危险的事。对于梦的解释都是属于个人的，我们不可能用公式来解释符号和隐喻，因为梦是生活模式的产品。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 爱好心理学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何有效阅读一本书（四）</title>
      <link href="/2020/01/10/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2020/01/10/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="如何有效阅读一本书（四）">          <a href="#如何有效阅读一本书（四）" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何有效阅读一本书（四）" class="headerlink" title="如何有效阅读一本书（四）"></a>如何有效阅读一本书（四）</h1>              <h3 id="利用书签边读边写">          <a href="#利用书签边读边写" class="heading-link"><i class="fas fa-link"></i></a><a href="#利用书签边读边写" class="headerlink" title="利用书签边读边写"></a>利用书签边读边写</h3>      <p><strong>☞三枚书签</strong>—————-①通读书签②重读书签③标记书签</p><p><strong>☞巧用标记区分对象</strong></p><p>Eg：普通直线、波浪线、圆圈等。（注：笔记本上尽量少画线，避免重读的时候影响心情）ps：好像有点前后矛盾╮（╯＿╰）╭</p><p>ps：需要分清一开始写与后来补充的 </p><div class="table-container"><table><thead><tr><th><u>三项</u>信息 = 写读书笔记的日期 + 书名 + 作者名     【ps：想起读什么书、理解成度】</th></tr></thead><tbody><tr><td>↑（摘抄 + 评论）</td></tr></tbody></table></div><blockquote><p>引：“摘抄对自己来说很重要的文章” “写主观评论”</p></blockquote><p>摘抄：①促进、加深对书的记忆②加深理解【注：二次理解】<a id="more"></a></p><p>R：抄写是要尽量减少视点的移动，避免在视线转移的过程中逐渐忘记自己要写的内容。<del>人话：减少分神时间</del></p><blockquote><p>读过一本书以后，对书中内容感同身受固然让人心情愉悦，但这也代表这次读书没有给你带来新的东西。相反，如果一篇文章颠覆了你之前的想法，使你的认识发生动摇，在抄写和重读的过程中仍然会让人信服或感觉震撼，这中文章才是值得摘抄的。</p></blockquote><p><strong>☞最能代表这次读书体验的语句</strong>———中心句【ps：如何有效阅读一本书 <strong>:-D</strong>】</p><p>杂：自己当下的想法最重要。</p><p>ps：读书时获得的感想正是原创<u>思考</u>的源泉。【深与浅】</p><p><strong>⊙葱鲔火锅式</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BOM模型</title>
      <link href="/2020/01/09/BOM%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/01/09/BOM%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="BOM模型">          <a href="#BOM模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#BOM模型" class="headerlink" title="BOM模型"></a>BOM模型</h2>              <h3 id="全局变量-全局函数">          <a href="#全局变量-全局函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#全局变量-全局函数" class="headerlink" title="全局变量   全局函数"></a>全局变量   全局函数</h3>      <pre><code class="html">var v1 = 10是全局变量,则v1 === window.v1为真function fn1 = function(){...}是全局函数,则fn1 === window.fn1为真注:可以不使用window.前缀</code></pre><a id="more"></a><p>直接使用要删除这个元素的关系来删除该元素</p><p>toDeleteObj.parentNode.removeChild();</p>        <h3 id="使用一次性定时器">          <a href="#使用一次性定时器" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用一次性定时器" class="headerlink" title="使用一次性定时器"></a>使用一次性定时器</h3>      <p><strong>创建一次性定时器:</strong></p><p>var 名字=window.setTimeout(要调用的函数,等待的时间)</p><p>等待时间单位是毫秒</p><p>该时间后执行一次</p><p><strong>清除一次性定时器:</strong></p><p>window.clearTimeout(名字)</p>        <h3 id="使用重复性定时器">          <a href="#使用重复性定时器" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用重复性定时器" class="headerlink" title="使用重复性定时器"></a>使用重复性定时器</h3>      <p>var 名字 = window.setlnterval(要调用的函数,间隔的时间);</p><p>每间隔该时间,都会执行一次所指定的函数</p><p>window.clearlnterval(名字)</p><p>property  属性</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BOM模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件流</title>
      <link href="/2020/01/09/event%E6%96%B9%E6%B3%95/"/>
      <url>/2020/01/09/event%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="事件流">          <a href="#事件流" class="heading-link"><i class="fas fa-link"></i></a><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2>      <p>a标签的链接 【】   form标签的提交 【】 return false——–其它做法</p>        <h3 id="event事件">          <a href="#event事件" class="heading-link"><i class="fas fa-link"></i></a><a href="#event事件" class="headerlink" title="event事件:"></a>event事件:</h3>      <p>属性:target,type,clientX/Y,pageX/Y,keyCode</p><a id="more"></a><p>方法:preventDefault(),stopPropagation()</p>        <h3 id="事件绑定方式">          <a href="#事件绑定方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#事件绑定方式" class="headerlink" title="事件绑定方式:"></a><strong>事件绑定方式:</strong></h3>      <p> //只能绑定一次,而且只能是冒泡事件</p><p>  元素.onxx事件 = function(){}</p><p>//可以绑定多次,也可以绑定捕获或冒泡事件</p><p>元素.addEventListener(‘xx事件’,function(){}true/false)//true为捕获.false为冒泡</p>        <h3 id="阻止事件默认行为">          <a href="#阻止事件默认行为" class="heading-link"><i class="fas fa-link"></i></a><a href="#阻止事件默认行为" class="headerlink" title="阻止事件默认行为:"></a>阻止事件默认行为:</h3>      <p>​    e.preventDefault()</p>        <h3 id="阻止事件传播">          <a href="#阻止事件传播" class="heading-link"><i class="fas fa-link"></i></a><a href="#阻止事件传播" class="headerlink" title="阻止事件传播:"></a>阻止事件传播:</h3>      <p> e.stopPropagation()</p><p>某个节点.modeType</p><p>1.代表元素</p><p>2.代表书序</p><p>节点属性:</p><p>node.nodeType</p><p>​                  name[元素节点的nodename也就是元素的标签名,而且必然是大写]</p><p>Value/</p>        <h3 id="事件委托">          <a href="#事件委托" class="heading-link"><i class="fas fa-link"></i></a><a href="#事件委托" class="headerlink" title="事件委托:"></a>事件委托:</h3>      <p>event.target获取当前触发事件的对象</p><p>keyCode获取键盘码</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件处理</title>
      <link href="/2020/01/08/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
      <url>/2020/01/08/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="事件处理">          <a href="#事件处理" class="heading-link"><i class="fas fa-link"></i></a><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2>      <p>事件源：事件类型：事件处理函数：                                                                                                                                                                                                    事件三要素其实就是设定某个元素上发生了某个时间后要做什么事</p><p>事件绑定（事件注册）</p>        <h3 id="常用事件概览（on）">          <a href="#常用事件概览（on）" class="heading-link"><i class="fas fa-link"></i></a><a href="#常用事件概览（on）" class="headerlink" title="常用事件概览（on）"></a>常用事件概览（on）</h3>      <p><strong>鼠标事件：</strong></p><p>click，dblclick</p><p>mouseover：鼠标进入某个盒子范围的那个时刻</p><p>mouseout：离开</p><p>mousemove：鼠标移动事件，通常是一个持续时间。 <a id="more"></a></p><p>mouseenter：(盒子范围)跟over几乎一样，但是更好用</p><p> mouseleave： （离开盒子范围）out一样，</p><p><strong>键盘事件：</strong></p><p>keydown：按钮按下去的时刻发生</p><p>keyup：抬起</p><p>keypress：按键一次</p><p><strong>表单事件：</strong></p><p>submit：表单提交事件</p><p> change：表单项的数据被改变的时刻（光标离开后）</p><p>input：输入时刻</p><p>focus：获得焦点。。。</p><p>blur：失去焦点。。。（空字符串）</p><p><strong>其它事件：</strong></p><p>load：加载成功事件（网页加载）</p>        <h3 id="事件绑定">          <a href="#事件绑定" class="heading-link"><i class="fas fa-link"></i></a><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3>      <p><strong>标签属性绑定———过时，不推荐</strong></p><p>语法：&lt;div on事件=”xx函数();”&gt;…&lt;/div.&gt;（调用函数）</p><p><strong>移除方式:</strong></p><p>●xx元素.onxx事件=null</p><p>●直接在html中删除该事件绑定代码(ps:不过这就不是js的工作)</p><p> <strong>对象属性绑定———简洁、常用，满足绝大数使用</strong></p><p>☞xx元素.onxx事件 = 函数名； //函数名后不带括号</p><p>  <strong>移除方式:</strong></p><p>●xx元素.onxx事件=null</p><p>☞xx元素.onxx事件=function(){…}; //这里是匿名函数</p><p>（注：等号后面是一个函数名，;不是调用函数）</p><p><strong>对象方法绑定———更好的可控性</strong></p><p><strong>语法：</strong>xx元素.addEventListener(‘xx事件’,xx事件处理函数);</p><p>第2个参数是事件处理函数,可以是匿名函数,也可以是一个函数名</p><p><strong>对应删除:</strong></p><p>●xx元素.removeEventListenter(‘xx事件’,xx事件处理函数);</p><p>●==特别注意:绑定后如果=需要再移除,则使用同样的函数名,且第1参数也要求一样==</p>        <h3 id="函数中的this">          <a href="#函数中的this" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数中的this" class="headerlink" title="函数中的this"></a>函数中的this</h3>      <p><strong>提示：</strong>在对象属性绑定和通过对象方法绑定的事件处理函数中，都<strong>可以直接使用this关键词</strong>。但通过元素标签属性的形式绑定的事件处理函数中不可以直接使用。</p>        <h3 id="排他思想（特例）：">          <a href="#排他思想（特例）：" class="heading-link"><i class="fas fa-link"></i></a><a href="#排他思想（特例）：" class="headerlink" title="排他思想（特例）："></a><strong>排他思想（特例）：</strong></h3>      <p>排他思想的基本代码模式：</p><p>1， 设定若干同类元素相同表现</p><p>2， 设定当前某个特殊元素的特殊表现（通常都会需要用到 this )</p><pre><code class="html">/*先设定所有一致（所有都同样）*//*给当前设置特殊*/</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>伸缩布局</title>
      <link href="/2020/01/08/%E4%BC%B8%E7%BC%A9%E5%B8%83%E5%B1%80/"/>
      <url>/2020/01/08/%E4%BC%B8%E7%BC%A9%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="伸缩布局">          <a href="#伸缩布局" class="heading-link"><i class="fas fa-link"></i></a><a href="#伸缩布局" class="headerlink" title="伸缩布局"></a><strong>伸缩布局</strong></h2>      <p><strong>什么时候使用伸缩布局:</strong></p><p>1.如果在在网页中希望让元素一行显示,并且元素随着父元素的宽度改变<strong>布局方式不会受影响</strong></p><p>2.使用了伸缩布局以后,还可以使用浮动,定位,margin,padding</p><p>3.伸缩布局只是一个新的布局方式,不要把伸缩布局看的太重或者太难</p>        <h3 id="核心知识点">          <a href="#核心知识点" class="heading-link"><i class="fas fa-link"></i></a><a href="#核心知识点" class="headerlink" title="核心知识点"></a>核心知识点</h3>      <p>1.伸缩盒子设置</p><p>2.设置伸缩盒子主轴 <a id="more"></a></p><p>3.设置伸缩盒子主轴对齐方式</p><p>4.设置伸缩盒子侧轴对齐方式</p><p>5.设置伸缩盒子伸缩比例</p><p>6.less基本语法及使用</p>        <h3 id="伸缩布局两个步骤">          <a href="#伸缩布局两个步骤" class="heading-link"><i class="fas fa-link"></i></a><a href="#伸缩布局两个步骤" class="headerlink" title="伸缩布局两个步骤:"></a><strong>伸缩布局两个步骤:</strong></h3>      <p>​             <strong>●给父元素设置的属性</strong>  </p><pre><code class="css">display:flex;   /*设置为伸缩盒子(弹性盒子)*/ 注:一定给父级!!!一定给父级!!!一定给父级!!!</code></pre><pre><code class="css">justify-content/*设置元素在主轴对齐*/justify-content:flex- start;  /*默认*/justify-content:flex-end;     /*结束*/justify-concent:center;  /*居中*/justify-content:space-between;/* 两端对齐中间自适应 */justify-content: space-around; /* 环绕 */</code></pre><pre><code class="css">flex-direction: /*设置主轴的方向*/row(默认,水平)  | column(竖显示) | row-reverse(横-右到左) |   column-reverse(纵-右到左)</code></pre><pre><code class="css">align-items; /*设置元素相对侧轴对齐方式*/stretch(默认,拉伸效果)  | flex-start(起点对齐)  | flex-end(终点对齐) | center(中心)   |  baseline(第一行文字的基线对齐)</code></pre><pre><code class="css">flex-wrap:/*设置伸缩盒子中元素是否换行显示*/nowrap 默认不换行 |  wrap 换行</code></pre><pre><code class="css">align-content:/*当元素换行后的一种对齐方式*/stretch(默认)注:如果要设置align-content必须要保证元素是换行的</code></pre><p>​                                                  <strong>注:</strong>  flex-flow复合属性 ===flex- direction和flex- wrap</p><p> <strong>●给子元素设置的属性</strong></p><pre><code class="css">flex:/*设置元素占父元素剩余宽度的一个比例*/'也就是1份'注:    1.flex 属性是给子元素设置的    2.剩余宽度:如果父元素中固定宽度的盒子,那么flex所占的比例是父元素整个的宽度-固定宽度后的比例</code></pre><p>​    <strong>● 伸缩盒子中-子元素排序</strong></p><pre><code class="css">order:值;  /*设置元素排序*/特点:     1.值越大元素越靠后显示     2.在排序时候,完全不用修改html结构</code></pre>        <h3 id="伸缩盒子的特点">          <a href="#伸缩盒子的特点" class="heading-link"><i class="fas fa-link"></i></a><a href="#伸缩盒子的特点" class="headerlink" title="伸缩盒子的特点:"></a><strong>伸缩盒子的特点:</strong></h3>      <p>​         1.伸缩盒子中的所有元素都是一行显示的</p><p>​         2.解释为什么伸缩盒子中的元素默认会一行显示?</p><p>​                      ✖在伸缩盒子中元素都是按照<strong>主轴显示</strong>的</p><p>​                      ✖在伸缩盒子中有一条主轴,主轴的<strong>默认水平显示</strong>  </p><p>​         3.在伸缩盒子中还有一条轴,叫侧轴.(侧轴始终要垂直于主轴,侧轴的方向是随着儿主轴的方向发生改变的)</p><p>​          4.在伸缩盒子中,如果子元素的宽度超出父元素的宽度,那么元素也不会换行</p><p><strong>注:</strong>                                                                                                                                                                                                                                                                              在伸缩盒子中元素一行显示,与脱标没有任何关系</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 伸缩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何有效阅读一本书（三）</title>
      <link href="/2020/01/08/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6(%E4%B8%89)/"/>
      <url>/2020/01/08/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6(%E4%B8%89)/</url>
      
        <content type="html"><![CDATA[<h2 id="如何有效的阅读一本书-三">          <a href="#如何有效的阅读一本书-三" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何有效的阅读一本书-三" class="headerlink" title="如何有效的阅读一本书(三)"></a>如何有效的阅读一本书(三)</h2>      <p>1.从一句话开始                                   <del>ps：凡事一句话搞定？</del>     <strong>(^ ^)v</strong></p><p>2.对自己很重要的事情                       <del>ps：有很多先做哪一个</del>       <strong>:D</strong></p><div class="table-container"><table><thead><tr><th>读书的目的是用自己的方式学习，而不是模仿评论家的做法，学习、吸收对自己真正有用的智慧和语句才是最重要的。</th></tr></thead><tbody><tr><td><del>杂：如果别人的学习方式比你的要好，是否还要坚持自己的学习方式？一味的模仿固然不对，但要怎么’避免‘【模仿与学习】？</del>      <strong>——————————</strong>     <strong>注：学会变通</strong></td></tr></tbody></table></div><blockquote><p>“这不是语文考试，没必要去拼命思考笔者（作者）想要传达什么。只要关注相关注的内容就好了”<strong>———————-注：一般来说只要思想不滑坡，就不会想偏。</strong></p></blockquote> <a id="more"></a><p><u><strong>【杂：只留下应有的想法即可】</strong></u></p><p>千万不要为了坚持写读书笔记而走形式主义，不管采用什么方式，都要脚踏实地地写读书笔记，并真正理解书的内容。                                       ps：经历吗？对于不长出门的人来说，有些困难</p><p>巩固印象的<strong><u>笔记</u></strong> <strong>——–加深记忆</strong>          注：反复理解内容与修改想法</p><p>  R：读书是一项“对重要内容进行提炼的工序”      ps：大脑会反复加工这一重要的内容</p><p><strong>筛选程序：</strong></p><p>① 通过一边阅读一边把觉得有价值的呢一也折角</p><p>② 重读（ps：反复阅读）</p><p>③ 标记……</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 我的读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>练习案例</title>
      <link href="/2020/01/07/%E7%BB%83%E4%B9%A0%E6%A1%88%E4%BE%8B/"/>
      <url>/2020/01/07/%E7%BB%83%E4%B9%A0%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="节点关系获取元素">          <a href="#节点关系获取元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#节点关系获取元素" class="headerlink" title="节点关系获取元素"></a>节点关系获取元素</h3>      <p><strong>==演示==：</strong></p><p><strong>使用元素的一些关系属性获取元素。</strong></p><p><strong>准备的素材：一个有id的无序列表。通过children找出第2个li，然后据此演示使用其他一些关系以获取元素。</strong></p> <a id="more"></a><pre><code class="html">&lt;ul id="list"&gt;        &lt;li&gt;项目1&lt;/li&gt;        &lt;li&gt;项目2&lt;/li&gt;        &lt;li&gt;项目3&lt;/li&gt;        &lt;li&gt;项目4&lt;/li&gt;        &lt;li&gt;项目5&lt;/li&gt;    &lt;/ul&gt;&lt;script&gt;    var ul = document.getElementByid('list');    var li = document.getElementsByTagName('li');    var iu = li[0].parentNode;    var op = ul.children;    var ki = ul.firstElementChild;    var hi = ul.lastElementChild;    console.log(iu);    console.log(op);     console.log(ki);     console.log(hi);&lt;/script&gt;</code></pre>        <h3 id="根据特征信息获取元素">          <a href="#根据特征信息获取元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#根据特征信息获取元素" class="headerlink" title="根据特征信息获取元素"></a>根据特征信息获取元素</h3>      <p><strong>==演示==：</strong></p><p>​    <strong>使用get系列方法和query系列方法获取元素。</strong></p><p>​    <strong>准备的素材：一个设定了id和class的div。</strong></p><pre><code class="html"> &lt;div id="box1" class="msg"&gt;sha&lt;/div&gt;    &lt;script&gt;        var box1 = document.getElementById('box1');        var msg = document.getElementsByClassName('.msg');        console.log('msg')    &lt;/script&gt;</code></pre>        <h3 id="开关灯案例">          <a href="#开关灯案例" class="heading-link"><i class="fas fa-link"></i></a><a href="#开关灯案例" class="headerlink" title="开关灯案例"></a>开关灯案例</h3>      <p> <strong>==案例3（介绍开关思想）==：</strong> </p><p><strong>网页上有一按钮，点击按钮，使整个页面能够在“关灯/开灯”之间切换。</strong></p><p><strong>所谓关灯/开灯，就是让网页的整体背景为黑色和白色。</strong></p><pre><code class="html"> &lt;input type="button" value="开关" id="op"&gt;    &lt;script&gt;        var body = document.body;        var yi = true;        var op = document.querySelector('#op');        op.onclick = function () {            if (yi == true) {                body.style.backgroundColor = 'black';                op.value = '关灯';                yi = false;            } else {                body.style.backgroundColor = 'white';                op.value = '开灯';                yi = true;            }        }    &lt;/script&gt;</code></pre>        <h3 id="添加元素案例（一）">          <a href="#添加元素案例（一）" class="heading-link"><i class="fas fa-link"></i></a><a href="#添加元素案例（一）" class="headerlink" title="添加元素案例（一）"></a>添加元素案例（一）</h3>      <pre><code class="html"> &lt;button id="ll"&gt;点一下&lt;/button&gt;    &lt;ul id="po"&gt;&lt;/ul&gt;    &lt;script&gt;        var bon = document.querySelector('#ll');        var ul = document.querySelector('#po');        // var bon = document.getElementsByTagName('button');        // var ul = document.getElementsByTagName('ul');这个不显示        bon.onclick = function () {            var ki = document.createElement('li');            ul.appendChild(ki);        }    &lt;/script&gt;</code></pre>        <h3 id="添加元素案例（二）">          <a href="#添加元素案例（二）" class="heading-link"><i class="fas fa-link"></i></a><a href="#添加元素案例（二）" class="headerlink" title="添加元素案例（二）"></a>添加元素案例（二）</h3>      <p><strong>在一个无序列表中实现如下需求：</strong></p><p><strong>1，点击按钮1，创建一个div放入第一个li中，</strong></p><p><strong>2，点击按钮2，克隆第一个li，并放到该列表的倒数第2个的位置（即最后一个的前面），,</strong></p><p><strong>3，点击按钮3，将最后一个li替换为一个新创建的li。</strong></p><pre><code class="html">&lt;body&gt;    &lt;button id="btn1"&gt;添加一个div到第1个li&lt;/button&gt;    &lt;button id="btn2"&gt;克隆第1个li并放入倒数第2个位置&lt;/button&gt;    &lt;button id="btn3"&gt;替换最后1个li&lt;/button&gt;    &lt;button id="btn4"&gt;删除最后一个li&lt;/button&gt;    &lt;ul&gt;        &lt;li&gt;列表项1&lt;/li&gt;        &lt;li&gt;列表项2&lt;/li&gt;        &lt;li&gt;列表项3&lt;/li&gt;        &lt;li&gt;列表项4&lt;/li&gt;    &lt;/ul&gt;    &lt;script&gt;        var btn1 = document.querySelector('#btn1');        var ul = document.querySelector('ul');        btn1.onclick = function () {            var div = document.createElement('div');            var fist = ul.children[0];            fist.appendChild(div);        }        var btn2 = document.querySelector('#btn2');        btn2.onclick = function () {            var li = ul.children[0].cloneNode(true);            var kj = ul.lastElementChild;            ul.insertBefore(li, kj)        }        var btn3 = document.querySelector('#btn3');        btn3.onclick = function () {            var li = document.createElement('li')            var kl = ul.lastElementChild;            ul.replaceChild(li, kl)        }        var btn4 = document.querySelector('#btn4')        btn4.onclick = function () {            // var yi =ul.children[3];            var li = ul.lastElementChild;            ul.removeChild(li);        }    &lt;/script&gt;</code></pre>        <h3 id="修改原生的HTML属性案例（一）">          <a href="#修改原生的HTML属性案例（一）" class="heading-link"><i class="fas fa-link"></i></a><a href="#修改原生的HTML属性案例（一）" class="headerlink" title="修改原生的HTML属性案例（一）"></a>修改原生的HTML属性案例（一）</h3>      <p> <strong>==案例1==：</strong></p><p><strong>页面上有两个按钮，一张图片。每点击一次按钮1，使图片变大20像素，每点击一次按钮2，使图片变小20像素。</strong></p><pre><code class="html">&lt;button id="btn1"&gt;放大&lt;/button&gt;    &lt;button id="btn2"&gt;缩小&lt;/button&gt;    &lt;br&gt;    &lt;img src="gl.jpg" alt="" width="100"&gt;    &lt;script&gt;        var btn1 = document.querySelector('#btn1');        var img = document.querySelector('img');        var fn = img.width;        btn1.onclick = function () {            fn += 20;            img.width = fn;        }        var btn2 = document.querySelector('#btn2');        btn2.onclick = function () {            fn -= 20;            img.width = fn;        }    &lt;/script&gt;</code></pre>        <h3 id="修改原生的HTML属性案例（二）">          <a href="#修改原生的HTML属性案例（二）" class="heading-link"><i class="fas fa-link"></i></a><a href="#修改原生的HTML属性案例（二）" class="headerlink" title="修改原生的HTML属性案例（二）"></a>修改原生的HTML属性案例（二）</h3>      <p><strong>==案例2==：</strong></p><p><strong>购买数量的增减操作</strong></p><pre><code class="html">&lt;body&gt;    &lt;style&gt;        div {            width: 80px;        }        input[type="text"] {            width: 50px;            height: 44px;            outline: none;            border: 1px solid #ccc;            text-align: center;        }        input[type="button"] {            height: 24px;            width: 22px;        }        input {            float: left;        }    &lt;/style&gt;    &lt;div&gt;        &lt;input type="text" id="total" value="1" readonly&gt;        &lt;input type="button" value="+" id="add"&gt;        &lt;input type="button" value="-" id="reduce" disabled&gt;    &lt;/div&gt;    &lt;script&gt;        var ddf = document.querySelector('#total');        var add = document.querySelector('#add');        var naa = document.querySelector('#reduce');        add.onclick = function () {            var ui = ddf.value;            ui++;            ddf.value = ui;            naa.disabled = false;        }        naa.onclick = function () {            var ul = ddf.value;            ul--;            if (ul &lt;= 0) {                ul = 1;                naa.disabled = true;            }            ddf.value = ul;        }    &lt;/script&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识点（二）</title>
      <link href="/2020/01/06/%E7%9F%A5%E8%AF%86%E7%82%B92/"/>
      <url>/2020/01/06/%E7%9F%A5%E8%AF%86%E7%82%B92/</url>
      
        <content type="html"><![CDATA[<h2 id="知识点">          <a href="#知识点" class="heading-link"><i class="fas fa-link"></i></a><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2>      <p>​          1.display:none *与visitibility:hidden  前者不保留位置,后者保留位置</p><p>​          2.额外标签法 overflow  伪元素法</p><p>​          3.css3盒子模型border-box中,盒子的width包含了conter+border+padding(实际宽高)</p><p>​         4.vertical-align:middle            vertical-align:top       vertical-align:bottom  </p><ol start="5"><li>css三种引入方式:行内式,内嵌式外联时</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点（二） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何有效阅读一本书（二）</title>
      <link href="/2020/01/06/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6(%E4%BA%8C)/"/>
      <url>/2020/01/06/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h2 id="如何阅读一本有效的书-二">          <a href="#如何阅读一本有效的书-二" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何阅读一本有效的书-二" class="headerlink" title="如何阅读一本有效的书(二)"></a>如何阅读一本有效的书(二)</h2>      <p><strong>1.熟读书评</strong>                   <strong>ps：书评两级分化严重该怎么解决？</strong></p><p><strong>2.坚持做笔记</strong>                   <del>ps:大多数时间，都在走神与胡思乱想  <strong>:）</strong></del></p><p><strong>作用:  图书都是有重点的,没有必要从头到尾详读.重要的是不管篇幅多少,都要下点功夫让自己对读过的书有印象.即使只记下这本书的作者、书名,阅读时的情景或是做些摘抄都好,要坚持写读书笔记,这是最有效的读书方法.</strong></p><p><strong>ps:不管怎么说还是坚持、用心好点或正确的对待写读书笔记这件事. R:读书笔记改变读书方法可以理解为不要漫无目的的读书.</strong>  <a id="more"></a></p><blockquote><p><strong>引:”为了写出精炼而深刻的读书笔记,你应该在读完一本书以后认真回想需要摘抄那一页哪一行,思考怎样撰写读书笔记,然后严格的筛选需要摘抄的内容,尽量提炼自己的感想,争取用最短的语句表达深刻的含义”    (注:以思想输出为前提)</strong></p></blockquote><p><strong>ps:想法很重要,有什么一闪而过想法最好写下来.避免被忘掉,从而错过有趣(重要)的想法.</strong></p><div class="table-container"><table><thead><tr><th><strong>杂:对于书中所说’速度’与’跳读’,我到是并不建议’跳读’</strong></th></tr></thead><tbody><tr><td>一是会错过有趣的故事、人物关系  二是会记忆混乱，看的一头雾水.</td></tr></tbody></table></div><p><strong>K:要注意读书的重心,要放在你读书为了什么或者为什么要读书.而不是单单是读过就好或者为了应付什么</strong></p><p><strong>杂:还是有必要说一下不要钻牛角尖,不要死读书,把握好时间与节奏.</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 我的读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML基础（一）</title>
      <link href="/2020/01/06/HTML%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
      <url>/2020/01/06/HTML%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h2 id="第一天">          <a href="#第一天" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2>      <p>1.<strong>ctrl+s</strong> 保存                         Lorem 乱数假文</p><p>2.英文下的 <strong>！+Tab</strong>       <strong>注</strong>：（vs code）</p><p>3.字符集—–避免乱码(<strong>utf- 8</strong>) <strong>注</strong>:不区分大小写</p><p>4.语言的种类—–避免编译器乱码    <strong>eg: en 、zh-CN</strong>    </p><p>5.关于h1  网页只有一个标题</p><a id="more"></a><div class="table-container"><table><thead><tr><th>小图标图片    ——      b                     i                                        u                   s</th></tr></thead><tbody><tr><td><strong>段落与文字  ——-     strong  加粗   em    倾斜    ins    下划线   del 删除线</strong></td></tr></tbody></table></div><p><del>文本格式化</del>                     </p><p>( 注:vs code 需要下载汉化插件与Open In Default Browser)</p><div class="table-container"><table><thead><tr><th>相对路径: ./同一级  /下一级 ../上一级</th></tr></thead><tbody><tr><td><strong>绝对路径: 盘符与网页图片</strong></td></tr></tbody></table></div><p><strong>a href:</strong>链接可以下载文件  放入链接    图片等等   <strong>[注:下载需要打包(压缩文件)]</strong> </p><p>加入空链接   <strong>#</strong> </p><p>锚点定位 ——-#”类id”     <strong>eg:”#ygsts”</strong></p><p>注释快捷键    ctrl + /</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML(一) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>响应式布局</title>
      <link href="/2020/01/06/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/"/>
      <url>/2020/01/06/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="响应式布局写对位置">          <a href="#响应式布局写对位置" class="heading-link"><i class="fas fa-link"></i></a><a href="#响应式布局写对位置" class="headerlink" title="响应式布局写对位置"></a><strong>响应式布局</strong>写对位置</h3>      <p>1.(同一个网页在不同设备中[布局]呈现的效果)</p><p><strong>核心知识</strong></p><p>◎媒体查询</p><pre><code>    媒体查询            liagn-height 可以不用加px    (一倍)</code></pre><pre><code class="css">@media only screen and (width:**/*不加分号*/) {   /* 加空格*/     div {           宽           高         背景颜色    }}</code></pre><p>1.媒体查询就是响应式布局实现的原理</p><p>2.总结:可以让css代码在满足某些条件的情况下才去执行 <a id="more"></a></p><p>◎boostrap框架</p><p>◎栅格系统</p><p>注:一旦涉及行内元素都需要转化为块元素</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 媒体查询 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流式布局</title>
      <link href="/2020/01/06/%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/06/%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="流式布局">          <a href="#流式布局" class="heading-link"><i class="fas fa-link"></i></a><a href="#流式布局" class="headerlink" title="流式布局"></a><strong>流式布局</strong></h3>      <p>1.ppi 像素密度(越高画质越好,相反)—–没用[设备像素]</p><p>2.dpr物理像素比(具体不能改变的比例关系–作用–适配)   [硬件]                  </p>        <h2 id="视口-viewport">          <a href="#视口-viewport" class="heading-link"><i class="fas fa-link"></i></a><a href="#视口-viewport" class="headerlink" title="视口(viewport)"></a>视口(viewport)</h2>      <p>1.禁止——水平滚动—页面缩放</p><p>2.视口—–pc[浏览器的大小]—-移动[移动设备的大小]</p>        <h3 id="视口的设置">          <a href="#视口的设置" class="heading-link"><i class="fas fa-link"></i></a><a href="#视口的设置" class="headerlink" title="视口的设置"></a><strong>视口的设置</strong></h3>      <pre><code class="css">&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;                      移动设备宽 ←↑         ↑→ 忘了</code></pre><p> <strong>注:</strong> 左右固定—中自适应     <strong>注:</strong>精灵图—-向上向左        <a id="more"></a></p><p><strong>注:</strong>转元素转块元素、行内元素</p><p>​             ♦行内块元素是一个非标准的元素      </p><p>​             ♦  行内块元素默认都会找基线对齐—(底部多3像素空白)</p><p>​             ♦’’图片是行内块元素转化为块元素  (加浮动=转化块=)—-[清除浮动]’ ‘</p><pre><code>             ∮  盒子之间用padding值撑开,切记不要用margin值</code></pre>        <h3 id="多行文字显示省略号">          <a href="#多行文字显示省略号" class="heading-link"><i class="fas fa-link"></i></a><a href="#多行文字显示省略号" class="headerlink" title="多行文字显示省略号"></a><strong>多行文字显示省略号</strong></h3>      <pre><code class="css">              /* 实现多行文字溢出显示省略号 */              overflow: hidden;             /* 文字溢出显示省略号：单行文字 */              text-overflow: ellipsis;             /* 辅助属性：兼容性 */             -webkit-line-clamp: 2;             /* 文字就要垂直显示 */             -webkit-box-orient: vertical;             /* 还需要设置一个弹性盒子 */             display: -webkit-box;</code></pre>        <h3 id="防止汉字自动换行-默认">          <a href="#防止汉字自动换行-默认" class="heading-link"><i class="fas fa-link"></i></a><a href="#防止汉字自动换行-默认" class="headerlink" title="防止汉字自动换行(默认)"></a><strong>防止汉字自动换行</strong>(默认)</h3>      <pre><code class="css">/*解决让文字不在特殊符号(空格,特殊符号)位置处换行*/  word-break:break-all;</code></pre><p>​         </p>        <h3 id="网页的步骤">          <a href="#网页的步骤" class="heading-link"><i class="fas fa-link"></i></a><a href="#网页的步骤" class="headerlink" title="网页的步骤"></a><strong>网页的步骤</strong></h3>      <ol><li><p>页面样式初始化</p></li><li><p>任何的一个项目都要单独的在一个文件夹中</p></li><li><p>任何文件的命名都不能出现汉字</p>        <h3 id="html的步骤">          <a href="#html的步骤" class="heading-link"><i class="fas fa-link"></i></a><a href="#html的步骤" class="headerlink" title="html的步骤"></a><strong>html的步骤</strong></h3>      <p>1.一般情况下,在网页中先设置一个大盒子</p><p>​     ▶<u>如果是一个最外层的大盒子,设置宽度100%( 重要)</u></p><p>​      ▶如果盒子的高度可以直接测量出来,可以设置高度,反之让内容撑开</p><p>2.在最外层大盒子中划分其它盒子</p><p>​       ▶搜索盒子(宽度与设备一宽,要设置高度,设置背景颜色,固定定位盒子,以及内[三个盒子])</p><p>​         ▶搜索盒子中要实现     [两端固定大小,中间[设置padding值]自适应效果]</p><p>{为了防止padding撑大盒子设置! !初始化(最好用一个写一个,以防..以防..[<del>ps：想不起来用什么词了…</del>])’}</p>        <h3 id="注-初始化">          <a href="#注-初始化" class="heading-link"><i class="fas fa-link"></i></a><a href="#注-初始化" class="headerlink" title="注:                                                               [初始化]"></a>注:                                                               [初始化]</h3>      <pre><code class="css">/*实际开发不写*/*{   padding:0;   margin:0;}/*真确写法*/body,p,h1,h2,h3,h4,h5,h6,ul,ol,dl,dd{    margin:0;    padding:0;    list-style:none;    font-size:14px;    font-familt:'宋体';}a{    /*清除下划线*/    text-decoration:none;}img,input{      vertical-align:middle;      /*去掉边框*/    border:0;    /*轮廓线*/    outline:none;    padding:0;}/*清除浮动*/.clearfix::after{    content:"";    display:block;    height:0;    visibility:hidden;    clear:both;}.clearfix{    *zoom:1;}</code></pre><p> <strong>例外 问题:</strong></p><p>♣背景图片:当页面中的标签某个图标效果,或者图片只是一个衬托效果(给高宽)</p><p>♣img图片:图片角色很重要[广告,商品]</p><p><strong>重要:</strong>  </p><p>选择器层级不要太高,类选择器不要超过3个[权限会很高]</p><p><strong>扩展知识点:</strong></p><p>♠定位 ——♪当一个元素加了定位有层级关系(后来居上原则)[z-index:*;]</p><p>​        ♪定位脱标元素盒子居中</p><pre><code class="css">transform:translate(-50%);[后期会讲,先记住]</code></pre><p>♠盒子模型 ——</p><pre><code class="css">      ♪max-width---最大宽度    ♪min-width-----最小宽度</code></pre><p>♠其它内部属性</p><pre><code class="css">div{    position:absolute;    left:0;    top:0;    width:**px;    height:**px;    font-size:**px;        /*字的大小颜色(背景)对齐方式*/    text-align:****;}</code></pre><p>底部的固定定位:需要加padding-bottom撑开</p><p>名:没有固定的宽或高</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动回顾</title>
      <link href="/2020/01/06/%E7%A7%BB%E5%8A%A8%E5%9B%9E%E9%A1%BE/"/>
      <url>/2020/01/06/%E7%A7%BB%E5%8A%A8%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="移动回顾">          <a href="#移动回顾" class="heading-link"><i class="fas fa-link"></i></a><a href="#移动回顾" class="headerlink" title="移动回顾"></a><strong>移动回顾</strong></h2>      <p> 1.流式布局</p><p>2.伸缩布局———–[修改主轴的方向,设置元素在主轴方向的对齐,元素在侧轴的对齐方式]</p><p>3.响应式布局———–[解决了同一个网页在不同设备中布局显示效果不同]</p><p>核心知识点———-媒体查询</p>        <h3 id="页面适配">          <a href="#页面适配" class="heading-link"><i class="fas fa-link"></i></a><a href="#页面适配" class="headerlink" title="页面适配"></a>页面适配</h3>      <p><strong>rem适配</strong>  ——-相对html中的文字大小 <a id="more"></a></p><p>1.要设置html中文字的大小 = 设备的宽度/缩放的倍数</p><p>2.测量元素转化为  rem = 当前元素测量的大小rem / (UI图宽度/缩放的倍数)</p><p>备注:</p><p>640px UI图一般  缩放 20倍</p><p>750px UI 图一般缩放 25倍</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改元素内容和属性</title>
      <link href="/2020/01/06/%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0/"/>
      <url>/2020/01/06/%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="修改元素内容和属性">          <a href="#修改元素内容和属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#修改元素内容和属性" class="headerlink" title="修改元素内容和属性"></a>修改元素内容和属性</h2>              <h3 id="原生html属性操作：">          <a href="#原生html属性操作：" class="heading-link"><i class="fas fa-link"></i></a><a href="#原生html属性操作：" class="headerlink" title="原生html属性操作："></a>原生html属性操作：</h3>      <p>取值：console.log（xx元素.src）</p><p>赋值：xx元素.alt = ‘abc’;    js不带单位</p>        <h3 id="自定义属性">          <a href="#自定义属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3>      <p><strong>设置一个属性的值</strong></p><p>​    xx元素.setAttribite(‘属性名’，’属性名’)   <a id="more"></a></p><p><strong>获取给定属性的值</strong></p><p>​    xx元素.getAttribute(‘属性名’)</p><p><strong>移除一个属性</strong></p><p>​    xx元素.removeAttribute(‘属性名’)</p>        <h3 id="html特殊属性">          <a href="#html特殊属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#html特殊属性" class="headerlink" title="html特殊属性"></a><strong>html特殊属性</strong></h3>      <p><strong>布尔值</strong></p><p>1.checked属性  用于单选或多选    true（选中） false</p><p>2.selected属性 下拉框</p><p>3.disable属性 禁用    </p>        <h3 id="容器盒子的内容属性">          <a href="#容器盒子的内容属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#容器盒子的内容属性" class="headerlink" title="容器盒子的内容属性"></a>容器盒子的内容属性</h3>      <p> 1.innerHTML  2.innerText</p>        <h3 id="style操作样式属性">          <a href="#style操作样式属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#style操作样式属性" class="headerlink" title="style操作样式属性"></a>style操作样式属性</h3>      <p>局限性：</p><p>样式值都是字符串类型的值</p><p>通过style读取和设置的都只能是行内样式。</p><p>样式属性名的写法跟css有所出入，必须使用“小驼峰”命名法，类似这样：xxxYyyZzz</p>        <h3 id="className操作属性">          <a href="#className操作属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#className操作属性" class="headerlink" title="className操作属性"></a>className操作属性</h3>      <p>js读取———–var v1 = xx元素.className</p><p>js中设置 ———- xx元素.—–=‘类名’</p><p><strong>注：</strong>如果元素有多个类名，则用空格隔开进行赋值</p>        <h3 id="classList-操作class属性">          <a href="#classList-操作class属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#classList-操作class属性" class="headerlink" title="classList 操作class属性"></a>classList 操作class属性</h3>      <p>1.添加一个类（class）：</p><p>xx元素.classList.add（‘类名’）</p><p>2.移除一个类（class）：</p><p>xx元素.classList.remove( ‘类名’ )</p><p>3.切换一个类（class）：</p><p>xx元素.classList.toggle( ‘类名’ )</p><p>注： 切换的意思是： 有就移除，没有就添加。</p>        <h4 id="通过className来操作类，和通过classList来操作类，有什么区别？">          <a href="#通过className来操作类，和通过classList来操作类，有什么区别？" class="heading-link"><i class="fas fa-link"></i></a><a href="#通过className来操作类，和通过classList来操作类，有什么区别？" class="headerlink" title="通过className来操作类，和通过classList来操作类，有什么区别？"></a>通过className来操作类，和通过classList来操作类，有什么区别？</h4>      <p>1.className设置的类，是会完整覆盖一个元素的calss属性的值</p><p>2.classList.add（）设置的类，会保留原来的class，并且加上新的这个</p>        <h3 id="获取非行内样式的值">          <a href="#获取非行内样式的值" class="heading-link"><i class="fas fa-link"></i></a><a href="#获取非行内样式的值" class="headerlink" title="获取非行内样式的值"></a>获取非行内样式的值</h3>      <p>1.使用xx元素.style.样式名 只能获取行内样式的值</p><p>2.getcomputedstyle（xx元素）可以获取到一个元素的所有style样式，结果是一个对象 </p><p> var style = getcomputedstyle（xx元素）【兼容性】</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> api（二） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebPAI案例(一)</title>
      <link href="/2020/01/06/WebAPI%E6%A1%88%E4%BE%8B/"/>
      <url>/2020/01/06/WebAPI%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="WebPAI案例-一">          <a href="#WebPAI案例-一" class="heading-link"><i class="fas fa-link"></i></a><a href="#WebPAI案例-一" class="headerlink" title="WebPAI案例(一)"></a>WebPAI案例(一)</h2>              <h3 id="放大与缩小案例">          <a href="#放大与缩小案例" class="heading-link"><i class="fas fa-link"></i></a><a href="#放大与缩小案例" class="headerlink" title="放大与缩小案例"></a>放大与缩小案例</h3>      <pre><code class="html">&lt;button id='jkl'&gt;放大&lt;/button&gt;&lt;button id='kjl'&gt;缩小&lt;/button&gt;&lt;br&gt;&lt;img src="gl.jpg" alt="" width="100"&gt;&lt;script&gt;    var img = document.querySelector('img');    var kids = img.width;    var jkl = document.querySelector('#jkl');    var kjl = document.querySekector('#kjl');    jkl.onclick = function(){        kids += 20；        img.width = kids；    }    kjl.onclick = function（）｛        kids -= 20；        img.width = kids；    ｝&lt;/script&gt;</code></pre> <a id="more"></a>        <h3 id="特殊属性的运用案例">          <a href="#特殊属性的运用案例" class="heading-link"><i class="fas fa-link"></i></a><a href="#特殊属性的运用案例" class="headerlink" title="特殊属性的运用案例"></a>特殊属性的运用案例</h3>      <pre><code class="html">加与减&lt;style&gt;        div {            width: 80px;        }        input[type="text"] {            width: 50px;            height: 44px;            outline: none;            border:1px solid #ccc;            text-align: center;        }        input[type="button"] {            height: 24px;            width: 22px;        }        input {            float: left;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        &lt;input type="text" id="total" value="1" readonly&gt;        &lt;input type="button" value="+" id="add"&gt;        &lt;input type="button" value="-" id="reduce" &gt;        &lt;script&gt;            var total = document.querySelector('#total')            var add = document.querySelector('#add')            var reduce = document.querySelector('#reduce')            add.onclick = function(){                // 获取到输入框中现有的值                var v1 = total.value;                v1++;                // 在将该变化了值赋值回输入框                total.value = v1;                // 加上去之后，值至少已经是2 了，所以，“-”按钮要重新设置为可用状态：                reduce.disabled = false;            }            reduce.onclick = function(){                // 获取到输入框中现有的值                var v1 = total.value;                v1--;                if( v1 &lt;= 0) {                    v1 = 1;                    // 此时，还需要去禁用“-”这个按钮                    // reduce.disable = "disabled";// 发现这种写法无效！！！                    reduce.disabled = true;                }                // 在将该变化了值赋值回输入框                total.value = v1;            }        &lt;/script&gt;    &lt;/div&gt;</code></pre>        <h3 id="开关灯案例（开关思想）">          <a href="#开关灯案例（开关思想）" class="heading-link"><i class="fas fa-link"></i></a><a href="#开关灯案例（开关思想）" class="headerlink" title="开关灯案例（开关思想）"></a>开关灯案例（开关思想）</h3>      <pre><code class="html"> 注：如何获取body元素（标签）？|document.body| &lt;input type="button" value="关灯" id="kids"&gt;&lt;script&gt;          var kids = document.quertSelector('#kids');         var kid = true;    kids.onlick = function () {        if(kid == true){              kids.value = '开灯'；               kid = true；            var body = document.body;          body.style.backgroundColor = 'black';        }else{             kids.value = '关灯'；               kid = false；             var body = document.body;          body.style.backgroundColor = 'while';        }    }&lt;/script&gt;</code></pre>        <h3 id="批量删除案例">          <a href="#批量删除案例" class="heading-link"><i class="fas fa-link"></i></a><a href="#批量删除案例" class="headerlink" title="批量删除案例"></a>批量删除案例</h3>      <pre><code class="html"> &lt;input type="button" id="btn1" disabled value="批量删除"&gt;    &lt;table border="1" cellspacing="0" id="table1" width="200"&gt;        &lt;thead&gt;            &lt;tr&gt;                &lt;th align="left"&gt;                    &lt;input type="checkbox" id="selectAllBtn"&gt;全选                &lt;/th&gt;                &lt;th&gt;标题&lt;/th&gt;            &lt;/tr&gt;        &lt;/thead&gt;        &lt;tbody&gt;            &lt;tr&gt;                &lt;td&gt;&lt;input type="checkbox"&gt;&lt;/td&gt;                &lt;td&gt;标题啦啦啦1&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;&lt;input type="checkbox"&gt;&lt;/td&gt;                &lt;td&gt;标题啦啦啦2&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;&lt;input type="checkbox"&gt;&lt;/td&gt;                &lt;td&gt;标题啦啦啦3&lt;/td&gt;            &lt;/tr&gt;        &lt;/tbody&gt;        &lt;script&gt;            var kids = document.querySelector('#btn1');            var kid = document.querySelector('#selectAllBtn');            var lii = document.querySelectorAll('#table1 tbody input');            kid.onclick = function () {                var mnu = kid.checked;                for (var i = 0; i &lt; lii.lenkgth; i++) {                    lii[i].checked = mnu;                }                btn1.disabled = !mnu;            }        &lt;/script&gt;</code></pre>        <h3 id="innerHtml和-innerText复制的区别【经典案例】">          <a href="#innerHtml和-innerText复制的区别【经典案例】" class="heading-link"><i class="fas fa-link"></i></a><a href="#innerHtml和-innerText复制的区别【经典案例】" class="headerlink" title="innerHtml和 innerText复制的区别【经典案例】"></a>innerHtml和 innerText复制的区别【经典案例】</h3>      <pre><code class="html">&lt;button id="btn1"&gt;复制html&lt;/button&gt;    &lt;button id="btn2"&gt;复制text&lt;/button&gt;    &lt;div id="box1"&gt;        &lt;ul &gt;            &lt;li&gt;项目1&lt;/li&gt;            &lt;li&gt;项目2&lt;/li&gt;            &lt;li&gt;项目3&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;div id="box2"&gt;&lt;/div&gt;        &lt;script&gt;        var btn1 = document.querySelector('#btn1');        var btn2 = document.querySelector('#btn2');        var box1 = document.querySelector('#box1');        var box2 = document.querySelector('#box2');        btn1.onclick = function(){            var str = box1.innerHTML;            console.log(str);            box2.innerHTML = str;        }        btn2.onclick = function(){            var str = box1.innerText;            console.log(str);            box2.innerText = str;        }    &lt;/script&gt;</code></pre><p><strong>对比innerHTML和createElement()创建元素的效率:</strong></p><pre><code class="html">&lt;button id="btn1"&gt;使用innerHTML&lt;/button&gt;    &lt;button id="btn2"&gt;使用createElement&lt;/button&gt;    &lt;ul id="list"&gt;&lt;/ul&gt;    &lt;script&gt;        var btn1 = document.querySelector('#btn1')        var btn2 = document.querySelector('#btn2')        var list = document.querySelector('#list')        btn1.onclick = function(){            // 先将ul中的所有内容（元素）清掉            list.innerHTML = '';            var str = ''; // 这个变量用于存储 html 代码            var start = new Date();    // 开始时间            // 意图放入1000个li标签到ul中            for(var i = 0; i &lt; 1000; i++) {                str += "&lt;li&gt;" + Math.random() + "&lt;/li&gt;";                list.innerHTML = str;            }            var end = new Date();    // 结束事件            console.log('耗时：' + (end - start));        }        btn2.onclick = function(){            // 先将ul中的所有内容（元素）清掉            list.innerHTML = '';            var start = new Date();    // 开始时间            // 意图放入1000个li标签到ul中            for(var i = 0; i &lt; 1000; i++) {                var li = document.createElement('li');                li.innerText = Math.random();                list.appendChild( li );            }            var end = new Date();    // 结束事件            console.log('耗时：' + (end - start));        }    &lt;/script&gt;</code></pre>        <h3 id="打折案例">          <a href="#打折案例" class="heading-link"><i class="fas fa-link"></i></a><a href="#打折案例" class="headerlink" title="打折案例"></a>打折案例</h3>      <pre><code class="html">&lt;button id="btn1"&gt;打8折！&lt;/button&gt;    &lt;ul id="list1"&gt;        &lt;li oldPrice="222"&gt;&lt;span&gt;产品1&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/li&gt;        &lt;li oldPrice="414"&gt;&lt;span&gt;产品2&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/li&gt;        &lt;li oldPrice="244"&gt;&lt;span&gt;产品3&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/li&gt;        &lt;li oldPrice="513"&gt;&lt;span&gt;产品4&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/li&gt;        &lt;li oldPrice="144"&gt;&lt;span&gt;产品5&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/li&gt;    &lt;/ul&gt;&lt;script&gt;       var btn1 = document.querySelector('#btn1');    var ul= document.querySelector('#list1');      var lii = ul.children;   //获取ul里面的li       //1.初始显示原价    for(var i = 0;i &lt; lii.length;i++){                 var oldPrice = list[i].getAttribute('oldPrice');            // 当前 li 中的第2个span            var span2 = list[i].children[1];            span2.innerHTML = "，原价 &lt;del&gt;¥" + oldPrice + "&lt;/del&gt;";        }    btn1.onclick = function(){            for(var i = 0; i &lt; list.length; i++){                // 先取出当前li的oldPrice这个自定义属性的值（原价）                var oldPrice = list[i].getAttribute('oldPrice');                // 当前 li 中的第3个span                var span3 = list[i].children[2];                span3.innerHTML = "，折后价 &lt;del&gt;¥" + (oldPrice*0.8).toFixed(2) + "&lt;/del&gt;";            }        }    }&lt;/script&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 案例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js基础(argment)</title>
      <link href="/2020/01/04/js%E5%9F%BA%E7%A1%80%E4%B8%80/"/>
      <url>/2020/01/04/js%E5%9F%BA%E7%A1%80%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p><strong>1.argment:</strong>在函数中获取参数的信息———-[个数、值]  </p><p>(注:无法确定用argment,明确用形参(ps:缩写)      ps: 本质上是个函数  </p><div class="table-container"><table><thead><tr><th>*<em>全局变量: *</em></th><th><strong>局部变量:</strong></th><th><strong>作用域链</strong></th></tr></thead><tbody><tr><td>可以在任何作用域使用</td><td>可以用return返回值(达到全局)</td><td>连接两个作用域链</td></tr></tbody></table></div><p><strong>获取对象中的值:</strong> </p><p>1.对象名.属性名 </p><p>2.对象名[‘属性名’]     <a id="more"></a></p><p><strong>执行对象方法:</strong></p><p> 1.对象名.方法名 </p><p>2.对相名 [‘ ‘] ()</p><p><strong>new关键字:</strong></p><p>new就是调用构造函数,创建对象.</p><p><strong>代码的预读:</strong></p><p> 变量提升 和 函数提升(不包含调用函数). </p><p>  [注:预解析后:先提升函数在提升变量]</p>        <h3 id="4种创造对象的方式">          <a href="#4种创造对象的方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#4种创造对象的方式" class="headerlink" title="4种创造对象的方式"></a>4种创造对象的方式</h3>      <p>Object:对象 ——–操作对象(取值、赋值)对象是个容器.                                           </p><p> <strong>组成:</strong></p><p> 1.属性 2.方法                                             </p><p> <strong>☞ 字面量</strong>—创造单个 </p><pre><code class="js"> var 对象名 = {  属性 : 值 , (最后一个值不加逗号.)  方法 : 自定义 : function() { ('_') }     }   </code></pre><p>  <strong>☞ js内置的构造函数</strong>— 创造单个    </p><pre><code class="js"> var 对象名 = new Object();           [注:Object():js中内置好的函数]     </code></pre><p><strong>☞ 工厂方式</strong>— 适用于批量创建 </p><pre><code class="js">function fn(name) {      var 对象名 = new Object();     对象名.属性;  return  对象名} </code></pre><p>​             </p><p><strong>☞ 自定义构造函数创造</strong>—-批量创建 </p><pre><code class="js">    function fn () {        this.属性名= 值    }   [注:首字母大写]</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> argment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML基础（二）</title>
      <link href="/2020/01/04/HTML%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%BA%8C%E5%A4%A9/"/>
      <url>/2020/01/04/HTML%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%BA%8C%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h2 id="第二天">          <a href="#第二天" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二天" class="headerlink" title="第二天"></a><strong>第二天</strong></h2>      <p>json  更改          </p><p>表格:跨行(rowspan)是竖着[从上往下夸]   跨列(colspan)横着</p><p>ctrl  f  查找<br>ctrl   s   保存<br>auto rename tag 插件<br>按住滚轮往下b</p><a id="more"></a><p>dl 自定义列表  </p><p>dt  文字类标签</p><p>dd   并列</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML（二） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>less补充</title>
      <link href="/2020/01/04/less%E8%A1%A5%E5%85%85/"/>
      <url>/2020/01/04/less%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[<h3 id="less补充">          <a href="#less补充" class="heading-link"><i class="fas fa-link"></i></a><a href="#less补充" class="headerlink" title="less补充"></a><strong>less补充</strong></h3>      <p><strong>引入less</strong>:</p><pre><code class="css">1.通过link引入less文件Eg: &lt;link rel="stylesheet/less"  href="css/less" &gt;2.需要在网页中引入less.js文件Eg:&lt;script src="less.js"&gt; &lt;script&gt;3.需要在服务器环境下执行</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> less </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件对象event属性</title>
      <link href="/2020/01/04/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1exent%E5%B1%9E%E6%80%A7/"/>
      <url>/2020/01/04/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1exent%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="事件对象event属性">          <a href="#事件对象event属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#事件对象event属性" class="headerlink" title="事件对象event属性"></a>事件对象event属性</h2>              <h3 id="事件对象的使用方法">          <a href="#事件对象的使用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#事件对象的使用方法" class="headerlink" title="事件对象的使用方法"></a>事件对象的使用方法</h3>      <p>处理函数定义是作为函数的第一个形参,就代表event对象:</p><p>enter编码13  </p><pre><code class="html">xx元素.onxx事件 = function(e){ //在此函数中,e就代表event对象}</code></pre><p>或</p><pre><code class="html">xx元素.addEventListener('xx事件',function(e)){//在此函数中,e就代表event对象}</code></pre><p>或 <a id="more"></a></p><pre><code>xx元素.onxx事件= func1;xx元素.addEventListener('xx事件',func1);//特别注意:这里只要写也只能写函数名称function funcl1(e){// 在此函数中， e 就代表 event对象}</code></pre>        <h3 id="事件对象event的属性">          <a href="#事件对象event的属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#事件对象event的属性" class="headerlink" title="事件对象event的属性"></a>事件对象event的属性</h3>      <p>event.target</p><p>  ++- 代表当前直接触发事件的元素本身</p><p>this对比：</p><p>代表事件发生时绑定了当前事件的元素</p><p>●event.type</p><p>代表当前事件类型,其实就是事件的名称,</p><p>●event.clientX,event.clientY</p><p>代表事件发生时鼠标在当前窗口可视范围的位置</p><p>仅仅只对鼠标事件有效</p><p>●event.pageX,ebent.pageY</p><p>代表事件发生时鼠标在页面文档范围的位置</p><p>仅仅对鼠标事件有效</p><p>●event.keyCode()</p><p>代表键盘事件ain发生是所按下的按键的按键码,是一个数字</p><p>仅仅对键盘事件有效</p>        <h3 id="事件对象event的方法">          <a href="#事件对象event的方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#事件对象event的方法" class="headerlink" title="事件对象event的方法"></a>事件对象event的方法</h3>      <p>●even.preventDefault()</p><p>取消事件的默认行为,</p><p>所谓默认行为，是指一个元素发生某个事件时，默认会产生的结果（行为）。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> event </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>less</title>
      <link href="/2020/01/04/less/"/>
      <url>/2020/01/04/less/</url>
      
        <content type="html"><![CDATA[<h3 id="less-less-bootcss-com">          <a href="#less-less-bootcss-com" class="heading-link"><i class="fas fa-link"></i></a><a href="#less-less-bootcss-com" class="headerlink" title="less        less.bootcss.com/#"></a><strong>less</strong>        <strong>less.bootcss.com/#</strong></h3>      <p><strong>less去写css代码优势:</strong></p><p>1.less中可以进行数字运算</p><p>2.less中可以支持选择器中嵌套选择器</p><p>   <strong>less使用步骤:</strong></p><p>1.新建less文件</p><p>​     ☂ 文件名以less结尾</p><p>2.less按照css语法编写</p><p>​       ☂ less文件中完全可以使用css原生的语法去写</p> <a id="more"></a><p>3.less语法</p><p>​      ☂  <strong>less嵌套语法</strong>(只适用嵌套结构的标签)</p><pre><code class="less">.nav{    li{    }}</code></pre><p>​       ☞<strong>支持数学运算</strong></p><p>​       ☞<strong>支持变量的设置</strong>(如果某个值是一个变化的值,那么就可以将改制保存到变量中)</p><pre><code class="less">@div_width: ***;</code></pre><p>​        ☞less混合写法</p><pre><code class="less">//less中的函数 [类似于css中的公共样式]#abc(){    color:red;    font-size:20px;}例如:.public(){    width:300px;    height:300px;    background-color:skyblue;}.one{    color:red;    .public()}.two{    color:black;    .public()}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> less </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bootstrap框架</title>
      <link href="/2020/01/04/bootstrap%E6%A1%86%E6%9E%B6/"/>
      <url>/2020/01/04/bootstrap%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="bootstrap框架">          <a href="#bootstrap框架" class="heading-link"><i class="fas fa-link"></i></a><a href="#bootstrap框架" class="headerlink" title="bootstrap框架"></a>bootstrap框架</h3>      <p>1.为了快速实现响应式布局和移动端页面为主.</p><p>2.全局样式[网页中常见标签的基本样式设置]</p><p>栅格系统[为实现响应式布局的]——-媒体查询</p><a id="more"></a><p><strong>☞下载</strong>(css文件)</p><p> <strong>生产环境</strong>:压缩,快速开发,并不适合学习</p><p><strong>源码</strong>:手写,没压缩</p><p><strong>使用</strong>—引用</p><p>语义标签—–(忘了)</p>        <h3 id="全局标签-最好刚刚不要使用…">          <a href="#全局标签-最好刚刚不要使用…" class="heading-link"><i class="fas fa-link"></i></a><a href="#全局标签-最好刚刚不要使用…" class="headerlink" title="全局标签(最好刚刚不要使用…)"></a><strong>全局标签</strong>(最好刚刚不要使用…)</h3>      <pre><code class="css">标题标签(可以直接写标签名字 | 对应类名)表示超小文字(可以使用small标签 | 对应的类名)text-capitallizr //*首个字母大小.text-capitalize</code></pre>        <h3 id="栅格系统-odd奇数-even偶数">          <a href="#栅格系统-odd奇数-even偶数" class="heading-link"><i class="fas fa-link"></i></a><a href="#栅格系统-odd奇数-even偶数" class="headerlink" title="栅格系统             odd奇数   even偶数"></a><strong>栅格系统</strong>             odd奇数   even偶数</h3>      <pre><code class="css">作用:用来实现响应式布局,通过将设备(视口)分为12列</code></pre><pre><code class="css">使用:1.引用bootstrap.css文件  [用一个就行]2.给父元素容器设置container[固定居中]或者container-fluid[满屏]3.只要给盒子设置了****或者***类名后就会分为12列4.通过栅格参数实现响应式布</code></pre><pre><code>.col-md ----&gt;适配电脑屏幕.col-sm ----&gt;适配平板设备.col-xs ----&gt;适配手机设备.col-lg ----&gt;适配大屏幕设备  2000px(或者1200px)?忘了</code></pre><p>可以给 *加边框,也可以加padding值</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bootstrap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rem适配</title>
      <link href="/2020/01/04/rem/"/>
      <url>/2020/01/04/rem/</url>
      
        <content type="html"><![CDATA[<h3 id="rem适配-vw">          <a href="#rem适配-vw" class="heading-link"><i class="fas fa-link"></i></a><a href="#rem适配-vw" class="headerlink" title="rem适配 [vw]"></a><strong>rem适配</strong> [vw]</h3>              <h3 id="移动端方式-补-opacity-透明颜色">          <a href="#移动端方式-补-opacity-透明颜色" class="heading-link"><i class="fas fa-link"></i></a><a href="#移动端方式-补-opacity-透明颜色" class="headerlink" title="移动端方式          补:opacity: 透明颜色;"></a><strong>移动端方式</strong>          补:opacity: 透明颜色;</h3>      <p> 1.<strong>流式布局(百分比布局)</strong>2.<strong>伸缩布局(弹性布局)</strong>3.<strong>响应式布局(媒体查询)</strong></p><p>4.<strong>rem适配:</strong>让元素(内容)随着设备的宽度改变,自己发生大小的改变</p><pre><code class="css">计算移动端中根标签[html]文字大小=当前设备宽度(动态获取)/缩放的倍数 媒体查询----定义一个变量</code></pre><pre><code class="css">计算ui图片中测量元素的rem值=测量大小/(ui图大小/缩放倍数)rem值是根据根(html)标签的文字大小来设置的</code></pre><p>​      <strong>注:</strong> UI 图中缩放的倍数必须和设备中缩放的倍数统一</p><p>@size是什么? <a id="more"></a></p>        <h4 id="补充-为什么页面适配要使用rem而不是em">          <a href="#补充-为什么页面适配要使用rem而不是em" class="heading-link"><i class="fas fa-link"></i></a><a href="#补充-为什么页面适配要使用rem而不是em" class="headerlink" title="补充: 为什么页面适配要使用rem而不是em?"></a><strong>补充:</strong> <strong>为什么页面适配要使用rem而不是em?</strong></h4>      <p>  1.rem在适配的时候是相对html中的文字大小</p><p>   2.html中的文字大小不会影响某个具体标签中的文字大小(继承的权重为0)</p><p>   3.rem适配最重要的一步就是要保证html中设置文字的大小</p><p><del><strong>注:</strong>保证当前标签中文字大小是30px 又要保证当前标签的宽度是400px</del></p><p> UI 640px —-20倍   750px—-25倍</p><p><strong>em:</strong>相对单位,em是相对当前标签中文字大小</p><p><strong>rem:</strong>相对单位,r(root),rem单位是相对html根标签中文字的大小</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rem适配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM模型</title>
      <link href="/2020/01/04/DOM%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/01/04/DOM%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="DOM模型">          <a href="#DOM模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#DOM模型" class="headerlink" title="DOM模型"></a>DOM模型</h1>              <h3 id="JavaScript由以下三部分构成">          <a href="#JavaScript由以下三部分构成" class="heading-link"><i class="fas fa-link"></i></a><a href="#JavaScript由以下三部分构成" class="headerlink" title="JavaScript由以下三部分构成"></a>JavaScript由以下三部分构成</h3>      <p>1.ECMAScript  2.Bom（浏览器对象） 3.Dom（文档对象）</p><pre><code class="js">注：&lt;script&gt;放在body的最后面</code></pre><a id="more"></a>        <h5 id="术语">          <a href="#术语" class="heading-link"><i class="fas fa-link"></i></a><a href="#术语" class="headerlink" title="术语"></a>术语</h5>      <p>1.文档（document）</p><pre><code class="文字">注：1.语法 2.注意大小写3.样式不加-4.多加或少加单引号''</code></pre><p> 2.节点（了解）</p><pre><code class="CN">构成网页的所有组成部分，在js中都被成为节点。节点类型：①标签节点②属性节点③文本节点节点属性：①nodeType节点类型②nodeName节点类型③nodeValue节点值</code></pre><p>注：节点本身就是对象。</p><p>元素节 == 标签名    属性节 == 属性名  文本节 == #text    value == null(空)</p><p>3.元素</p><pre><code class="cn">就是html中的标签，在js中称为元素或对象，是节点的一种，也称为元素节点</code></pre>        <h5 id="Dom编程的基本理解">          <a href="#Dom编程的基本理解" class="heading-link"><i class="fas fa-link"></i></a><a href="#Dom编程的基本理解" class="headerlink" title="Dom编程的基本理解"></a>Dom编程的基本理解</h5>      <pre><code class="cn">在js代码中获取到网页中的有关标签（元素），并对其进行某种操作。</code></pre>        <h3 id="DOM模型-1">          <a href="#DOM模型-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#DOM模型-1" class="headerlink" title="DOM模型"></a>DOM模型</h3>              <h5 id="如何获取元素">          <a href="#如何获取元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何获取元素" class="headerlink" title="如何获取元素"></a>如何获取元素</h5>      <pre><code class="js">根据ID名获取元素 ------document.getElementByid（'id名'）【结果是该id所对应的元素（对象/节点）】根据标签获取元素 ------document.getElementsByTagName（'标签名'）【结果是一个'集合'（伪数组）】|注意：标签获取即使只获取一个元素，也是一个伪数组，也是集合，也要用下标去获取|根据类名获取元素 ------document.getElementsByClassName（'类名'）【结果是一个'集合'（伪数组）】               ------document.querySelector('选择器')【结果是该选择器所对应的第一个元素（对象/节点）】根据选择器获取元素               ------document.querySelectorAll('选择器')【结果是一个'集合'（伪数组）】</code></pre>        <h5 id="元素（节点）关系获取元素">          <a href="#元素（节点）关系获取元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#元素（节点）关系获取元素" class="headerlink" title="元素（节点）关系获取元素"></a>元素（节点）关系获取元素</h5>      <pre><code class="js">xx元素.parentNode--------【获取到某元素的父元素】xx元素.children---------【获取到某元素的所有子元素，是一个集合】xx元素.firstElementChild--------【获取到某个元素的第一个子元素】xx元素.lastElementChild--------【获取到某个元素的最后一个子元素】xx元素.nextElementSibing-------【获取到某个元素的后一个兄弟元素】xx元素.previousElementSibing------【获取到某个元素的前一个兄弟元素】</code></pre>        <h5 id="添加元素">          <a href="#添加元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5>      <pre><code class="js">创建元素-----var 变量 = document.createElement（'标签名'）|注：创建的元素以内存变量的形式，未放入页面中|克隆元素-----var 变量 = xx元素.cloneNode（true/false）【true表示同时克隆该元素的所有内部内容。false表示不克隆该元素的内部内容】添加元素到父元素中的最后位置------xx父元素.appendChild（xx要添加的元素）【结果该新添加的元素成为了父元素的最后一个子元素】添加元素到父元素中的某个元素之前-----xx父元素.insertBefore（xx要添加的元素，xx现有的元素）【结果该新添加的元素成为了父元素的一个子元素，并在指定的子元素前】替换某个现有元素------xx父元素.replaceChild（xx新，xx旧）【结果就是新的元素替换了所给定的现有子元素】</code></pre>        <h5 id="删除元素">          <a href="#删除元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h5>      <pre><code>父元素.removeChild（子元素）</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何有效阅读一本书（一）</title>
      <link href="/2020/01/04/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6(%E4%B8%80)/"/>
      <url>/2020/01/04/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h2 id="如何有效阅读一本书（一）">          <a href="#如何有效阅读一本书（一）" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何有效阅读一本书（一）" class="headerlink" title="如何有效阅读一本书（一）"></a>如何有效阅读一本书（一）</h2>      <p><strong>1.随想笔记:记录平时的感悟,这与日后的选书息息相关.</strong></p><pre><code>  【注:a.可以书写任何内容 b.按时间顺序书写  c.附上日期 d.灵活运用速记或略记 e.可以粘贴 】</code></pre><p><strong>2.购书清单:找到真正想读的书.</strong></p><p>  <strong>[注:选书.购书.读书和活用才是读书的完整流程] (归档…..)</strong>     </p><blockquote><p>​         <strong>|书名、作者与出版社名.|       标注:所谓读书的动机或目的性,就好比照片的’焦点’.即使拍摄同样的场景,聚焦于面前的花朵和聚焦于远处的建筑,得到的效果完全不同.读书也一样,抱着不同的目的阅读同一本书,也会产生截然不同的效果.</strong></p></blockquote><p><strong>3.各种报道的剪报:尽情的收录感兴趣的内容.</strong></p><p><strong>4.读书笔记:将读后感转变成文字保存下来.</strong><a id="more"></a></p><p><strong>5.养成习惯</strong></p><p><strong>6.放大读书笔记的作用.</strong></p><p><strong>7.创造别具一格的记录方式</strong></p><p><strong>8.信息一元化(读书一元化)</strong>      </p><pre><code class="文字"> 【注:①简单易懂.人人都能做到       ②更容易坚持.       ③自由度高,可自行设置      ④信息'存在'于同一个地方       ⑤直接记录.参考.不易混肴.        ⑥因为'杂乱无章',所以便于活用】</code></pre><p><strong>杂:绫辻行人的钟表馆事件.远宁的八声甘州以及岛田庄司系列和江户川乱步系列.     –新星出版社–</strong>     <strong><del>ps:听说他们家的纸不是很好 :）</del></strong>   </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 我的读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS高级用法</title>
      <link href="/2020/01/04/CSS%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
      <url>/2020/01/04/CSS%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="CSS高级用法">          <a href="#CSS高级用法" class="heading-link"><i class="fas fa-link"></i></a><a href="#CSS高级用法" class="headerlink" title="CSS高级用法"></a><strong>CSS高级用法</strong></h3>      <p>   <strong>核心知识点</strong></p>        <h3 id="2D转化及相关属性-重要">          <a href="#2D转化及相关属性-重要" class="heading-link"><i class="fas fa-link"></i></a><a href="#2D转化及相关属性-重要" class="headerlink" title="2D转化及相关属性[重要]"></a><strong>2D转化及相关属性[重要]</strong></h3>      <a id="more"></a><ol><li><pre><code class="css">基本语法:                 transition:all .5;[过度动画]旋转:transform:rotate(deg/*度*/)  正顺负逆默中心tranform-origin/*改变旋转中心点*/   绕点旋转具体坐标 | 缩放:tranform:scale(x (w), y (h));  倍数 scale()中设置的值表示的是一个倍数,没单位scale()中设置的值如果大于0且小于1, 缩小scale()中设置的值大于1, 放大scale()中设置的值等于1, 不变 scale()中设置的值等于0,该宽高等于0scale()中设置的值可以设置一个,宽和高的倍数scale()中不能设置负数注:如果页面中元素要同时设置多个tranform属性的时候,tranform属性要合写[防层叠]位移:x轴:水平,左向右为正y轴:垂直,上向下为正tranform:tranlate(x,y);中第一个值代表水平方向位移,第二个值代表垂直方向位移补充:线性渐变background-image: linear-gradient( /* 渐变的方向 */ to right, #34c2aa, #6cd557 /* 使用角度的方式渐变 */ /* 135deg, red, blue */ );</code></pre></li></ol>        <h3 id="3D转换">          <a href="#3D转换" class="heading-link"><i class="fas fa-link"></i></a><a href="#3D转换" class="headerlink" title="3D转换"></a><strong>3D转换</strong></h3>      <pre><code class="css">语法:   tranform:tranlateX(值) /*x必须大写*/可以设置百分比   tranlateX只能让元素沿着水平方向位移           可以设置负数,沿水平相反的方向位移(从右往左)           可以设置百分比,百分比是相对于当前元素的宽度   Y   Z   prespective: 透视在浏览器中出现近大远小的效果  (透视:推荐值--&gt;600--1000)   prespective属性设置:给tranform属性的父元素添加   总结:   旋转:       加个坐标轴       x  正往我这边        Y 正往右  开门      z 于2d转换效果一样   总结:如果元素沿着x轴旋转,x轴默认中间位置   3d改旋转轴 tranSform-origin             tranSform-origin:left;轴   缩放:   tranSporfm: scale()   转化样式平面转立体   transform-style:preserve-3d;</code></pre>        <h3 id="animation属性">          <a href="#animation属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#animation属性" class="headerlink" title="animation属性"></a><strong>animation属性</strong></h3>      <p>animation–动画自动播放 ,动画次数可以无限次执行</p><p>transition—    动画需用户动作,动画随着用户动作的取消</p><pre><code class="css">@keyframes name {       /*设置动画在开始时候的样式*/       from {            }            /* 动画开始后的一个效果 */            to {            }}animation-name:调用动画名称animation-dyration:设置动画时间animation-iteraton-count:设置动画次数 infinite;无限次执行animation-direction:alternate; 逆播animation-timing-function:;速度默认值ease | linear匀速ease-in 加速 | ease-out 减速 |ease-in-outanimation-fill-mode:forwards;让动画在结束位置停止[条件不能设置无限次数]animation-delay:设置动画延迟时间animation复合属性:1.设置  animation -name2 设置 animation-duration</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js（一）</title>
      <link href="/2019/12/27/js%E4%B8%80/"/>
      <url>/2019/12/27/js%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="js">          <a href="#js" class="heading-link"><i class="fas fa-link"></i></a><a href="#js" class="headerlink" title="js"></a><strong>js</strong></h2>      <pre><code class="JavaScript">行内式:  学习阶段1.先准备一个html2.在html页面中任何一个位置,添加一个&lt;script&gt;&lt;/script&gt;标签 3.对应代码</code></pre><pre><code class="JavaScript">外联式:   大项目1.单独一个js文件 .js2.在js文件直接写对应的js代码3.通过&lt;script src="js文件路径"&gt; &lt;/script&gt;----引用js文件</code></pre><blockquote><pre><code class="js">当前一个值是变量不需要加单引号....console.log('要展示的信息');控制台注意:1.在程序中遇到的任何一个特殊符号,都必须是英文输入法的符号2.9.alert('新窗口'); 弹出窗口3.document.write('展示信息');网页4. 获取用户输入信息prompt('提示用户要输入的信息');  </code></pre></blockquote>        <h3 id="变量">          <a href="#变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#变量" class="headerlink" title="变量:"></a>变量:</h3>      <a id="more"></a><pre><code class="js">作用:在程序中保存数据的一个容器var 自定义变量名 注:1.定义必须写var写法:var 变量名 = 值;注意: '=' 叫赋值运算 '=' 右侧的结果 赋值给 左侧变量 var kid = prompt ('请输入摄氏度')alert ()</code></pre><p>变量的命名规范:</p><p> .变量名在合法的时候一定的语义</p><ol><li><strong>字符必须是字母、 数字或下划线</strong>  </li></ol><p>.不能用的(var变量名—关键字不能作为变量名)    (数字不能作为变量名)  (变量中间不能出现空格) (汉字不能作为变量名)     (不建议直接使用name) (不建议使用js的<strong>保留字</strong>)</p><p> Number—-&gt;数字</p><p>​    1.arseInt—&gt;整数类型</p><p>2,parseFloat —&gt;浮点类型</p><p>boonlen类型</p><p>string 类型</p><p>如果布尔类型的false转化为数字类型后数字是0</p><p>​                           true 转化为1</p><p>undefined类型</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML+CSS+JS代码规范</title>
      <link href="/2019/12/20/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>/2019/12/20/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML-CSS-JS代码格式规范">          <a href="#HTML-CSS-JS代码格式规范" class="heading-link"><i class="fas fa-link"></i></a><a href="#HTML-CSS-JS代码格式规范" class="headerlink" title="HTML+CSS+JS代码格式规范"></a>HTML+CSS+JS代码格式规范</h2>              <h2 id="1-为什么要按照规范写代码">          <a href="#1-为什么要按照规范写代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-为什么要按照规范写代码" class="headerlink" title="1.为什么要按照规范写代码"></a>1.为什么要按照规范写代码</h2>      <blockquote>        <h4 id="☞代码规则">          <a href="#☞代码规则" class="heading-link"><i class="fas fa-link"></i></a><a href="#☞代码规则" class="headerlink" title="☞代码规则"></a>☞代码规则</h4>      <pre><code class="html">编译器在编译时就会报错，这个规定叫作规则</code></pre>        <h4 id="☞代码规范">          <a href="#☞代码规范" class="heading-link"><i class="fas fa-link"></i></a><a href="#☞代码规范" class="headerlink" title="☞代码规范"></a>☞代码规范</h4>      <pre><code class="html">有一种规定，它是一种人为的、约定成俗的，即使不按照那种规定也不会出错，这种规定就叫作规范</code></pre>        <h4 id="☞代码规范化的好处">          <a href="#☞代码规范化的好处" class="heading-link"><i class="fas fa-link"></i></a><a href="#☞代码规范化的好处" class="headerlink" title="☞代码规范化的好处"></a>☞代码规范化的好处</h4>      <pre><code>规范的代码可以减少bug处理，规范的代码可以降低维护成本，规范的代码有助于代码审查。</code></pre></blockquote> <a id="more"></a>        <h2 id="2-HTML代码规范介绍">          <a href="#2-HTML代码规范介绍" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-HTML代码规范介绍" class="headerlink" title="2. HTML代码规范介绍"></a>2. HTML代码规范介绍</h2>              <h4 id="1-嵌套元素应当缩进一次（即两个空格）">          <a href="#1-嵌套元素应当缩进一次（即两个空格）" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-嵌套元素应当缩进一次（即两个空格）" class="headerlink" title="1.嵌套元素应当缩进一次（即两个空格）"></a>1.嵌套元素应当缩进一次（即两个空格）</h4>      <pre><code class="html">&lt;div&gt;    &lt;p&gt;&lt;/p&gt;&lt;/div&gt;</code></pre>        <h4 id="2-对于属性的定义，确保全部使用双引号，不要使用单引号。">          <a href="#2-对于属性的定义，确保全部使用双引号，不要使用单引号。" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-对于属性的定义，确保全部使用双引号，不要使用单引号。" class="headerlink" title="2.对于属性的定义，确保全部使用双引号，不要使用单引号。"></a>2.对于属性的定义，确保全部使用双引号，不要使用单引号。</h4>      <pre><code class="html">&lt;div class="username"&gt;&lt;/div&gt;</code></pre>        <h4 id="3-单标签中不要添加‘-’结束">          <a href="#3-单标签中不要添加‘-’结束" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-单标签中不要添加‘-’结束" class="headerlink" title="3.单标签中不要添加‘/’结束"></a>3.单标签中不要添加‘/’结束</h4>      <pre><code class="html">&lt;br&gt; 备注： html5中提示可以加可以不加</code></pre>        <h4 id="4-不能省略双标签的结束的标签">          <a href="#4-不能省略双标签的结束的标签" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-不能省略双标签的结束的标签" class="headerlink" title="4.不能省略双标签的结束的标签"></a>4.不能省略双标签的结束的标签</h4>      <pre><code class="html">&lt;div&gt;&lt;/div&gt;</code></pre>        <h4 id="5-在引入CSS文件和JS文件时候，不需要指定type属性">          <a href="#5-在引入CSS文件和JS文件时候，不需要指定type属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-在引入CSS文件和JS文件时候，不需要指定type属性" class="headerlink" title="5.在引入CSS文件和JS文件时候，不需要指定type属性"></a>5.在引入CSS文件和JS文件时候，不需要指定type属性</h4>      <pre><code class="html">&lt;style&gt;&lt;/style&gt;&lt;script&gt;&lt;/script&gt;备注：type属性属于以上标签的默认值</code></pre>        <h4 id="6-标签使用过程中，要遵循标签的语义化">          <a href="#6-标签使用过程中，要遵循标签的语义化" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-标签使用过程中，要遵循标签的语义化" class="headerlink" title="6.标签使用过程中，要遵循标签的语义化"></a>6.标签使用过程中，要遵循标签的语义化</h4>              <h4 id="7-标签设置属性的时候，要按照顺序依次设置，保证代码易读性">          <a href="#7-标签设置属性的时候，要按照顺序依次设置，保证代码易读性" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-标签设置属性的时候，要按照顺序依次设置，保证代码易读性" class="headerlink" title="7.标签设置属性的时候，要按照顺序依次设置，保证代码易读性"></a>7.标签设置属性的时候，要按照顺序依次设置，保证代码易读性</h4>      <pre><code class="html">&lt;div class=""  id=""  name=""&gt;&lt;/div&gt;</code></pre>        <h2 id="3-CSS代码规范介绍">          <a href="#3-CSS代码规范介绍" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-CSS代码规范介绍" class="headerlink" title="3.CSS代码规范介绍"></a>3.CSS代码规范介绍</h2>              <h4 id="1-为了代码的易读性，在每个声明块的左花括号前添加一个空格，且单独成行">          <a href="#1-为了代码的易读性，在每个声明块的左花括号前添加一个空格，且单独成行" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-为了代码的易读性，在每个声明块的左花括号前添加一个空格，且单独成行" class="headerlink" title="1. 为了代码的易读性，在每个声明块的左花括号前添加一个空格，且单独成行"></a>1. 为了代码的易读性，在每个声明块的左花括号前添加一个空格，且单独成行</h4>      <pre><code class="CSS">选择器 {}</code></pre>        <h4 id="2-每条声明语句的：后应该插入一个空格-且以封号结束">          <a href="#2-每条声明语句的：后应该插入一个空格-且以封号结束" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-每条声明语句的：后应该插入一个空格-且以封号结束" class="headerlink" title="2.每条声明语句的：后应该插入一个空格,且以封号结束"></a>2.每条声明语句的：后应该插入一个空格,且以封号结束</h4>      <pre><code class="css">选择器 {    color: red;}</code></pre>        <h4 id="3-避免为-0-值指定单位">          <a href="#3-避免为-0-值指定单位" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-避免为-0-值指定单位" class="headerlink" title="3.避免为 0 值指定单位"></a>3.避免为 0 值指定单位</h4>      <pre><code class="css">选择器 {    margin: 0;}</code></pre>        <h4 id="4-声明顺序">          <a href="#4-声明顺序" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-声明顺序" class="headerlink" title="4. 声明顺序"></a>4. 声明顺序</h4>      <pre><code class="css">1. 定位2. 盒子模型3. 其他内部属性例如：div {    position: absolute;    left: 0;    top: 0;    width: 200px;    height: 200px;    font-size: 12px;    text-align: center;}</code></pre>        <h4 id="5-选择器">          <a href="#5-选择器" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-选择器" class="headerlink" title="5. 选择器"></a>5. 选择器</h4>      <pre><code>1.优先选择类选择器，有利于渲染性能优化2.选择器层级不能太高，最多不要超过3个</code></pre>        <h2 id="4-js语法规范">          <a href="#4-js语法规范" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-js语法规范" class="headerlink" title="4.js语法规范"></a>4.js语法规范</h2>      <blockquote>        <h5 id="☞定义变量后要空行-在定义变量的同时初始化该变量">          <a href="#☞定义变量后要空行-在定义变量的同时初始化该变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#☞定义变量后要空行-在定义变量的同时初始化该变量" class="headerlink" title="☞定义变量后要空行,在定义变量的同时初始化该变量"></a>☞定义变量后要空行,在定义变量的同时初始化该变量</h5>      <pre><code class="javascript">var num = 123;</code></pre>        <h5 id="☞函数名之后不要留空格">          <a href="#☞函数名之后不要留空格" class="heading-link"><i class="fas fa-link"></i></a><a href="#☞函数名之后不要留空格" class="headerlink" title="☞函数名之后不要留空格"></a>☞函数名之后不要留空格</h5>      <pre><code class="javascript">function fn() { }</code></pre>        <h5 id="☞单目运算符-、-、-、－－、－、-、-amp-等前后不加空格">          <a href="#☞单目运算符-、-、-、－－、－、-、-amp-等前后不加空格" class="heading-link"><i class="fas fa-link"></i></a><a href="#☞单目运算符-、-、-、－－、－、-、-amp-等前后不加空格" class="headerlink" title="☞单目运算符 !、~、++、－－、－、*、&amp; 等前后不加空格"></a>☞单目运算符 !、~、++、－－、－、*、&amp; 等前后不加空格</h5>              <h5 id="☞声明数组使用">          <a href="#☞声明数组使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#☞声明数组使用" class="headerlink" title="☞声明数组使用[]"></a>☞声明数组使用[]</h5>      <pre><code class="js">var ary = [];</code></pre>        <h5 id="☞通常能用CSS实现的效果要避免使用JS来实现">          <a href="#☞通常能用CSS实现的效果要避免使用JS来实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#☞通常能用CSS实现的效果要避免使用JS来实现" class="headerlink" title="☞通常能用CSS实现的效果要避免使用JS来实现"></a>☞通常能用CSS实现的效果要避免使用JS来实现</h5>              <h5 id="☞变量要使用驼峰命名法，使用名词结构">          <a href="#☞变量要使用驼峰命名法，使用名词结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#☞变量要使用驼峰命名法，使用名词结构" class="headerlink" title="☞变量要使用驼峰命名法，使用名词结构"></a>☞变量要使用驼峰命名法，使用名词结构</h5>      <pre><code class="javascript">var userName = 'zs'备注：    1. 首字母小写，后面单词首字母大写</code></pre>        <h5 id="☞构造函数使用帕斯卡命名法">          <a href="#☞构造函数使用帕斯卡命名法" class="heading-link"><i class="fas fa-link"></i></a><a href="#☞构造函数使用帕斯卡命名法" class="headerlink" title="☞构造函数使用帕斯卡命名法"></a>☞构造函数使用帕斯卡命名法</h5>      <pre><code class="javascript">function Person() {}备注：    1. 所有单词都以大写字母开始</code></pre>        <h5 id="☞对象属性命名必须唯一">          <a href="#☞对象属性命名必须唯一" class="heading-link"><i class="fas fa-link"></i></a><a href="#☞对象属性命名必须唯一" class="headerlink" title="☞对象属性命名必须唯一"></a>☞对象属性命名必须唯一</h5>      <pre><code class="javascript">var obj {    age: 12,    height: 170}</code></pre>        <h5 id="☞在同一个作用域下，变量名和方法名不要重复">          <a href="#☞在同一个作用域下，变量名和方法名不要重复" class="heading-link"><i class="fas fa-link"></i></a><a href="#☞在同一个作用域下，变量名和方法名不要重复" class="headerlink" title="☞在同一个作用域下，变量名和方法名不要重复"></a>☞在同一个作用域下，变量名和方法名不要重复</h5>      <pre><code class="javascript">var fn = 12;function fn() {}</code></pre>        <h5 id="☞每一个方法之间空一行">          <a href="#☞每一个方法之间空一行" class="heading-link"><i class="fas fa-link"></i></a><a href="#☞每一个方法之间空一行" class="headerlink" title="☞每一个方法之间空一行"></a>☞每一个方法之间空一行</h5>      <pre><code class="javascript">function fn() {}function fn1() {}</code></pre>        <h5 id="☞运算符前后需要添加空格">          <a href="#☞运算符前后需要添加空格" class="heading-link"><i class="fas fa-link"></i></a><a href="#☞运算符前后需要添加空格" class="headerlink" title="☞运算符前后需要添加空格"></a>☞运算符前后需要添加空格</h5>      <pre><code class="javascript">var a;var b = a;</code></pre>        <h5 id="☞紧挨着圆括号内不需要加空格">          <a href="#☞紧挨着圆括号内不需要加空格" class="heading-link"><i class="fas fa-link"></i></a><a href="#☞紧挨着圆括号内不需要加空格" class="headerlink" title="☞紧挨着圆括号内不需要加空格"></a>☞紧挨着圆括号内不需要加空格</h5>      <pre><code class="javascript">for(var i = 1; i &lt;= 10; i++) {}</code></pre>        <h5 id="☞三目运算符用来进行条件性的赋值，不要用来当做简写的-if-语句使用。">          <a href="#☞三目运算符用来进行条件性的赋值，不要用来当做简写的-if-语句使用。" class="heading-link"><i class="fas fa-link"></i></a><a href="#☞三目运算符用来进行条件性的赋值，不要用来当做简写的-if-语句使用。" class="headerlink" title="☞三目运算符用来进行条件性的赋值，不要用来当做简写的 if 语句使用。"></a>☞三目运算符用来进行条件性的赋值，不要用来当做简写的 if 语句使用。</h5>      <pre><code class="javascript"> var a =  a &gt;= 10? a : 10;</code></pre></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.1</title>
      <link href="/2019/12/12/%E5%B7%A6%E8%BE%B9%E7%9A%84%E4%BE%A7%E8%BE%B9%E6%A0%8F/"/>
      <url>/2019/12/12/%E5%B7%A6%E8%BE%B9%E7%9A%84%E4%BE%A7%E8%BE%B9%E6%A0%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1">          <a href="#1-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h2>      <ol><li><p>左侧边栏出来的话需要在同级别下</p></li><li><p>common.css(公共样式{模块化}                                               )   </p></li><li><p>注:先引入初始化后引入公共样式</p></li><li><p>关于三大标签的SEO的优化:</p><p> titile标题      description网站说明(meta name=””content=””)     keywoeds(关键字)</p></li><li><p>字体不一样不要给li设置宽高（关于竖线的需要单独的小li）</p></li><li><p>关于字体图标的用法</p></li><li><p>logo SEO :  logo盒子 然后是h1 然后是a链接</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 1.1 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
