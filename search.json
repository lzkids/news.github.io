[{"title":"如何进行心理学研究","url":"/5XE9Z3/","content":"\n研究两个步骤：1产生科学假设 2 验证该假设\n对感兴趣的主题**产生假设**——一个可以加以验证的陈述。\n科学性假设最主要的来源，通常在于科学理论，一组与某特定现象有关、彼此关联的命题。<!--more-->\n验证导源于相互竞争理论的假设，是增进科学知识最有力的途径。\n\n科学的一词意指用来收集资料的研究方法是：\n\n（1）无偏见的，这些方法并非只偏向某一种假设；\n\n（2）可信的，这些方法能让其它合格研究者重复使用且获致相同的结果;\n\n**实验法**是最有力的科学方法,对因果假设提出了最有力的验证. 控制条件——通常在实验中——并加以测量，以找出变量间的关系（所谓**变量**，会产生不同数值的事物）。<u>与其它科学观察法的差别在于，实验法可以精确的控制变量。</u>\n**自然量**是指变量全在实验者的控制下，造成并控制变量的变化。事实上在一个实验中，自变量代表假设中的“成因”，而假设中的“效果”则为**因变量**，因而它是假设会依自变量数值而变动的变量。\n实验法最重要的特征是<u>被试随机分配到不同的组别或条件</u>。**随机分配**是指每位参与者被分配到任意组别的几率是相等的。但实验法只是描述单一自变量对单一因变量的作用。只研究单一自变量是不够的，涉及数种变量刺激操作的研究称为**多变量实验(multivariate experiments)**。用在心理研究上\n\n**测量(measurement)**心理学家采用实验法时，常发现必须对结果作数量的陈述。为了作精确的沟通，通常以数字来描述变量，此过程称为**测量**\n\n但研究及果实一串以数字形式显示的数据时，需以**统计**(statistics)来加以简化和解释，其原则为对以一群人为样本而取得的数据加以处理，再由该样本数据归纳出与此群人有关的结论。而最常用的统计时**平均值**(mean)，即数学平均数的专有名词，为一连串测量数字的总和除以测量次数所得的结果。在统计上是显著的则意味着已统计测量应用于资料上，且此观察到的差异是缺失的或可信的，而不是受到偶发因素的意外或少数极端例子的影响。\n\n**相关法**(correlational method)用来解决某些不受控制的变量，是否与其他我们感兴趣的变量有关联或相关。但是每个变量通常存在多个数值，而要决定用一种称为**相关系数**的统计方法来做决定，其代表符号为小写字母r。而相关系数是两个变量相关程度的估计，且以-1.00至+1.00之间的数字来表示，不相关为0，完全相关为1.00(+1.00表示正相关，-1.00表示负相关)。当r由0至1.00，表明相关程度递增。\n相关性非正即负，相关性的符号表示两个变量若非**正相关**(两个变量的数值不是同时增加就是同时减少)便是**负相关**(一个变量的数值增加时，另一个变量的数值则减少)\n\n**测验**(tests)是一种类似相关法的研究方法，可以来测量某些态度、成就或其它心理特质。\n\n**相关与因果**(correlation and causation)当两个变量间有相关，其中之一有可能是另一个变量的成因，相关是因果关系的先决条件。相关并不必然表示其间有因果。[缺少实验]\n\n**观察法** 直接观察(direct observation)——在研究的早期阶段，观察自然发生的有趣现象是进行研究最佳的方法。\n（1）行为的观察\n\n（2）生理变化的记录\n\n**调查法**(survey method)<u>间接观察：通过问卷或面谈的方式来进行研究。</u>容易出现偏见，尤其考虑到**社会赞许效应**时，指人们会试着呈现出光明面。\n\n**个人历史法**(case histories)间接的观察某个人的方法就是取得TA的传记，即特定人物的部分传记(回忆过去的相关经历)。<u>个案历史法限制在于依赖人们记忆与对早年事件的重建，然而这些常常被扭曲或者不完整。</u>\n\n**文献回顾整理法**是指摘录某主题既存的研究文献。\n<u>元分析</u>是指使用统计方法从过去的研究中统整并导出结论。\n\n**心理学的研究理论**   \n\n以人为被试的研究：\n<font color=red>(1)*首要的道德原则是最小危险性*</font>\n\n<font color=red>(2)*知情同意。自愿参加*</font>\n\n<font color=red>(3)*被试的隐私权。收集资料是要抽离可辨认的信息等*</font>\n\n以动物为被试的研究：以动物进行研究的主要原因：\n(1)*动物的行为本身即值得研究*\n\n(2)*动物的系统可以提供作为人类系统的模(有助于得到一些无法[或者不和道德]从人类研究中获得的知识)*\n\n参与心理学研究的人应被视为此研究事业的完全合伙人\n\n{% spoiler 小结 %}\n进行心理学研究先要产生假设，然后通过科学方法来验证。了解心理实验法必备的核心概念有自变量、因变量，实验组、控制组，随机分配，测量与统计。\n当实验不可行，即可能用相关法来决定：某一自发性的变量是否与另一变量有关联？此二变量关联的程度可由相关系数r测得，其数值可为正(最高到+1.00)或负(最小未-1.00)或随另变量增高反而降低(-)而定。\n另一种进行研究的方法为观察法，可通过直接观察，间接调查，或是采取个案历史法。\n最后一种研究法为文献回顾整理，可通过叙述性回顾，或统计的元分析。\n对待人类被试应遵循的基本伦理原则为：最小危险性、知情同意，以及尊重隐私权。施予动物身上的任何痛苦或具伤害性的过程，都必须以可从该项研究中获得该知识的理由加以辨明。\n{% endspoiler %}","tags":["西尔格德心理学导论"],"categories":["爱好心理学"]},{"title":"前沿研究:21世纪的心理学","url":"/1QSXSSQ/","content":"\n最受瞩目的是认知神经科学、进化心理学、文化心理学与积极心理学\n\n**认知神经科学**（cognitive neuroscience）试图了解脑部如何执行心智活动。\n认知心理学提供了某特定认知能力——如面孔辨识——的假设，而神经科学则提出这些特定功能在脑部执行的可能过程。\n认知神经科学以新技术研究正常被试（正好与脑部受损被试相反）在进行认知活动试的脑部。\n心理学与神经科学间的联结并不仅限于认知心理学中。 <!--more-->\n\n**感情神经科学**以探究脑部如何执行情绪现象，以及**社会认知神经科学**以探索脑部如何执行刻板印象、态度、人际知觉，以及自我知识。\n\n**进化心理学**关注心理机制的生物起源。\n\n------\n\n{% markmap 100px %}\n\n# 与进化心理学相关的学科\n\n## 心理学\n\n## 生物学\n\n## 分支\n\n- 人类学\n- 精神医学\n\n{% endmarkmap %}\n\n------\n\n**进化心理学**的主要概念是，心理机制经过数百万年的自然选择过程。\n若说心理学机制以自然选择方式进化，<u>即意味着它具有基因基础某些生存问题或增加繁殖机会十分有利。</u>\n\n**文化心理学** (cultural psychology)关注一个人生活于其间的文化传统、语言和世界观——如何影响此人的心理表征和心理历程\n\n**积极心理学**   即为了平衡本领域对心理疾病繁复的科学性解说，转而对人类丰饶的一面提出同样繁复的科学性解说（2002）\n\n**积极情绪** 会扩展人们的心灵，鼓励人们去发现新的思想与行动路线。\n<font color=#596E99>积极心理学告诉我们的主要信息是：积极情绪值得我们培养的原因，不仅仅在于积极情绪本身即为我们意欲达到的目标状态，更因为它是激发心灵向心理成长与丰沛提升的途径</font>","tags":["西尔格德心理学导论"],"categories":["爱好心理学"]},{"title":"小结与关键思考问题","url":"/1AMHQBM/","content":"\n心理学研究取向，而现阶段即有五种观点：生物观、行为观、认知观、心理分析观及主观观点。\n生物观与其他观点不同之处在于其原则部分源自生物学。采取生物观点者常试图以生物学原理来解释心理学原则；此即所谓还原论。 <!--more-->\n心理学的主要领域有：生物心理学、实验心理学、发展心理学、社会与人格心理学、临床与咨询心理学、学校与教育心理学，以及组织与工程心理学。\n新近探索的领域，包括：认知神经科学（以及感情神经科学、社会认知神经科学）、进化心理学、文化心理学、积极心理学等，均触及传统的心理学各领域与科学的课题。\n\n1.思考这个问题： “决定个人性取向的因素为何？” 本章所述各种观点将如何探讨此问题？\n\n{% spoiler 答%}\n长相？相处友好度？\n{% endspoiler %}\n\n2.21世纪的心理学有许多新的研究取向（见前沿研究栏内）整合了不同的观点或弥补了本领域的缺失。值此崭新世纪，心理学可能会有哪些新的进展？你预期还会出现哪些整合性的论点且补足哪些缺憾？\n\n{% spoiler 答%}\n暂时想不到。占空\n{% endspoiler %}","tags":["西尔格德心理学导论"],"categories":["爱好心理学"]},{"title":"心理学的主要理论","url":"/J92HJT/","content":"\n{% spoiler 生物心理学 %}\n 生物心理学家（生理心理学家）\nbiological psychology\nbiological paychologists\n\n做什么\n试图发现生物过程与行为间的关系\n\n {% endspoiler %}\n\n{% spoiler 实验心理学 %}\n实验心理学家 (行为学家和认知心理学家)\nexperimental psychology\nexperimental paychologists\n\n做什么\n使用实验方法研究人们（及其它动物）如何反应感觉刺激、知觉这个世界、学习与记忆、推理以及情绪反应\n\n {% endspoiler %}  <!--more-->\n\n{% spoiler 发展心理学 %}\n 发展心理学家\ndevelopmental psychology\ndevelopmental psychologists\n\n做什么\n关注人类的发展，以及从出生到老死，塑造人类行为的因素\n\n {% endspoiler %}\n\n{% spoiler 社会与人格心理学 %}\n ①社会心理学家、②人格心理学家\nsocial and personality psych-ology\nsocial psychologists\npersonality psychologists\n\n做什么\n①了解人们如何知觉与解释它们的社会世界，以及他们的信念、情绪与行为如何受真实或想象中存在的他人所影响。                                  \n②研究如何定界出个人与世界独特互动方式的思想、情绪与行为\n\n区别\n两个领域有重叠\n他们一方面对个别差异感兴趣，一方面也试图整合所有心理历程以对个体提出完整的解释\n\n {% endspoiler %}\n\n{% spoiler 临床及咨询心理学 %}\n ①临床心理学家、②咨询心理学家\nclinical and counseling psychology\nclincal psychologists\ncounseling psychologists\n\n做什么\n①将心理学的原则运用在情绪和行为问题的诊疗上。              \n②处理较不严重的问题，工作性质与临床心理学家相当接近\n\n {% endspoiler %}\n\n{% spoiler 学校和教育心理学 %}\n ①学习心理学家、②教育心理学家\nschool and educational psychology\nschool psychologists\nschool psychologists\n\n做什么\n①评估儿童的学习和情绪问题    \n②擅于学习和教学\n\n {% endspoiler %}\n\n{% spoiler 组织心理学及工程心理学%}\n ①组织心理学家（工业心理学家）、②工程心理学家（人因工程师）\norganizational and engineering psychology\norganizational psychologists\nengineering psychologists\n\n做什么\n①为某一特别公司工作（为特别的工作选择最合适的人或设计能增加合作与团队关系的结构）             ②致力于改善人——机器关系。（提高人的舒适感）\n\n {% endspoiler %}","tags":["西尔格德心理学导论"],"categories":["爱好心理学"]},{"title":"心理学与生物学观点间的关系","url":"/M77C83/","content":"\n行为观点、认知观点、心理分析观点和主观观点都依赖于纯粹心理学概念（知觉、无意识和归因等）\n而这些观点会对相同现象提出不同的解释，却一致同意这些解释应位于心理学层次。但生物观点不同，除了引用心理学概念之外，生物观点也采用生物学和其它生物支派的概念（神经传导物质①、荷尔蒙②）。但是两者之间仍有一种直接联系的方式。就是尝试以生物学中与生理学相似的情况来解释心理学概念和原则。【心理学的研究发现、概念与原则可以指引生物学者的研究工作。】<!--more-->\n\n**还原论**  指将心理学概念简化为生物学概念。\n\n以心理和生物两种层次来了解心理现象:\n\n------\n\n{% markmap 100px %}\n# 两者互补\n\n## 生物分析\n\n- 透过生物分析知道心理学概念如何在脑中执行\n\n\n## 心理学\n\n- 心理学研究发现可以指出生物学研究方向\n\n{%endmarkmap%}\n\n------\n\n","tags":["西尔格德心理学导论"],"categories":["爱好心理学"]},{"title":"当代心理与行为神经基础","url":"/2N13CX5/","content":"\n{% spoiler 当代心理学观点 %}\n\n心理学观点：一种观察心理学议题的方式或取向。\n\n任何心理学议题都可以根据不同的观点来加以研讨。\n\n心理学许多议题，是需要综合多种观点，采取**折中取向**。\n\n{% endspoiler %}\n\n**生物观点**\n心理现象：原则上都以某种方式与脑部及神经系统的活动相对应。\n**生物取向**(biological perspective)的研究意义，在于区辨出行为和心理现象下的生物神经过程。<!--more-->\n**行为观点** 聚焦于可以观察的刺激与反应上，并认为几乎所有的行为都是条件作用与强化作用的结果。\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E5%BF%83%E7%90%86%E5%AD%A6%E8%A7%82%E7%82%B9%20(%E6%89%8B%E6%9C%BA).png)\n\n**认知观点** 部分系回归于心理学的认知基础，部分则是对行为论观   点倾向忽略人类复杂的活动（计划、做决定和沟通）的狭溢所作出响应。【现在的认知研究也关注（知觉、记忆、推理、决策、解决问题的心理过程）】\n\n**现代认知研究不同于19世纪以内省法为基础的认知研究**。而是在假设作为前提：\n\n1. 唯有研究心智历程才能完全了解有机体的所作所为\n2. 心智历程的研究可着眼于对特殊行为的客观观察，但以内在心智历程的观点来加以解释。\n\n------\n\n{% markmap 100px %}\n\n# 计算机(心灵比拟)处理方式\n\n## 选择\n\n## 比较\n\n## 与记忆中其他信息\n\n- 结合\n- 转换\n- 重新排列\n\n{% endmarkmap %}\n\n------\n\n**心理分析观点**  的基本假设是：大多数行为的产生来自无意识过程（unconscious process），即人们不自知但却可影响其行为的思想、恐惧和欲望等。必须以某种方式加以处理，禁止这些冲动，只是强迫让它们由意识进入无意识，但是它们不会消失，会以情绪问题、心理疾病症状或社会认可的艺术和文学活动方式表现出来。\n<font color=#6940A5>注：弗洛伊德认为人类与动物一样受到基本本能的驱使。此论点并未广为人类心理学者所接受，但是与某些生物学者以及研究动物攻击行为的心理学者的观点一致。</font>\n**主观论者的观点** 是主张人类行为是他所知觉的世界，而非客观世界的函数。\n\n与认知论同样都是源自格式塔的传统而对抗行为论的狭隘论点。虽于认知论同源，但主观论更普遍出现在社会与人格心理学领域中，并且认为，要了解人类的社会行为，必须紧紧扣住人们自己“对情境的定义”而这种定义会因文化、个人过去经历与当时的情绪状况而异。\n\n<font color=#D4710D>【这种观点（主观论）最为开放，会受到文化、个别差异，以及动机与情绪的影响】</font>\n\n<u>主动构建自己主观现实的理念，有赖内省法。当然主观论者并非完全依赖主观的自我报告，因为假设人们 无法看到个人建构的主观现实。</u>而这就是——\n**朴素的现实主义**（naive realism）即是指人们会倾向于将自己构筑好的、主观的现实，理解为忠实地表现了客观世界。\n\n{% table _data/ConceptSummaryTable.json 名称,概念 %}\n\n{% spoiler ①特质归因%}\n\n概念：\n描绘人们在考察某些行为或后果的原因时高估倾向性因素（谴责或赞誉他人）、低估情景性因素（谴责或赞誉环境）的双重倾向。\n基本归因错误或者基本归因偏差是指在对他人行为进行归因的时候，往往会倾向于把别人的行为归因为其内在因素，而低估了情境因素的影响\n\n基本归因错误产生原因：\n最主要的一个原因就是，与其他的环境因素相比，行为者的行为是最容易观察的信息。个人的一言一行、一举一动都很容易被注意到，而社会环境、社会角色、情境压力等外部条件则难以引起注意，于是，我们就忽视了这些外部因素的作用，而过多地强调个人自身的原因。\n此外，还有一个可能的原因就是，我们有一种基本的信念，觉得个人应该对自己的行为负责，于是，在分析行为的原因时，我们就会追溯个人自身的原因。比如，我们倾向于认为一个人的生活状况与自己的努力奋斗有很大关系，所以，当我们看见一个人生活拮据时，可能会想：“为什么你不勤奋一点儿呢！”\n\n{% endspoiler %}","tags":["西尔格德心理学导论"],"categories":["爱好心理学"]},{"title":"关键思考问题二","url":"/2P9J50X/","content":"\n1.过去各种心理学研究取向对人性的假设是什么？\n\n{% spoiler 答%}\n从一开始的**先天与后天**（）到观察记录自己的知觉、思想与感受的本质的**内省法**再到**结构主义**的心理结构（构成）与**功能主义**（如何运作，使得有机体可以适应其环境）了解心理动态、流向和个人特质。接着就是**行为主义**（所认为的所有的行为都是条件作用的结果，而环境借由强化特殊习惯塑造成我们的行为）。**格式塔主义**的知觉以及**心理分析**的无意识概念。\n{% endspoiler %}\n\n2.这些基本假设中，哪些研究取向间是兼容的？哪些又是相左的？\n\n{% spoiler 答 %}\n\n内省法和格式塔主义、功能主义相兼容。先天和后天相左。（不确定）\n\n{% endspoiler%}\n\n<!--more-->","tags":["西尔格德心理学导论"],"categories":["爱好心理学"]},{"title":"心理学20世纪后期的发展","url":"/36WR13N/","content":"\n二战后人们对心理学的兴趣日增，加借以进性研究的复杂工具和电子设备的发展，使更多问题可被检验，证明早期的理论取向太受限制。此观点在50年代计算机发展后被强化。\n\n50年代末，西蒙（HerbertSimon）和同事发表一系列优良的研究，并指出心理现象可以利用计算机加以仿真（simulated）。<!--more-->\n\n许多旧的心理学议题以**信息处理模式**（information-processing models）重新出现。这使得人类可以被视为一个信息处理器，提供一个比行为论更具动力性的心理学取向。而且使得某些格式塔心理学与心理分析理念，能得到跟精确的陈述。\n\n早期有关心理本质的观念，可以被具体化并以实际数据验证。Eg：可将记忆的运作现象成类似计算机存取信息的过程。\n\n另一个影响心理学观点的因素式近代语言学的发展——“了解及说一种语言”的心理结构理论化。而这个研究的先驱是乔姆斯基（Noam Chomsky）1957年出版的《句法结构》提供了第一个重要的语言心理分析，并促进了语言心理学（psycholinguistics）领域的快速发展。\n\n**神经心理学**有许多关于脑以及神经系统的发现提示了生物神经事件和心理历程间有明确的关联。而**生物药物技术**的进步加速了对这种关系的研究。<u>**斯佩里（Roger Sperry）**</u>的研究显示了脑部某些区域和特定的思考及行为历程的关联性，在1981年获得诺贝尔奖\n\n信息处理模式、语言心理学、神经心理学的发展，为心理学提供了一种高度认知取向的研究方法。主要关心的是对心理历程和心理结构的科学分析，认知心理学并不局限于思考和知识。（它【认知心理学】扩展到心理学的所有领域，包括知觉、动机、情绪、临床心理学、人格和社会心理学）\n\n20世纪，心理学的关注焦点形成一种循环：**在排拒意识经验，认为他是一种不当的科学研究而转向行为的研究后，心理学家再次建构心灵的理论（强有力的新工具）**\n\n小结：\n\n{% spoiler 小结%} \n\n1.心理学的根源可追溯到公元前上四百年。有关人类心理学最早的争论之一即聚焦于 “人类的能力是天生的还是通过经验而获得的”这个问题上（就是所谓先天与后天的争论）\n\n2.科学心理学诞生于19世纪末，当时主张心灵与行为可作为科学分析的主题，而心理学的第一间科学实验室即由冯特（Wilhelm Wundt）在1879年创设于莱比锡大学。\n\n3.20世纪心理学的早期学派有结构主义、功能主义、行为主义、格式塔心理学及心理分析\n\n4.20世纪心理学后期的发展：包括信息处理论、心理语言学以及神经心理学。\n\n{% endspoiler %}\n\n","tags":["西尔格德心理学导论"],"categories":["爱好心理学"]},{"title":"5种停止厌恶任务列表的方法","url":"/NR9XAW/","content":"1.学习像Candy Crush一样珍视您的任务列表\n      这个任务列表项目中的第一步是沉迷于写下您的任务后大脑清晰的舒适感。\n2.为未来懒惰的您自己写下任务列表\n      好的任务列表是详细的。您的大脑会容易过滤相对概括的内容，比如“食品”或者“兽医”，因为您根本不知道从何做起。<!--more-->\n3.任务没有感情，尽管厚此薄彼\n     您的列表应该呈现一个阶级架构，您可以将事情按必须要做和如果有时间会想去做来划分。\n4.你写下它，但是您也可以更改它\n      给您自己更多空间来从容应对，这样您才可以让自己一直保持动力，无论发生了什么。\n5.像奖杯一样对待您的任务列表\n      已完成的任务列表可以为您铺垫前往重大成功的道路，或者仅仅是帮助您对当天的效率感到满意。\n一封来自todolist 的邮件","categories":["笔记"]},{"title":"科学心理开端","url":"/140WZGJ/","content":"所谓的科学心理则通常被认为创立于19世纪末，即冯特（Wihelm Wundt）与1879年在德国莱比锡大学创设第一座心理实验室。创立心里实验室的信念：心理与行为，一如行星、化学物质或人类器官，可以称为科学分析的主题。\n\n冯特个人主要研究与感觉相关，尤其是视觉方面，也研究\n\n**内省法**（introspection）指观察记录自己的知觉、思想与感受的本质。内省法源自哲学。<u>而冯特在此感念上添加了新的维度（内容）：单纯的自我观察是不够的，必须再辅以实验。</u><!--more-->\n\n冯特是实验是有系统的变动刺激的一些物理维度（强度），然后运用内省法来确定，物理改变如何影响被式所意识到的刺激经验的改变。\n\n内省法的研究在某些心理事件是行不通的，即使经过密集的训练，在感觉经验上仍有相当不一致的内省结果，从这些差异很难得到结论。因此内省法已非当前认知观点的主流。\n\n**结构主义与功能主义** 19世纪研究者以分析复杂组合物（分子）为其元素（原子）的方法，在化学和物理学上有很大的进步。而这些成就鼓舞了心理学者探索由更复杂经验所组成的心理元素。其中在美国的主要支持者<u>**铁钦纳（E.B Titchener）**</u> 一个在康奈尔大学接受冯特训练的心理学家，由于其目标是阐明心理结构，铁钦纳便使用**结构主义**（structuralism）一词来描绘此派心理学。\n\n但由于结构主义纯粹分析特征激起很强烈的反对声，哈弗大学的心理学家詹姆士（William James）【**研究心灵如何运作，使得有机体可以适应其环境称功能主义（functionalism）**】认为强调分析意识元素应少些，应多加强调了解它的动态、流向和个人特质。\n\n<font color=red>19世纪的心理学家主要兴趣来源于达尔文的进化论所引起的议题。</font>\n\n两者均认为心理学是一门有关意识经验的科学。但到了20年代二者被三种新兴学派取代：行为主义、格式塔心理学和心理分析。\n\n**行为主义**   而三种新学派中，**行为主义学派**对北美的科学心理影响最大。其建立者华生（John B. Watson），对其时代以意识经验作为心理学的中枢的传统进行抗争。为了使心理学成为一门科学，认为心理学的数据必须能够公开检验。\n\n 🌀（行为主义学者）认为几乎所有的行为都是条件作用的结果，而环境借由强化特殊的习惯，塑造成我们的行为\n\n【俄国的巴普洛夫（Ivan Pavlov）在条件作用反应上的研究被认为是行为主义重要的研究领域。但是在行为主义兴起前，美国对条件作用反应研究方法很有限，华生对后续的发展由重大贡献】\n\n行为主义倾向于刺激与反应来探讨心理学现象（刺激-反应（S-R）注：S-R本身并非一种理论或观点。一组用来沟通心理学信息用语（术语））\n\n**格式塔主义**   1912年在德国出现。格式塔（Cestalt）在德语单词中的意思是形式（form）或构图（configruation），是指韦特海默（Max Wertheimer）和考夫卡（Kurt Koffka）与柯勒（Wolfgan K o hler）所采取的研究取向\n\n而格式塔学派主要研究兴趣是（运动的、颜色、大小等）知觉（以知觉为中心诠释有关学习、记忆与问题解决等现象的研究）。他们认为（知觉经验决定于刺激所形成的组型以及经验的组织。）【并为认知心理学研究奠定了良好的基础】\n\n【相对于背景所呈现的物体形象，也是整体刺激组型中的一部分。整体并非部分的总合，因为整体式依各部分间的关系而定】\n\n注意：1946年的阿希将格式塔理念延伸到人的知觉上认为人们是整体的知觉而非只看到各自独立的部分。（勒温[Kurt Lewein]、阿希[Solomon Asch]、海德[Fritz Heider]）——> 赋予输入刺激的意义与结构的，是一中自动化、且意识觉知之外的历程。\n\n**心理分析**   大约在世纪交替到20世纪由弗洛伊德首创的即使人格也是心理治疗方法的一种理论。而核心是**无意识**概念 ——指我们无法察觉的思想、态度、冲动、欲望、情绪与动机。弗洛伊德会根据**自由联想**的方法，请被试说出闪现在心里的任何事物，借此将意识的欲望带到觉知状态。\n\n弗洛伊德理论中，隐藏的无意识欲望大多涉及性与攻击。但并未获得广泛的接受，当代也并未全然接受这个理论，而是倾向于同意，人们的想法、目标与动机有时是在意识觉知之外运作的。","tags":["西尔格德心理学导论"],"categories":["爱好心理学"]},{"title":"先天论与后天论","url":"/3BX2BGS/","content":"最早的争论之一：即人类的能力是先天具有的还是经由后天经验获得的。\n\n**先天论**（nature view）认为人是带着先备的知识和对现实的了解来到未来。\n\n17世纪的笛卡尔（因其有关身体可如同机器一般被研究的新概念而著名）支持先天论观点\n\n**后天论**（nurture view）认为知识的获得要通过经验及与外在世界的交互作用。<!--more-->\n\n17世界的英国哲学家洛克（John Locke）认为人生下来是一白板（tabula rasa）借着在世的经验写下所有的知识和理解。而这一观点产生了**联想主义心理学** （associationalist psychology），联想论者否认天生概念或心理能力。而认为充满心灵的各种概念是通过知觉进入，再以相似、对照等原则而相互关联。（有关记忆和学习的研究与早期的联想论有关）\n\n注：大多数心理学家会采取整合的观点，承认生物历程会影响思想、感受与行为，经验也会留下痕迹。因此当前的问题不在于塑造人类心理的是先天还是后天，而在于先天后天二者如何共同发挥影响力。","tags":["西尔格德心理学导论"],"categories":["爱好心理学"]},{"title":"心理学的历史渊源","url":"/50672/","content":"古希腊的伟大哲学家，苏格拉底、柏拉图与亚里士多德\n\n意识 是什么？人是理性还是非理性的？所谓的选择自由真的存在吗？\n\n探讨心灵与心智历程的本质，是心理学认知观点的关键成分。而其它心理学问题则讨论人类身体与行为的本质\n\n“医学之父”--- 希波克拉底（Hippocrates）主要研究有机体功能的生理学，对大脑控制身体各种器官的历程进行了许多重要的观察研究 <!--more-->","tags":["西尔格德心理学导论"],"categories":["爱好心理学"]},{"title":"关键思考问题一","url":"/42811/","content":"1.回顾网络上或第四页所列报纸上包含心理学研究发现的一些标题，你相信这些论点吗？为什么？\n\n- 新式心理治疗可促进回复压抑的记忆\n- 焦虑可经由脑波进行自我调节与控制\n- 发现心电感应的证据\n- 婴儿在假寐时学习说话的语音\n- 情绪稳点度与家庭大小密切相关\n- 含糖饮料可能提升考试成绩\n- 直觉冥想法能够延长平均寿命\n- 过分重视外表会损及心智\n  <!--more-->\n{% spoiler 答 %}\n应抱有怀疑态度，一方面有没有足够的证据来支持这一论点。另一方面论点是否符合科学证据\n{% endspoiler %}\n\n2.你如何得知何时该相信一则新闻报道？在哪接受该心理论点为事实前，你还需要知道什么信息？\n{% spoiler 答 %}\n根据多方信息来证明这则新闻报道是不是具有真实性。消息的来源\n{% endspoiler %}","tags":["西尔格德心理学导论"],"categories":["爱好心理学"]},{"title":"心理学领域","url":"/36361/","content":"\n**心理学界定为**：对行为与心智历程的科学研究。（心理学的多样性）\n\n五种代表性问题：\n\n**面部伤害和面孔辨识**（brain damage and face recognition）\n\n某些脑部区域受到伤害，会失去某些能力，但其它区域却正常；面部辨识能力的丧失被称为**面部辨识困难症**（prosopagnosia） <!--more-->\n\n**对人作特质归因**（attributing traits to people）\n\n在解释他人行为时，人们倾向于高估人格特质的因果作用，而低估了情境因素的影响—称为**基本归因错误**（fundamental attribution error）\n\n在解释自己行为是，我们常会高估，而非低估情境的成因\n\n**童年失忆症**：事实上，没有人能忆起3岁以前的事\n\n**媒体暴力对儿童攻击的作用**（effects of media violence on children's aggression):观看暴力电视会影响儿童行为。让儿童更具有攻击性（9岁观看越多的暴力节目，19岁是也越可能更具有攻击性【此10年后数据不是最新数据】）\n\n**小结：**\n{% spoiler 小结 %}\n心理学触及我们日常生活许多方面，且会影响法律与公共政策。\n\n欲评估有关心理学的新论点，你必须知道有哪些心理学事实已被确证以及科学证据的标准为何\n\n心理学是对行为与心智历程的科学研究。\n\n心理学的领域相当广泛，包含诸如面孔辨识、社会判读、记忆、肥胖症、暴力及更多的议题\n{% endspoiler %}\n","tags":["西尔格德心理学导论"],"categories":["爱好心理学"]},{"title":"引子","url":"/10503/","content":"\n学习理论中的一条基本原则：做出某种行为后得到酬赏，则该行为会被强化。\n\n酬赏具有强大影响力的原则被称为**效果律**（law of effect）\n\n在解释个人行为时，过于强调显见的情境原因反而忽略个人成因称作**过度辩护效应（overjustification）** <!--more-->\n\n**分辨主张的真伪：**\n\n**1.知道那些心理事实已确证的事实相互矛盾，如果有矛盾之处，那就必要加以审慎考虑**\n\n**2.必须知道足以令人信服一项新主张或新发现所必备的证据类型，这样才能解决那些支持新主张的论点是否符合科学证据的一般标准，如果不符合同样就有必要保持怀疑态度。**\n\n回顾心理学知识的现状。\n\n检验研究的本质（检视心理学家如何设计研究程序以提供强而有力的证据，来支持或推翻一项假设，进而明白支持一项新主张所需要的证据类型）","tags":["西尔格德心理学导论"],"categories":["爱好心理学"]},{"title":"西尔格德心理学导论大纲","url":"/55288/","content":"# 大纲\n\n**贯穿全书的三个观点：**（生物学、进化、文化）\n1、加强行为的生物学基础\n2、在心理学研究中增加进化观点。\n3、强调文化影响及其多样性\n并在不同学派的增加“主观论者的观点”。 <!--more-->\n\n***\n\n{% markmap 400px %}\n\n# 西尔格德心理学导论大纲\n\n## 基础部分\n\n### 心理学的本质\n\n### 心理学的生物基础\n\n### 心理学的发展\n\n#### 增加儿童心理学基础上有关认知论发展\n\n#### 扩展和更新青春期发展的范围\n\n#### 增加遗传对气质影响信息\n\n## 基本心里活动\n\n###  感觉过程\n\n#### 对光和心理物理的研究扩展\n\n####  增加信号检测论\n  \n### 知觉\n\n####  用生态学的观点解释知觉的作用，将错觉并入知觉的恒常性研究\n\n####  注意研究被扩展为独立部分\n\n### 意识\n\n####  以分心或失去意识的情景来对意识进行解释，认为它是对自己内外环境和各种行为活动的监控，并由当时的知觉、思维和情感构成\n\n####  酗酒的产生、其它文化差异和性别差异\n\n### 学习与条件反射作用\n\n####  抑制性条件反射③\n\n### 记忆\n\n#### 三个阶段与三个储存区分与解释是①\n\n##### 三个存储系统\n\n###### 编码\n\n- 指对来自外部的信息进行最初加工，在脑海里形成深刻印象；\n  \n###### 存储\n\n- 指信息被你编码后，会在你脑海里保存一段时间；\n  \n###### 提取\n\n- 指从记忆这个大仓库里，将你需要使用的特定信息提取出来。\n  \n##### 三个阶段\n\n###### 瞬时记忆（感觉记忆）\n\n- 指外界刺激以极短的时间一次呈现后，信息在感觉通道内迅速被登记并保留一瞬间的记忆。\n \n###### 短时记忆\n\n- 指外界刺激以极短的时间一次呈现后，保持时间在1分钟以内的记忆。\n \n###### 长时记忆\n\n- 指外界刺激以极短的时间一次呈现后，保持时间在1分钟以上的记忆。\n  \n#### 记忆的建构性及对实际生活的影响\n\n### 语言和思考\n\n#### 增加神经基础\n\n#### 在推理和决策中指出表象的作用\n\n#### 在演绎与归纳的解释中用脑内的神经机制加以区分\n  \n## 社会心理\n\n### 社会影响\n\n#### 以情境起重要作用的观点，对社会助长作用、旁观者效应、顺从等几个方面做现代化解释\n\n#### 增加包含不和谐理论与自我知觉理论的“自我辩护②（self-justification）”\n\n### 社会认知\n\n#### 依据思维的双进程模型的观点，阐述印象的形成、态度和人际吸引等问题\n\n#####  自主思维\n\n#####  控制思维\n\n#### 解释刻板印象的形成及其文化印象\n\n#### 增加对偏见与刻板印象的控制\n\n#### 团体思维中保持团体多样性的积极意义\n\n## 心理特征\n\n### 动机\n\n#### 一种是行为加强并给以方向的心理状态，保持体内平衡是其主要的内在原因\n\n#### 并以“想要与喜爱区分”\n\n#### 增加与性别有关的过度节食与过胖等健康问题心理学解释\n\n### 情绪（从认知评价开始）\n\n#### 主观体验、内部躯体变化等多种成分构成\n\n#### 讨论情绪与心境的区分\n\n#### 强调积极情绪和面部表情在生活交往中的作用\n\n#### 增加有关情绪调整及性别与文化差异部分\n\n### 智力\n\n#### 智力测验的历史发展和当代智力理论\n\n#### 讨论智力测验编制中的偏向性问题\n\n#### 有关智力理论中文化问题的讨论\n\n### 人格\n\n#### 增加人格的进化理论并讨论了人格的遗传问题\n\n#### 人格评估\n\n## 心理健康与心理障碍\n\n### 压力、健康及应对\n\n#### 各种压力事件的产生，到应激反应生理和心理因素及应对技巧（以文化问题讨论）\n\n### 心理疾病\n\n#### 以一个变态心理实例，在焦虑障碍、心理障碍和精神分裂症部分强调脑成像研究\n\n#### 在界定“变态性”时需要强调不同文化下的常模讨论\n\n### 心理异常的治疗\n\n#### 以一个精神分裂症患者从多种治疗方法中获益说明治疗的作用\n\n#### 药物治疗对心理障碍的作用（草药的治疗及文化差异）\n\n{% endmarkmap %}\n\n***\n\n**注：**\n①记忆过程的三个步骤，并不是相互独立的，通常在为新信息编码时，需要提取存储在脑海里的旧信息\n②生活中的自我辩解\n{% spoiler 生活中的自我辩解 %}\n\n关键词：自我辩护、认知失调，印象管理、自我认知、自尊、自我概念\n**自我辩护的心理机制**\n<font color=#00868B><u>**认知失调理论**——指个体认识到自己的态度之间、或者态度与行为之间存在着矛盾。</u></font>通常人们减少认知失调的方法有三种：\n1.**改变认知**。如果两个认知相互矛盾我们便简简单单的改变其中的一个认知，使他和另一个认知相一致\n2.**增加认知**。如果两个不一致的认知导致了失调，那么失调程度可能有增加一个或更多的协调性认知来减少。\n3.**改变重要性**。因为一致和不一致的认知必须根据它们的重要性来加权，因此可以通过该变认知的重要性来减少失调。\n<font color=#00868B>作为行动者，我们往往会把自己的行为归因于外在的或情景的因素，也即做**外在归因**。</font>这是一种归因偏差，而如果一个人不能理性正确的看待自己的认知与行为的正确性，就会找各种理由来进行自我辩护，有时候明显自己的行为是错误的，也坚持自己是正确的，把原因推到其他人或物的身上，这样的话就很容易造成生活中的麻烦。\n\n{% endspoiler %}\n③什么是抑制性条件反射？（第七章）\n④什么是“双面论证”？（seeing both sides）\n 陈述自己观点时，将利弊得失两面同时谈及，加以比较，突出有利一面，让对方再思考权衡\n⑤歇斯底里发作（ataque de nervios）---常见于拉丁文化、近似焦虑症症状\n⑥创伤后应激障碍（PTSD）\n⑦弗罗伊德理论\n⑧记忆\n{% spoiler 记忆的三个系统及其特点 %}\n\n　如果把记忆看作是人脑对输入的信息进行编码、储存和提取的过程，那么可以把信息的编码、储存和提取的方式的不同，以及信息储存时间长短的不同，可以将记忆分作<font color=＃40826D>瞬时记忆</font>、<font color=fuchsine>短时记忆</font>和<font color=＃43b3ae>长时记忆</font>三个系统。\n\n　**(一)瞬时记忆：**\n\n<font color=#8B3A3A>瞬时记忆的概念：美国心理学家斯波林的实验证明，刚看完时能记住的比较多，但保持的时间比较短，斯波林将刚看完卡片能保持很短时间的记忆叫瞬时记忆。</font>\n　瞬时记忆又叫感觉记忆或感觉登记，是指外界刺激以极短的时间一次呈现后，信息在感觉通道内迅速被登记并保留一瞬间的记忆。一般又把视觉的瞬时记忆叫图象记忆，把听觉的瞬时记忆叫声象记忆。\n\n　**瞬时记忆的特点：**\n\n  1、瞬时记忆的编码方式，即瞬时记忆记住信息的方式，是外界刺激物的形象。所以具有鲜明的形象性。\n\n　2、瞬时记忆的容量很大，但保留的时间很短。容量为9-20比特，时间4秒以内。图象记忆0.25-1秒，声象记忆可以超过1秒,不会长于4秒。如果对瞬时记忆中的信息加以注意，或者说当意识到瞬时记忆的信息时，信息就被转入短时记忆了，否则，没有注意到的信息过1秒钟便会消失，也就是遗忘了。\n\n　**(二)短时记忆：**\n\n<font color=#8B3A3A>短时记忆的概念：指外界刺激以极短的时间一次呈现后，保持时间在1分钟以内的记忆。</font>\n\n　**短时记忆的特点：**\n\n   1、短时记忆的容量有限，一般为7±2，即5-9个项目，这也就是平常我们所说的记忆广度。心理咨询师为扩大短时记忆的容量，可采用组块的方法。\n\n　2、语言文字的材料在短时记忆中多为听觉编码，即容易记住的是语言文字的声音而不是它们的形象，非语言文字的材料主要是形象的记忆，而且视觉记忆的形象占有更重要的地位，此外，也有少量的语义记忆。\n\n　3、短时记忆中的信息是当前正在加工的信息，因而是可以被意识到的。短时记忆中既有从瞬时记忆中转来的信息，也有从长时记忆中提取出来的信息，它们都是当前正在加工的信息，所以短时记忆又叫工作记忆。\n\n　4、短时记忆的信息经过复述可能转入长时记忆系统。\n\n**(三)长时记忆：**\n<font color=#8B3A3A>长时记忆的概念：指外界刺激以极短的时间一次呈现后，保持时间在1分钟以上的记忆。</font>\n\n　**长时记忆特点：**\n\n  1、长时记忆的容量无论是信息的各类或数量都是无限的。\n\n　2、长时记忆的编码有语义编码和形象编码两类。\n\n　3、长时记忆中储存的信息如果不是有意回忆的话，人们是不会意识到的。只有当人们需要借助已有的知识和经验时，长时记忆储存的信息再被提取到短时记忆中，才能被人们意识到。\n\n　4、长时记忆的遗忘或因自然的衰退，或因干扰造成。干扰又分为前摄抑制和倒摄抑制两种。前摄抑制是指先前学习的材料，对识记和回忆后学习材料的干扰作用。倒摄抑制是指后学习的材料，对识记和回忆先前学习材料的干扰作用。系列位置效应是干扰对记忆效果造成影响的非常明显的例子。\n　系列位置效应是记忆材料在系列中所处的位置对记忆效果发生的影响。系列两头比系列中间的材料记忆效果好，这就是系列位置效应。系列开头比系列中间的材料记得好又叫首因效应或首位效应。培训系列末尾比系列中间的材料记得好又叫近因效应或新近效应。在我们平时背资料时，对于资料内容的开头和结尾记忆深刻就是这个原因。\n\n{% endspoiler %}\n","tags":["西尔格德心理学导论"],"categories":["爱好心理学"]},{"title":"升级与更新包","url":"/30109/","content":"随着hexo5.0的发布，打着尝试最新功能的心，准备升级看看。之前尝试过升级，但都已失败告终。废话不多说直奔主题。\n\n首先推荐一个npm包——`npm-check-updates`。\n它是查找比你的package.json所允许的更新版本的软件包依赖关系。<!--more-->\n\n### **安装**\n\n`npm install -g npm-check-updates`  \n\n### **使用方法**\n\n**显示当前目录下项目的任何新的依赖关系。** \n\n```bash\n$ ncu\nChecking package.json\n[====================] 5/5 100%\n\n express           4.12.x  →   4.13.x\n multer            ^0.1.8  →   ^1.0.1\n react-bootstrap  ^0.22.6  →  ^0.24.0\n react-a11y        ^0.1.1  →   ^0.2.6\n webpack          ~1.9.10  →  ~1.10.5\n\nRun ncu -u to upgrade package.json\n```\n{% note info no-icon %}\n\n<font color=red>红色</font>=主要升级(和所有[主要的零版本](https://semver.org/#spec-item-4))\n<font color=cyan>青色</font>=小规模升级 \n<font color=green>绿色</font>=补丁升级\n\n{% endnote %}\n\n**升级一个项目的包文件:**\n\n{% note danger no-icon %}\n\n确保你的包文件处于版本控制中，并且所有的修改都已经提交。这将覆盖你的包文件。\n\n{% endnote %}\n\n```bash\n$ ncu -u\nUpgrading package.json\n[====================] 1/1 100%\n\n express           4.12.x  →   4.13.x\n\nRun npm install to install new versions.\n\n$ npm install      # update installed packages and package-lock.json\n```\n**检查全局包:**\n\n```bash\nncu -g\n```\n\n### **注意事项：**\n\nhexo如果是4.x版本升级会报以下错误，需要修改`_config.yml`\n\n```bash\nINFO  Validating config\nWARN  Deprecated config detected: \"use_date_for_updated\" is deprecated, please use \"updated_option\" instead. See https://hexo.io/docs/configuration for more details.\n...\n```\n修改如下：\n```bash\n_config.yml\n# Deprecated\nexternal_link: true|false\n\n# New option\nexternal_link:\n  enable: true|false\n\n# Deprecated\nuse_date_for_updated: true\n\n# New option\n# https://hexo.io/docs/configuration#Date-Time-format\nupdated_option: date\n```\n了解更多hexo5.0版本的改动请参考[hexo发布的新闻](https://hexo.io/news/2020/07/29/hexo-5-released/)\n\n了解更多的npm-check-updates请访问[Github](https://github.com/raineorshine/npm-check-updates)或者[npm](https://www.npmjs.com/package/npm-check-updates)\n\n","categories":["笔记"]},{"title":"自动初始化Gitalk评论","url":"/42664/","content":"\n ### 第一步：创建js文件\n\n  在根目录下新建一个`gitalk.init.js`文件\n\n{% note default  no-icon %}\n\n如果名字感觉太长可以自己命名\n\n{% endnote %}\n\n### 第二步：安装依赖包\n\n```cmd\nnpm install cheerio --save\nnpm install request --save\nnpm install xml-parser --save\nnpm install yamljs --save\nnpm install hexo-generator-sitemap --save\n```\n\n{% note success  no-icon %}\n\n**一步到位**\n\n npm  install  cheerio request xml-parser yamljs hexo-generator-sitemap  --save\n\n{% endnote %}\n\n<!--more-->\n\n###  第三步：修改站点根目录下的`_config.yml`添加如下代码\n\n```yaml\n# hexo sitemap网站地图\nsitemap:\n  path: sitemap.xml\n  rel: false\n  tags: true\n  categories: true\n```\n\n{% note danger no-icon %}\n\n把_config.yml站点网址的url改成https\n\n{% endnote %}\n\n ### 第四步：复制代码\n\n根据需求修改<font color=red>config</font>里的内容\n\n```js\nconst request = require(\"request\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst url = require(\"url\");\nconst xmlParser = require(\"xml-parser\");\nconst YAML = require(\"yamljs\");\nconst cheerio = require(\"cheerio\");\nconst crypto = require('crypto');\n// 根据自己的情况进行配置\nconst config = {\n    username: \"name\", // GitHub 用户名\n    token: \"token\",  // GitHub Token\n    repo: \"blogtalk\",  // 存放 issues的git仓库\n    // sitemap.xml的路径，gitalk.init.js放置在根目录下，无需修改，其他情况自行处理\n    sitemapUrl: path.resolve(__dirname, \"./public/sitemap.xml\"),\n    kind: \"Gitalk\",  // \"Gitalk\" or \"Gitment\"\n};\nlet issuesUrl = `https://api.github.com/repos/${config.username}/${config.repo}/issues?access_token=${config.token}`;\n\nlet requestGetOpt = {\n    url: `${issuesUrl}&page=1&per_page=1000`,\n    json: true,\n    headers: {\n        \"User-Agent\": \"github-user\"\n    }\n};\nlet requestPostOpt = {\n    ...requestGetOpt,\n    url:issuesUrl,\n    method: \"POST\",\n    form: \"\"\n};\n\nconsole.log(\"开始初始化评论...\");\n\n(async function() {\n    console.log(\"开始检索链接，请稍等...\");\n    \n    try {\n        let websiteConfig = YAML.parse(fs.readFileSync(path.resolve(__dirname, \"./_config.yml\"), \"utf8\"));\n        \n        let urls = sitemapXmlReader(config.sitemapUrl);\n        console.log(`共检索到${urls.length-1}个链接`);\n        \n        console.log(\"开始获取已经初始化的issues:\");\n        let issues = await send(requestGetOpt);\n        console.log(`已经存在${issues.length}个issues`);\n        \n        let notInitIssueLinks = urls.filter((link) => {\n            return !issues.find((item) => {\n                link = removeProtocol(link);\n                return item.body.includes(link);\n            });\n        });\n        \n        for(let i=0;i<notInitIssueLinks.length;i++)\n        {\n            if(notInitIssueLinks[i].endsWith(\"tags/index.html\"))\n            {\n                notInitIssueLinks.splice(i,1);\n                i--;\n            }\n        }\n\n        if (notInitIssueLinks.length > 0) {\n            console.log(`本次有${notInitIssueLinks.length}个链接需要初始化issue：`);\n            console.log(notInitIssueLinks);\n            console.log(\"开始提交初始化请求, 大约需要40秒...\");\n            /**\n             * 部署好网站后，直接执行start，新增文章并不会生成评论\n             * 经测试，最少需要等待40秒，才可以正确生成， 怀疑跟github的api有关系，没有找到实锤\n             */\n            setTimeout(async ()=>{\n                let initRet = await notInitIssueLinks.map(async (item) => {\n                    let html = await send({ ...requestGetOpt, url: item });\n                    let title = cheerio.load(html)(\"title\").text();\n                    let desc = item + \"\\n\\n\" + cheerio.load(html)(\"meta[name='description']\").attr(\"content\");\n                    let pathLabel = url.parse(item).path;\n                    let label = crypto.createHash('md5').update(pathLabel,'utf-8').digest('hex');\n                    let form = JSON.stringify({ \"body\": desc, \"labels\": [config.kind, label], \"title\": title });\n                    return send({ ...requestPostOpt, form });\n                });\n                console.log(`已完成${initRet.length}个！`);\n                console.log(\"可以愉快的发表评论了！\");\n            },40000);\n        } else {\n            console.log(\"本次发布无新增页面，无需初始化issue!!\");\n        }\n    } catch (e) {\n        console.log(`初始化issue出错，错误如下：`);\n        console.log(e);\n    } finally {\n    \n    }\n})();\n\nfunction sitemapXmlReader(file) {\n    let data = fs.readFileSync(file, \"utf8\");\n    let sitemap = xmlParser(data);\n    return sitemap.root.children.map(function (url) {\n        let loc = url.children.filter(function (item) {\n            return item.name === \"loc\";\n        })[0];\n        return loc.content;\n    });\n}\n\nfunction removeProtocol(url) {\n    return url.substr(url.indexOf(\":\"));\n}\n\nfunction send(options) {\n    return new Promise(function (resolve, reject) {\n        request(options, function (error, response, body) {\n            if (!error) {\n                resolve(body);\n            } else {\n                reject(error);\n            }\n        });\n    });\n}\n```\n\n### 第五步:执行命令\n\n```bash\nhexo clean\nhexo g\nhexo d\nnode ./gitalk.init.js\n```\n\n","tags":["Gitalk"],"categories":["笔记"]},{"title":"刷新DNS缓存命令","url":"/14940/","content":"\n在终端输入 ipconfig/flushdns ，按下回车键确认即可\n\n如果系统提示`已成功刷新缓存`或者`Successfully flushed the DNS Resolver Cache`，则说明清除DNS缓存成功。<!--more-->","categories":["笔记"]},{"title":"Windows访问Linux子系统文件夹","url":"/27102/","content":"\n 当我们处于 Linux 子系统的命令行窗口时，只需输入并执行下面这行命令，我们即可以在 Windows 文件资源管理器中访问和管理 Linux 子系统中我们当前所处的文件路径下的文件：<!--more-->\n\n`explorer.exe .`\n\n提示：在输入和执行以上命令时，请注意，`explorer.exe `和.` `之间有个空格。\n\n<font color=#CE0000>修改文件需要先修改文件权限</font>","categories":["笔记"]},{"title":"Vscode插件与主题","url":"/35300/","content":"插件：\n\n1.**Auto Close Tag** 自动添加HTML/XML关闭标签\n\n2.**Auto Rename Tag** 自动重命名配对的HTML/XML标签\n\n3.**GitLens**  帮助你通过Git blame注释和代码透镜一目了然地可视化代码作者身份，无缝浏览和探索Git仓库，通过强大的比较命令获得有价值的洞察力，等等<!--more-->\n\n4.**Markdown All in One** 所有你需要的Markdown（键盘快捷键，目录，自动预览等）。\n\n5.**Terminal** 直接在文本编辑器中运行终端命令\n\n6.**markmap** 用vscode写脑图\n\n主题：\n   1.**Github Light**\n   主题有两种形式：一个是纯白色背景，一个是灰色背景。\n\n   2.**Brackets Light Pro**\n   主题的外观非常简洁\n\n   3.**Hop Light**\n   具有友好颜色的主题\n\n   4.**Snazzy Light**\n   明亮的环境光条件下表现出清晰鲜明的色彩\n\n   5.**Monokai Light**\n   主题具有鲜艳的色彩 \n\n  <font color=green>不定时更新中.... </font> ","categories":["应用与插件"]},{"title":"欢乐好声音合集","url":"/28541/","content":"\nNO.1 《Hallelujah》 Leonard Cohen 《欢乐好声音》中的大象米娜\n\nNO.2 《Wake Me Up Before You Go Go》Wham!  富二代绵羊的手机铃声。\n\nNO.3 《Under Pressure》 David Bowie/Queen 考拉老板Buster Moon重新振作并决定和小伙伴们再大干一票的背景音乐 <!--more-->\n\nNO.4 《Stay with me》Sam Smith 《欢乐好声音》里面，猩猩强尼演唱 \n\nNO.5 《Firework》Katy Perry “猪妈妈”威瑟斯彭演唱了Katy Perry的《Firework》。\n\nNO. 6 《All of me》John Legend   由塔伦·埃格顿（猩猩）演唱\n\nNO.7 《I’m Still Standing》 Elton John  演唱这首歌的猩猩Johnn\n\nNO.8 《My Way》Frank Sinatra   老鼠麦克  \n\nNO.9 《Don't You Worry 'Bout A Thing》Stevie Wonder  大象米娜\n\nNO.10 《True Colors》Cyndi Lauper  猪妈妈\n\nNO.11 《Kiss From A Rose》 Seal  绵羊试音\n\nNO.12 《Anaconda》Nicki Minaj  浴袍的兔子\n\nNO.13 《Call Me Maybe》Carly Rae Jepsen  艾希\n\nNO.14 《Kira Kira Killer》Kearny Pamyu Pamyu  小熊猫\n\nNO.15 《Shake It Off》Taylor Swift  猪妈妈和猪先生\n\nNO.16 《Golden Slumbers》The Beatles   嗓门Jennifer Hudson演唱","categories":["生活与话"]},{"title":"FreeFileSync同步软件","url":"/18537/","content":"\n[FreeFileSync](https://freefilesync.org/)是一款文件夹对比和同步软件，它可以创建和管理所有重要文件的备份副本。FreeFileSync不需要每次都复制每个文件，而是确定源文件夹和目标文件夹之间的差异，并只传输所需的最低数据量。FreeFileSync是一款开源软件，适用于Windows、macOS和Linux。 <!--more-->\n\n安装完FreeFileSync后桌面会有两个快捷软件\n\nFreeFileSync是主体软件\n\nRealTimeSync是自动化，但需要配合主体软件使用\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/Snipaste_2021-03-07_13-10-45.png)\n\n\n### 第一步：选择需要同步的文件夹。\n\n打开FreeFileSync,点击左侧的“浏览”，选择你想要进行镜像的其中一个文件夹。同样的操作，在右侧添加第二个文件夹 。这样，后面需要进行操作的两个主体就已经设置好了。\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E5%90%8C%E6%AD%A5%E6%96%87%E4%BB%B6%E5%A4%B9_2021-03-03_13-11-32.png)\n\n### 第二步：设置同步规则\n\n点击右上角的绿色 “设置” 符号，选择我们需要的同步配置，点击确定\n\n{% note success %}\n\n**删除文件**\n\n回收站（不推荐）\n\n永久 (删除)    \n\n历史版本（推荐）可以单独放在其它文件夹里最好是新建一个文件夹\n\n{% endnote %}\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E9%95%9C%E5%83%8F_2021-03-03_13-10-12.png)\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E5%90%8C%E6%AD%A5%E8%A7%84%E5%88%99_2021-03-03_13-15-03.png)\n\n### 第三步：设置比较规则\n\n点击左上角的蓝色 “设置” 符号，选择我们需要的比较配置，点击确定\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E6%AF%94%E8%BE%83_2021-03-07_13-39-48.png)\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99_2021-03-07_13-40-28.png)\n\n### 第四步：点击 “另存为批处理作业” 图标\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E9%85%8D%E7%BD%AE_2021-03-03_13-17-25.png)\n\n勾选 “以最小化运行” 和“自动关闭”两项，这样所有操作都是在后台运行，不会打扰我们的工作，否则成功后会有弹窗提示！然后点击“另存为”，将这个批处理任务存储到你能找得到的地方\n\n### 第五步：建立自动同步任务\n\n这里很简单，打开RealTimeSync，直接将刚才存储的批处理文件拖到命令行。\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E7%BA%A2%E8%89%B2%E8%BD%AF%E4%BB%B6_2021-03-07_13-51-09.png)\n\n然后点击开始\n\n------\n\n手动同步\n\n只需要按 `Ctrl + s`保存到你能找得到的地方\n\n点击右上角的同步就可以手动同步\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E6%89%8B%E5%8A%A8%E5%90%8C%E6%AD%A5_2021-03-07_14-13-45.png)\n\n------\n\n{% note warning %}\n\n**注意事项**\n\n1.备份最好选择一个单独的文件夹，不要直接选择盘符下\n\n2.自动同步重启电脑后需要重新手动打开RealTimeSync\n\n3.重启之后需要把存储的自动同步(.ffs_batch)的文件重新拖到命令行中\n\n4.自动同步文件是.ffs_batch \n\n5.手动同步文件是.ffs_gui\n\n{% endnote%}","tags":["软件"],"categories":["笔记"]},{"title":"好用的浏览器插件推荐","url":"/62702/","content":"\n以下是我自用的浏览器插件，实测好用——以下排名不分先后\n\n------\n\nNo1.[AdGuard AdBlocker](https://addons.mozilla.org/en-GB/firefox/addon/adguard-adblocker/?utm_source=addons.mozilla.org&utm_medium=referral&utm_content=search)   \n\n 屏蔽所有广告：视频广告（包括YouTube视频广告）、富媒体广告、不需要的弹窗、横幅和文本广告（包括Facebook广告）。加快页面加载速度，节省带宽，由于缺少广告和弹出窗口。阻止许多间谍软件、广告软件和拨号器安装程序。屏蔽常见的第三方追踪系统，保护你的隐私。保护你免受恶意软件和网络钓鱼的侵害。\n\n<!--more-->\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/adguard_2021-03-01_18-19-35.png)\n\nNo2.[Cookie AutoDelete](https://addons.mozilla.org/en-GB/firefox/addon/cookie-autodelete/?utm_source=addons.mozilla.org&utm_medium=referral&utm_content=search)  \n  当一个标签页关闭时，任何未被使用的cookies都会被自动删除。将信任的cookie列入白名单，同时删除其余的cookie。支持容器标签。\n  ![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/cookieAutodelete_2021-03-01_18-27-18.png)\n  No3.[OneTab](https://addons.mozilla.org/en-GB/firefox/addon/onetab/?utm_source=addons.mozilla.org&utm_medium=referral&utm_content=collection)\n  将标签页转换为列表，减少浏览器内存。\n  ![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/OneTab_2021-03-01_18-41-24.png)\n  No4.[Dark Reader](https://addons.mozilla.org/en-GB/firefox/addon/darkreader/?utm_source=addons.mozilla.org&utm_medium=referral&utm_content=featured)\n  这款护眼扩展可以实现夜间模式，Dark Reader将明亮的颜色反转，使其具有高对比度，易于在夜间阅读。\n  ![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/dark_2021-03-01_18-50-33.png)\n  No5.[uBlock Origin](https://addons.mozilla.org/en-GB/firefox/addon/ublock-origin/?utm_source=addons.mozilla.org&utm_medium=referral&utm_content=featured)\n  一个高效的广谱内容拦截器。占用极少的CPU和内存。\n ![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/ub_2021-03-01_18-50-05.png)\n\n以上是火狐浏览器插件","categories":["应用与插件"]},{"title":"查看共享文件与终端","url":"/50465/","content":"\n 查看共享文件夹\n\n```bash\nvmware-hgfsclient\n```\n\n查看终端命令\n\n```bash\ncat /etc/shells\n```\n\n","categories":["语言与Linux"]},{"title":"nvm的安裝與配置","url":"/34859/","content":"\n ### 如何安装nvm\n\n  [nvm](https://github.com/nvm-sh/nvm) 是用于管理多个活动的nodejs版本 \n\n{% note danger no-icon %}\n\n注意这是<font color=red>Linux的安装方法</font>Windows请访问[nvm-windows](https://github.com/coreybutler/nvm-windows)or[nodist](https://github.com/nullivex/nodist)\n\n<font size=2>官方：nvm不支持Windows(见[#284](https://github.com/nvm-sh/nvm/issues/284))，但可能在WSL(Windows Subsystem for Linux)中工作，这取决于WSL的版本。对于Windows，有两种选择，但我们既不支持也不开发。</font>\n\n{% endnote %}\n\n<!--more-->\n\n要安装或更新 nvm，你应该运行安装脚本。要做到这一点，你可以[手动下载](https://github.com/nvm-sh/nvm/blob/v0.37.2/install.sh)并运行该脚本，或者使用下面的cURL或Wget命令:\n\n```bash\ncurl  -o-  https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh   |  bash\nor\nwget  -qO-  https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh   |   bash\n```\n运行上述任何一个命令都会下载一个脚本并运行它。脚本会将nvm资源库克隆到`~/.nvm`，并尝试将下面代码段中的源码行添加到正确的配置文件中(`~/.bash_profile`or`~/.zshrc`or`~/.profile`or`~/.bashrc`)  \n\n```bash\n#This loads nvm\nexport NVM_DIR=\"$([ -z \"${XDG_CONFIG_HOME-}\" ] && printf %s \"${HOME}/.nvm\" || printf %s \"${XDG_CONFIG_HOME}/nvm\")\"\n[ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\" \n```\n\n{% note warning %}\n在Linux上，运行安装脚本后，如果在输入命令`command -v nvm `后，得到nvm: command not found或终端没有反馈，只需关闭当前终端，打开一个新的终端，再尝试验证。\n{%  endnote %}\n\n配置镜像源可以提高nodejs的下载速度，尝试将下面的代码段配置上面提到的配置文件中去(不用全部配置)\n\n### **nvm 镜像源**\n\n```bash\n#node官方\nexport  NVM_NODEJS_ORG_MIRROR=\"https://nodejs.org/dist\" \nor\n#淘宝镜像源\nexport NVM_NODEJS_ORG_MIRROR=\"https://mirrors.aliyun.com/nodejs-release/\" \nor\n#清华大学镜像源\nexport NVM_NODEJS_ORG_MIRROR=\"https://mirrors.tuna.tsinghua.edu.cn/nodejs-release/\" \n```\n\n{% note danger no-icon %}\n<font color=red size=2>注意：如果更换的是这个镜像源export  NVM_NODEJS_ORG_MIRROR=\"https://npm.taobao.org/mirrors/node\"的话下载nodejs会显示url404,至少我是这样</font>\n{% endnote %}\n\n### 使用方法\n\n要下载、编译并安装最新版本的node，请这样做:\n```bash\n# \"node\" is an alias for the latest version\nnvm install node \n```\n\n要安装特定版本的node:\n\n```bash\nnvm install 12.20.2 # or 14.16.0\n```\n\n使用ls-remote列出可用的版本:\n\n```bash\nnvm ls-remote\n```\n\n然后在任何新的shell中只需使用已安装的版本:\n\n```bash\nnvm use node  \nor  \nnvm use 12.20.2 #or 14.16.0\n```\n\n查看安装了哪些版本：\n\n```bash\nnvm ls\n```\n\n可以用 nvm 给不同的版本号设置别名\n\n```bash\n nvm alias <xxx> <版本号> # 也可以自定义名称 \n```\n\n指定默认node版本\n\n```bash\nnvm alias default 14.16.0 # 也可以指定别名or nvm alias default xxx\n```\n\n取消别名\n\n```bash\nnvm unalias xxx\n```\n\n删除已安装的指定版本\n\n```bash\nnvm uninstall xxxx\n```","categories":["笔记"]},{"title":"虚拟机配置共享文件","url":"/58206/","content":"\n\n\n在VMware虚拟机上设置共享文件夹，现在通过下面的命令就可以看到已经设置好的共享文件夹名\n\n```bash\nvmware-hgfsclient\n```\n\n进入/etc/systemd/system目录\n\n```bash\ncd /etc/systemd/system\n```\n\n创建一个文件\n\n```bash\ntouch xxx.xxx.service\n```\n\n用vim或者其它喜欢的软件打开\n\n```bash\nsudo vim xxx.xxx.service\n```\n\n填入下面的内容，为了方便，就不单独配置各个共享文件夹了，直接将所有共享文件夹mount到一个目录下 <!--more-->\n\n```bash\n[Unit]\n\nDescription=Load VMware shared folders\n\nRequires=vmware-vmblock-fuse.service\n\nAfter=vmware-vmblock-fuse.service\n\nConditionPathExists=.host:/\n\nConditionVirtualization=vmware\n\n\n\n[Service]\n\nType=oneshot\n\nRemainAfterExit=yes\n\nExecStart=\n\nExecStart=/usr/bin/vmhgfs-fuse -o allow_other -o auto_unmount .host:/ /mnt/hgfs\n\n\n\n\n\n[Install]\n\nWantedBy=multi-user.target\n```\n\n保存后，用systemctl命令使能这个service\n\n```bash\nsudo systemctl enable xxx.xxx.service\n```\n\n查看/mnt里有没有hgfs文件夹\n\n如果没有创建hgfs文件夹，需要创建`mkdir hgfs`\n\n```bash\nsudo mkdir -p /mnt/hgfs\n```\n\n重启后检查共享目录是否已经挂载到/mnt/hgfs目录下了","categories":["笔记"]},{"title":"虚拟机安装开源增强工具","url":"/13898/","content":"\n安装open-vm-tools增强工具\n\n```bash\nsudo pacman -S open-vm-tools\n```\n\n开机[启动服务](https://wiki.archlinux.org/index.php/Systemd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87))\n\n```bash\nsystemctl enable  vmtoolsd.service\nsystemctl enable   vmware-vmblock-fuse.service\n```\n\n安装gtkmm3\n\n```bash\nsudo pacman -S gtkmm3\n```\n或者按照VMware自带的增强工具\n\n打开虚拟机光盘，在终端运行`sudo ./VBoxLinuxAdditions.run`\n\n","categories":["笔记"]},{"title":"fcitx5的安裝與配置","url":"/8493/","content":"\n**安装fcitx5**\n\n```bash\nsudo pacman -S fcitx5\nsudo pacman -S  fcitx5-rime\n```\n\n{% note warning %}\n\n打开fcitx5配置报错:你正在运行kde，但是fcitx找不到KCModule未被找到，此KCModule的软件包名通常为kcm-fcitx 或kde-config-fcitx.现在将打开配置目录\n\n{% endnote %}\n\n需要安装：\n\n```bash\nsudo pacman -S fcitx5-configtool\n```\n\n配置編輯`etc/profile`文件，末尾寫入\n\n```bash\n#Fcitx\nexport GTK_IM_MODULE=fcitx\nexport QT_IM_MODULE=fcitx\nexport XMODIFIERS=\"@im=fcitx\"\n```\n\n如果還不支持請嘗試運行`sudo pacman -S fcitx5-im`\n","tags":["Linux"],"categories":["笔记"]},{"title":"Arch删除卸载命令","url":"/16277/","content":"\n 删除单个软件包，保留其全部已经安装的依赖关系 \n```bash\npacman -R package_name \n```\n\n删除指定软件包，及其所有没有被其他已安装软件包使用的依赖关系：\n```bash\n pacman -Rs package_name  #推荐命令\n```\n要删除软件包和所有依赖这个软件包的程序: \n```bash\npacman -Rsc package_name \n```\n {% note  warning%}\n\n警告: 此操作是递归的，请小心检查，可能会一次删除大量的软件包。\n\n{% endnote %}\n\n要删除软件包，但是不删除依赖这个软件包的其他程序： <!--more-->\n```bash\n pacman -Rdd package_name pacman \n```\n删除某些程序时会备份重要配置文件，在其后面加上*.pacsave扩展名。-n 选项可以删除这些文件： \n```bash\npacman -Rn package_name \npacman -Rsn package_name\n```","tags":["Linux命令"],"categories":["语言与Linux"]},{"title":"VMware切换大小写作用失效","url":"/14384/","content":"\n### **VMware(Caps Lock键)切换大小写作用失效的Bug的解决办法**\n\n1.用shift + 要大写的字母\n\n~~2.首先停止运行中的虚拟机，打开虚拟机镜像安装的位置找到`.vmx`在vscode打开在最后添加`mks.win32.useInjectedMagic = \"FALSE\"`~~","categories":["笔记"]},{"title":"ArchLinux安装","url":"/54936/","content":"\n### **如何在虚拟机安装Arch Linux？**\n\n1.新建一个虚拟机。下载Arch ios\n\n{% note success no-icon %}\n\n[清华大学开源软件镜像站](https://mirrors.tuna.tsinghua.edu.cn/) <font size=4>OR</font> [阿里巴巴开源镜像站](https://developer.aliyun.com/mirror/)\n\n{% endnote %}\n\n2.虚拟机设置---选项---高级---选择uefi  3.开机<!--more-->\n\n4.配置网络 \n\n```bash\ndhcpcd\n```\n\n5.wifi-menu \n\n{% note danger %}\n\n会显示zsh: command not found: wifi-memu\n\n{% endnote %}\n\n6.配置镜像源 \n\n```bash\nnano /etc/pacman.d/mirrorlist\n```\n\n[清华大学镜像源](https://mirrors.tuna.tsinghua.edu.cn/help/archlinux/)\n\nctrl + x 然后输入y按回车\n\n7.磁盘分区\n\n```bash\n cfdisk /dev/sda\n```\n\n创建300m EFI分区 剩余空间创建根分区\n\nnew 回车 300m（第二个同理指剩余的空间）\n\n选择write回车输入yes\n\nquit退出\n\n8.把根分区格式化为ext4 \n\n```bash\nmkfs.ext4 /dev/sda2\n```\n\n9.把EFI分区格式化为fat32\n\n```bash\nmkfs.fat -F32 /dev/sda1\n```\n\n10.挂在根分区\n\n```bash\nmount /dev/sda2 /mnt\n```\n\n11.创建EFI分区挂载点\n\n```bash\nmkdir /mnt/boot  mkdir /mnt/boot/EFI\n```\n\n12.挂在EFI分区\n\n```bash\nmount /dev/sda1 /mnt/boot/EFI\n```\n\n13.安装基础包\n\n```bash\npacstrap -i /mnt base base-devel linux linux-firmware\n```\n\n 注：需要按两下回车 然后yes\n\n14.生成文件系统表\n\n```bash\ngenfstab -U /mnt >> /mnt/etc/fstab\n```\n\n15检查文件系统表有没有问题\n\n```bash\ncat  /mnt/etc/fstab\n```\n\n16.切换根目录\n\n```bash\narch-chroot /mnt\n```\n\n17.设置时区\n\n```bash\nln -sf /usr/share/zoneinfo$(tzselect) /etc/localtime\n```\n\n> 4 >>9>>1>>1\n\n18.设置时间漂移\n\n```bash\nhwclock --systohc --utc\n```\n\n19.配置locale\n\n```bash\nnano /etc/locale.gen\n```\n\n{% note warning %}\n\n终端显示 bash: nano:command not found(bash: nano:命令未找到)\n下载nano pacman -S nano\n\n{% endnote %}\n\n20.生成locale文件\n\n```bash\nlocale-gen\n```\n\n21.设置语言（tty中文乱码）\n\n```bash\necho LANG=en_US.UTF-8 > /etc/locale.conf\n```\n\n22.设置主机名\n\n```bash\necho kiss > /etc/hostname\n```\n\n23.配置hosts文件[ArchWiki配置](https://wiki.archlinux.org/index.php/Network_configuration_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E6%9C%AC%E5%9C%B0%E4%B8%BB%E6%9C%BA%E5%90%8D%E8%A7%A3%E6%9E%90)\n\nnano  /etc/hostname\n\n```vim\n127.0.0.1        localhost\n::1              localhost\n127.0.1.1        myhostname.localdomain        myhostname \n```\n\n24.安装DHCP\n\n```bash\npacman -S dhcpcd\n```\n\n25.启动dhcp服务\n\n```bash\nsystemctl enable dhcpcd.service\n```\n\n26.设置root密码\n\n```bash\npasswd\n```\n\n27.创建普通用户\n\n```bash\nuseradd -m -G wheel -s /bin/bash xxx\n```\n\n 27.1设置密码 用户名\n\n```bash\npasswd xxx #xxx是你的用户名不是密码\n```\n\n28.安装vim sudo\n```bash\npacman -S vim sudo\n```\n29.赋予用户sudo权限\n\n```bash\nvisudo \n去掉%wheel ALL=(ALL)ALL的#\n```\n\n30.安装引导\n\n```bash\npacman -s grub efibootmgr \n多系统安装os-prober\n```\n\n31.grub安装\n\n```bash\ngrub-install --target=x86_64-efi --efi-directory=/boot/EFI\n```\n\n32.生成配置文件\n\n```bash\ngrub-mkconfig -o /boot/grub/grub.cfg\n```\n\n33.退出重启\n\n```bash\nexit \nreboot\n```\n\n------\n\n34.查看显示设备\n\n```bash\nlspci | grep vga\n```\n\n35.安装通用的显示驱动\n\n```bash\npacman -S xf86-video-vesa\n```\n\n36.安装xorg\n```bash\npacman -S xorg\n```\n38.安装字体\n```bash\npacman -S ttf-dejavu wqy-microhei\n```\n39.安装kde桌面环境和应用\n```bash\npacman -S plasma kde-applications\n```\n40启用显示管理服务\n```bash\nsystemctl enable sddm\n```\n41启用网络管理器 \n```bash\nsystemctl  enable NetworkManager\n```\n42.重启\n\n```bash\nreboot\n```\n\n43.更改中文\n\n略\n\n44.根据网址设置更新镜像  写入签名key\n\n[ArchlinuxCN](https://mirrors.tuna.tsinghua.edu.cn/help/archlinuxcn/)","tags":["Linux"],"categories":["笔记"]},{"title":"如何在Firefox中禁用WebRTC补充","url":"/6032/","content":"\n   ## FireFox: \"about:config\"的隐私设置调整\n   ### 准备：\n1.在浏览器的网址列输入 \"about:config\" 并点击 enter 键\n\n2.点击\"I'll be careful, I promise!\"按钮\n3.依照下方的指示操作...\n <!--more-->\n### 开始动手：\n\n1. privacy.firstparty.isolate = true\n\n   - [Tor Uplift](https://wiki.mozilla.org/Security/Tor_Uplift)效用的结果，它可隔绝主要访问网域中所有浏览器辨识器来源（如 cookies），并期能可阻挡跨域名的追踪。（如果已使用扩展 \"Cookie AutoDelete\"，请不要打开此功能。）\n\n2. privacy.resistFingerprinting = true\n\n   - [Tor Uplift](https://wiki.mozilla.org/Security/Tor_Uplift) 效用的结果, 此偏好可让 Firefox 更能抵抗指纹辨识。\n\n3. privacy.trackingprotection.enabled = true \n\n   - Mozilla 新內建的追踪保护功能，其利用 Disconnect.me 过滤名单，但如果你已使用其它第三方的屏滤器如 uBlock Origin，其效能就会重复多余，因此你可以将之设为关闭。\n\n4. browser.cache.offline.enable = false\n\n   - 取消离线的缓存快取资料\n\n5. browser.safebrowsing.malware = false \n\n   - 取消 Google 安全浏览的恶意软件检查。这会有安全上的风险，但可改善隐私。\n\n6. browser.safebrowsing.phishing.enabled = false\n\n   - 取消Google安全浏览与防钓鱼保护。这会有安全上的风险，但可改善隐私。\n\n7. browser.send_pings = false\n\n   - 这个性能可让网站追踪访客的点击情況。\n\n8. browser.sessionstore.max_tabs_undo = 0\n\n   - 尽管 Firefox 设定为不记录浏览资讯，但在用户关闭浏览器分页之前，这些资讯仍会暂存在选单 -> 浏览历史 -> 近期关闭的分页 底下\n\n9. browser.urlbar.speculativeConnect.enabled = false\n\n   - 关闭自动完成的 URLs 预载， 当用户在网址列输入资讯时，Firefox 会自行预载，有人担心这些浏览器自动建议的网址并非是用户想要连上的网站。\n\n10. dom.battery.enabled = false\n   - 网站主人可以追踪用户上网设备的电池状况。\n\n11. dom.event.clipboardevents.enabled = false\n   - 取消让网站在让你从某网页中复制、贴上是剪下任何内容時，会发出通知。这会让他们知道网页的哪一部份被挑选。\n\n12. geo.enabled = false\n   - 取消地理定位资料\n\n13. media.navigator.enabled = false\n   - 网站可以跟踪用户上网设备里的麦克风和摄影机状态\n\n14. network.cookie.cookieBehavior = 1\n    - 取消cookies\n    - 0 = Accept all cookies by default （默认接受所有cookies）\n    - 1 = Only accept from the originating site (block third party cookies) (只接受来自原网站的Cookies（阻止第三方Cookies）。)\n    - 2 = Block all cookies by default ( 默认情况下禁止所有cookies)\n\n15. network.cookie.lifetimePolicy = 2\n\n    - cookies 在期间结束后会被刪除\n    - 0 = Accept cookies normally (正常接受cookies)\n    - 1 = Prompt for each cookie (每个cookie的提示)\n    - 2 = Accept for current session only (只接受当前会议)\n    - 3 = Accept for N days (接受N天)\n\n16. network.http.referer.trimmingPolicy = 2\n\n    - Send only the scheme, host, and port in the `Referer` header  (只发送Referer标头中的方案、主机和端口。)\n    - 0 = Send the full URL in the `Referer` header (在Referer header中发送完整的URL。)\n    - 1 = Send the URL without its query string in the `Referer` header (发送不含查询字符串的URL的Referer header)\n    - 2 = Send only the scheme, host, and port in the `Referer` header\n\n17. network.http.referer.XOriginPolicy = 2\n\n    - Only send `Referer` header when the full hostnames match. (Note: if you notice significant breakage, you might try `1` combined with an `XOriginTrimmingPolicy` tweak below.) \n    - 0 = Send `Referer` in all cases\n    - 1 = Send `Referer` to same eTLD sites\n    - 2 = Send `Referer` only when the full hostnames match\n\n18. network.http.referer.XOriginTrimmingPolicy = 2\n\n    - When sending `Referer` across origins, only send scheme, host, and port in the `Referer` header of cross-origin requests. \n    - 0 = Send full url in `Referer`\n    - 1 = Send url without query string in `Referer`\n    - 2 = Only send scheme, host, and port in `Referer`\n\n19. webgl.disabled = true\n\n   - WebGL 有潜在的安全风险","tags":["WebRTC"],"categories":["笔记"]},{"title":"如何在Firefox中禁用WebRTC","url":"/51087/","content":"\n### 如何在Firefox中禁用WebRTC？\n简而言之：在 `about:config` 中设置 `media.peerconnection.enabled `为 `false`。\n解释一下: \n在firefox地址栏输入 \"about:config \"然后按回车键。\n按 \"我会小心的，我保证！\"按钮。\n搜索 \"media.peerconnection.enabled\"\n双击该条目，\"Value \"列现在应该是 \"false\"\n完成。再做一次[WebRTC泄漏测试](https://ipleak.net/)。<!--more-->\n\n如果你想确保每一个与WebRTC相关的设置真的被禁用，请更改这些设置。\n1.media.peerconnection.turn.disable = true。\n2.media.peerconnection.use_document_iceservers = false\n3.media.peerconnection.video.enabled = false\n4.media.peerconnection.identity.timeout = 1\n现在你可以100%确定WebRTC被禁用。","tags":["WebRTC"],"categories":["笔记"]},{"title":"向你而生","url":"/21015/","content":"\n“反抗将自身价值给予人生，贯穿人生的始末，恢复人生的伟大对眼光开阔的人而言，最美的景观莫过于智力与超过人的现实之间的搏斗。”-----走出自卑陰影，在更高､更遠的地方找到生命的補償","tags":["话"],"categories":["生活与话"]},{"title":"小學生水平","url":"/51349/","content":"\n\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E6%84%9B%E9%BA%97%E7%B5%B22.png)","tags":["画"],"categories":["生活与话"]},{"title":"hexo报错","url":"/51550/","content":"\n  **报错**\n\nhexo 报错 use_date_for_updated is deprecated...\n\nWARN Deprecated config detected: \"use_date_for_updated\" is deprecated, please se \"updated option\" instead. See https://hexo.io/docs/configuration for more deails.\n\n**解决办法**\n\n编辑根目录的 `_config.yml` 文件 , 把 `use_date_for_updated` 值改为 `updated_option`","tags":["hexo"],"categories":["笔记"]},{"title":"VirtualBox共享文件设置","url":"/32245/","content":"\n   在 VirtualBox 中选择`设置/共享文件夹`，添加想要共享文件夹；设置共享文件夹的名称，选择 `固定分配`；确认 `OK`。\n\n进入 Linux系统，选择一个文件夹作为共享文件夹\n\n打开终端，写入 `$ sudo mount -t vboxsf 共享文件夹的名 在Linux建立的共享文件夹名`\n\nps：\n\n- 重启后，已设置的共享文件夹将会消失，需要再次执行挂载命令。\n- 在Linux建立的文件夹需要`sudo chmod 777 [文件夹名] `\n- 可是设置`自动挂载`\n\n","categories":["笔记"]},{"title":"Linux安装配置","url":"/42703/","content":"\n更新源 更新软件  安装vim   安装zsh   安装oh-my-zsh 安装nodejs  \n\n切換鏡像源\n\n```\nnpm config set registry=https://registry.npm.taobao.org/\n```\n\n檢查鏡像源是否下載成功：npm config get registry\n\n安装npm  nrm   安装hexo  `npm install hexo-cli -g` 安装vscode\n\nGitHub配置 ssh <!--more-->\n\n```bash\nssh-keygen -t rsa -C \"youremail\"\n```\n\n然後一路回車，生成  `.ssh` 的文件夾。在你的筆電中找到這個文件夾\n\n```bash\n~/.ssh/id_rsa.pub\n```\n\n打开[github](https://github.com/)，在头像下面点击`settings`，再点击`SSH and GPG keys`，新建一个`SSH`，名字随便取一个都可以，把你的`id_rsa.pub`里面的信息复制进去。\n\n安装输入法 ` fcitx5`   \n\n安装md软件\n\n```bash\n# or run:\n# sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE\nwget -qO - <https://typora.io/linux/public-key.asc> | sudo apt-key add -\n# add Typora's repository\nsudo add-apt-repository 'deb <https://typora.io/linux> ./'\nsudo apt-get update\n# install typora\nsudo apt-get install typora\n```","categories":["笔记"]},{"title":"坚果云更改备份路径","url":"/9678/","content":"\n打开坚果云 找到要更改的文件夹 选择右边三个点 点击同步设置 ——修改同步路径\n\n","categories":["笔记"]},{"title":"如何更新hexo和插件版本","url":"/45014/","content":"\n 自动更新----进入博客根目录运行`npm update`\n\n手动更新----进入博客根目录运行`npm outdated`\n\n运行后查看Hexo和插件的最新版本然后修改根目录下的`package.json`将对应的插件名和Hexo对应的版本号更新为要更新的版本号\n\n开始更新----`npm install --save`\n\n查看版本号----`hexo version`","categories":["笔记"]},{"title":"vim下方向键无法移动光标","url":"/27002/","content":"\n  方式一：可以使用【H左】【K上】【J下】【L右】移动光标修改\n\n方式二：下载vim自动的vim是精简版`sudo apt-get install vim`\n\n","categories":["笔记"]},{"title":"Windows创建还原点","url":"/29138/","content":"\n  \n\n# 创建系统还原点\n\nWindows 10\n\n1. 在任务栏上的搜索框中，键入“创建还原点”，然后从结果列表中选择它。\n2. 在“系统属性”的“系统保护”选项卡上，选择“创建”。\n3. 键入有关还原点的描述，然后依次选择“创建”>“确定”。","categories":["笔记"]},{"title":"hexo上传报错","url":"/52109/","content":"\n​    电脑死循环自启重置电脑后，安装node出错\n\n```\n(node:11276) Warning: Accessing non-existent property 'lineno' of module exports inside circular dependency\n(Use `node --trace-warnings ...` to show where the warning was created)\n(node:11276) Warning: Accessing non-existent property 'column' of module exports inside circular dependency\n(node:11276) Warning: Accessing non-existent property 'filename' of module exports inside circular dependency\n(node:11276) Warning: Accessing non-existent property 'lineno' of module exports inside circular dependency\n(node:11276) Warning: Accessing non-existent property 'column' of module exports inside circular dependency\n(node:11276) Warning: Accessing non-existent property 'filename' of module exports inside circular dependency\n\n```\n\nnode版本过高 卸载安装旧版本","categories":["笔记"]},{"title":"GoodSync同步备份","url":"/55246/","content":"\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/GoodSync_2021-01-30_09-05-56.png)\n\n [GoodSync](https://www.goodsync.com/cn)是一款备份和文件同步程序。它用于在一台计算机上的两个目录之间，或计算机与另一个存储设备（如另一台计算机、可移动磁盘、闪存驱动器或智能手机）之间，或计算机与远程计算机或服务器之间同步文件。\n\n","tags":["软件"],"categories":["应用与插件"]},{"title":"Linux下如何切换root","url":"/43258/","content":"\n>  如果想临时使用一下root权限，只需要在命令前面加上`sudo`\n> 如果想一直使用root权限，需要通过su切换到root用户：（不推荐一直使用）\n\n### **重设root用户密码**\n\n```shell\nsudo passwd root\n```\n\n根据提示，输入新root密码（不要和非root用户密码一样）\n\n### **切换root用户**\n\n```shell\nsu\n```\n\n输入root用户密码\n### **回到非root用户权限**\n使用`su “yc”`或者`exit`命令，回到用户权限","categories":["语言与Linux"]},{"title":"Cmder配置WSL","url":"/16140/","content":"\n###   **在Windows下安装Linux子系统**\n\n使用Windows搜索打开控制面板-->程序和功能-->启用或关闭Windows功能-->找到适用于Linux的Windows子系统打上√（等系统下载重新启动）如图\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF_2021-01-29_19-32-18.png)\n\nps:如果找不到程序和功能，把右上角的查看方式换成大图标<!--more-->\n\n### **在Windows的应用商店下载你喜欢的Linux**\n\n（LTS表示长期支持版本）我选的是Ubuntu 20.04 LTS如图\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/Linux_2021-01-29_19-39-42.png)\n\n安装完之后，打开Ubuntu会让你输入name（必须英文）然后是密码（在输入密码的时候并不显示）和核对密码。输入完之后就成功了\n\n### **在Cmder关联WSL（关联子系统）**\n\n需要下载并安装好[Cmder](https://cmder.net/) ps：下载完整版Download Full\n\n打开Cmder-->右下角的三（或者win+Alt+p）-->settings(第一次安装是英文版)-->Interface language(切换中文)-->启动-->选择命令行（找到Ubuntu）如图\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E9%85%8D%E7%BD%AEcmder_2021-01-29_20-04-13.png)\n\n如果手动找不到，在文件管理搜索Ubuntu2004.exe（WindowsApp文件夹下的）","tags":["WSL"],"categories":["笔记"]},{"title":"DeepLTranslate翻译","url":"/36500/","content":"\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/deelp_2021-01-29%20185315.png)\n\n [DeepL](https://www.deepl.com/translator)是人工智能语言辅助，训练人工智能来理解和翻译文本。系统能快速、自动地识别语言，将单词转化为你想要的语言，并尝试添加特殊的语言细微差别和表达方式。拥有神经性网络。官网支持中文。支持网页翻译和客户端翻译[下载地址](https://www.deepl.com/app)","categories":["应用与插件"]},{"title":"推荐RSS网站","url":"/3355/","content":"\n游戏时光头条：https://www.vgtime.com/rss.jhtml\n\n青柠学术：https://iseex.github.io/feed.xml\n\n少数派：https://sspai.com/feed\n\n森林集：[https://senlinjimore.com/archives/category/%25e8%25bd%25af%25e4%25bb%25b6/%25e7%2594%25b5%25e8%2584%2591/feed](https://senlinjimore.com/archives/category/%e8%bd%af%e4%bb%b6/%e7%94%b5%e8%84%91/feed)\n\n数码荔枝：https://www.lizhi.io/feed/\n\n小众软件：https://www.appinn.com/feed/\n\n知乎日报：http://feedmaker.kindle4rss.com/feeds/zhihu-daily.xml\n\n178动漫频道：http://acg.178.com/s/rss.xml\n\n反斗软件：http://www.apprcn.com/feed\n\n更新中......","tags":["RSS"],"categories":["应用与插件"]},{"title":"我遇到的问题","url":"/47746/","content":"##                                   问题\n\n1. 什么是行内块元素()?\n\n2. 什么是块元素 (占一整行)? \n\n3. 什么是行内元素(一行内显示的)\n\n4. 阴影的设置   box-shadow  :x轴 y轴  阴影大小 模糊程度  颜色 内阴影inset/外阴影(默认)   如果一分为二,需要设置模糊成度\n\n5. 权重问题 ---- !>行内式>id选择器>类选择器>标签选择器>通配符选择器>浏览器默认>继承选择<!--more-->\n\n6. 定位 ?  \n\n   绝对定位([absolute]不占位置) \n\n   相对定位(relative永远参照自身定位)\n\n   固定定位([fixed]浏览器的可是区域移动)\n\n7. 双伪元素的写法   (伪元素清除浮动)---(               )\n\n   ```css\n   ①                                                 ②\n   \n   .clearfix:after{                           .clearfix:before,\n   \n    content:\"\";                                  .clearfix:after{  \n   \n   display:block;                                contrnt:\"\";    \n   \n   height:0;                                        display:table;\n   \n   visibitility:hidden;(隐藏)               } \n   \n   clear: both;                                   \n   \n   }\n   \n   .clearfix{\n   \n   *zoom:1;\n   \n   }\n   \n   ```\n\n   \n\n   ​      *zoom:1(ps:应该是这个)\n\n8. overflow的用法\n\n9. 相对路径和绝对路径\n\n10. 按钮部分","tags":["问题"],"categories":["Web前端"]},{"title":"如何删除鼠标右键的cmder","url":"/64285/","content":"\n \n\n**如何删除鼠标右键选项的cmder（或其他添加到文件目录中的应用）**\n\n1.打开注册表设置（打开方式：直接搜索“注册表”或者win + r → regedit） <!--more-->\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E6%89%93%E5%BC%80%E6%B3%A8%E5%86%8C%E8%A1%A8%202021-01-29%20114632.png)\n\n2.找到HKEY_CLASSES_ROOT → Directory → Background → cmder（删除选项）\n\n或者打开注册表之后，编辑 -->查找 -->输入cmder进行查找","categories":["笔记"]},{"title":"入门oh-my-zsh","url":"/13401/","content":"\n \n\n> Oh-my-zsh是一个开源的、社区驱动的管理zsh的框架，它是免费的。它有超过180个可选的插件（rails、git......），超过120个主题和一个自动更新工具来保持oh-my-zsh的最新状态。\n\n在本教程中，我将指导你在你的PC/笔记本电脑上安装它。最大的好处是你可以自定义你的Shell和添加插件。不像老式的Bash shell，它看起来并不吸引人，当你大量使用命令行工作时，会让你很难使用。\n\n#### **前提条件**\n\n- Linux 和 macOS，因为 oh-my-zsh 在基于 Unix 的操作系统上工作得最好。\n- WSL(Windows Subsystem for Linux)也可以和oh-my-zsh一起工作。<!--more-->\n- zsh必须是预装的，在OSX中，它已经被预装了。在OSX中，它已经被预装了。在 Linux 中，你需要在终端中输入命令来安装。\n- curl或wget必须安装.\n- 对于Debian/Ubuntu，你需要在终端输入命令：必须安装curl或wget。\n\n```shell\nsudo apt-get installl zsh\n```\n\n- 对于Fedora：\n\n  ```shell\n  sudo yum install zsh\n  ```\n\n  下载oh-my-zsh\n\n  通过curl\n\n  ```shell\n  curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh\n  ```\n\n  通过wget\n\n  ```shell\n  wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O - | sh\n  ```\n\n  更改默认shell\n\n  ```shell\n  chsh -s /bin/zsh\n  ```\n\n  对于某些操作系统，可能需要重新启动计算机才能生效。\n\n#### **更换终端主题**\n\n现在你已经成功安装了 oh-my-zsh。你需要改变适合你的主题，而不是使用默认的。要改变它，你需要修改`.zshrc`文件:\n\n```shell\nvim ~/.zshrc\n```\n\n在本教程中，我使用的是vim文本编辑器，如果你喜欢可以使用其他的文本编辑器。接下来，在文件中找到这一行:\n\n```shell\nZSH_THEME=\"robbyrussell\"\n```\n\n把名字 \"robbyrussell \"改为另一个主题的名字。你可以看看这个网站上的所有可用的[主题](https://github.com/ohmyzsh/ohmyzsh/wiki/Themes)。\n\n最后，只要重启终端，你就会看到不同的效果。\n\n#### **添加插件**\n\n在.zshrc文件中，你需要编辑以 \"plugins \"字样开头的一行:\n\n```shell\nplugins=(git bundler osx rake ruby)\n```\n\n如果你喜欢，你可以添加更多或删除插件。要使用这些插件，大多数插件都有README文件，其中记录了如何使用它们。\n\n#### **自动补全与⬆**\n\n在Bash shell中，你可以使用Ctrl + R和⬆来自动填写最近的和匹配的命令。\n\n使用 oh-my-zsh，还有另一种方法：你可以输入你想要的命令的起始词，然后按 ⬆来循环浏览历史记录。\n\n#### **用Tab键自动完成**\n\n在Bash shell中，你可以输入关键字，然后按Tab键显示匹配命令列表，但是你需要在列表中循环并记住你想要的名称，并手动进一步输入以完成。\n\n有了oh-my-zsh，事情就好办了，第一次按Tab键后，可以按第二次，允许在列表中循环，选择你想要的命令，然后它会自动填入剩下的单词，最后只要按Enter键就可以了。比如说：\n\n1. 第一次输入并按Tab键`doc`\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/apt_2021-01-29%20105236.png)\n\n  2.第二次按Tab键，然后按Tab键进行上、下、左、右循环。\n\n#### **更新 oh-my-zsh**\n\n它会自动更新，但如果你想手动更新，只需在终端机上输入以下命令即可。\n\n```shell\nomz update\n```\n\n","tags":["Linux"],"categories":["笔记"]},{"title":"Linux入门指南-一","url":"/30688/","content":"\n###    **Linux 是什么？**\n\nLinux 是一个开源操作系统和 IT 基础架构平台。它由 Linus Torvalds 于 1991 年构思设计而成，\n\n### Linux 的优点\n\n跨平台的硬件支持\n\n低资源占用下良好的稳定性\n\n高效的文件系统\n\n可靠的安全性 <!--more-->\n\n完善纯净的软件包管理机制\n\n随心所欲定制 UI\n\n社区的支持\n\n开源\n\n### 哪些大众用户比较适合 Linux 桌面版？\n\n学习和探索\n\n业余个人内容创作\n\n极度重视安全和隐私\n\n机器已经跑不动 Windows / macOS\n\n### Linux 上软件有多少？\n\n网页版应用\n\n支持同类网络传输协议的客户端\n\n任务自动化服务\n\n即时通讯软件内置的聊天机器人\n\nWine 兼容运行 Windows 应用\n\n模拟器兼容运行 Android 应用\n\n虚拟机软件模拟运行 macOS 或 Windows 系统\n\n### **总结**\n\nLinux 因为其完全模块化的基理，干净得像水一样。水本身无固定的形态，它可以随环境而作出适应，让自己变成外物的形态。\n\n所以，朋友，像水一样吧！","categories":["语言与Linux"]},{"title":"Hyper终端简单配置","url":"/6423/","content":"\n  [Hyper](https://hyper.is/) 是一个开源的、全平台适用的、有着丰富主题和插件的现代化终端。\n\n打开之后是默认的cmd，更改顺序是左上角Edit--->Preferences如图\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/komi_2021-01-28_13-37-46.png)\n\n打开之后是一个.hyper.js的文件找到shell，在引号内写入`C:\\\\Windows\\\\System32\\\\bash.exe` 如图 <!--more-->\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/shell_2021-01-28_13-44-18.png)\n\n当然前提是有子系统，更改主题找到`plugins`(在.hyper.js里) 填入你喜欢的[主题](https://hyper.is/themes) （hyperterm-monokai）\n\n如果要切换zsh则需要在Preferences的shell在引号内写入`C:\\\\Windows\\\\System32\\\\wsl.exe` 和`shellArgs: ['~']`如图\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-01-28%20192821.png)\n\n**下载插件** \n\n推荐这两个插件，[其它插件](https://hyper.is/plugins)\n\n```bash\n # hyper-opacity,解决windows下hyper原生不支持的窗口透明化\n hyper i hyper-opacity\n # Hyper的扩展，可以打开电源模式，并有额外的哇模式。\n hyper i hyperpower\n # 在 Hyper 终端启动之前和之后初始化命令的终极和最完整的扩展\n hyper i hyper-init\n```\n\n在Hyper安装会报错，需要在管理员Windows PowerShell中下载或者管理员cmd中下载\n\n安装成功如下图\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-01-28%20194803.png)","tags":["软件"],"categories":["应用与插件"]},{"title":"子系统下不识别u盘","url":"/28595/","content":"\n#       Windows下Linux不识别U盘的解决办法\n\n在终端进入`/mnt/` 在终端输入`sudo mkdir /mnt/d`然后紧接输入`sudo mount -t drvfs D: /mnt/d`\n\n现在，能够访问D：驱动器的文件。如果卸载驱动器以便安全地将其卸载下时，运行以下命令：`sudo umount /mnt/d`\n\n具体的内容请访问[微软文档](https://docs.microsoft.com/zh-cn/archive/blogs/wsl/file-system-improvements-to-the-windows-subsystem-for-linux)","categories":["笔记"]},{"title":"windows10中的剪切版","url":"/26695/","content":"\nWindows中的剪切板使用基于云的剪贴板从一台电脑上复制图像和文本并粘贴到另一台电脑上。你不仅可以重剪贴板历史记录中粘贴，还可以固定发现自己经常使用的项目。\n\n1. 若要随时访问剪贴板历史记录，请按 Windows 徽标键 + V。你还可以从剪贴板菜单中选择单个项来“粘贴”和“固定”常用的项。\n2. 若要在你的 Windows 10 设备之间共享剪贴板项目，请依次选择“开始”菜单 >“设置” >“系统”>“剪贴板”。选择“跨设备同步”下的“自动同步我复制的文本”。同步功能与你的 Microsoft 帐户或工作帐户绑定，因此请记得在所有设备上使用相同的登录信息。","categories":["笔记"]},{"title":"DirectoryOpus文件管理","url":"/59017/","content":"\n# DirectoryOpus\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/header.png)\n\n[DirectoryOpus](https://www.gpsoft.com.au/) 是 Win 平台上de1资源管理器，功能最完全、可定制化程度高。可以通过 DO 完成几乎所有操作，包括查看图片元信息、预览图片、阅读文本文件内容、批量重命名、操作压缩文件以及 FTP 同步请求等\n\n","tags":["软件"],"categories":["应用与插件"]},{"title":"小技巧","url":"/35842/","content":"\n#   小技巧\n\n- ☺笑容会给你带来一整天的灿烂。\n- 别犹豫别放弃，保持速度，不要慢下来。\n- 没有必要为了别人而改变，别人总有离开的时候。改变应该是自发而主动的。\n- 改变你的思考模式。\n- 变是为了让自己快乐，为了别人而改变，不会长久的。\n- 改变外在是改变内心的途径之一。\n- 别人的想法不重要，要尊重你自己的想法。\n- 有意识的去改变，要知道自己在做什么。\n- 可以改变很多次，一切都处于运动变化中。\n- 坚持。养成一个新习惯至少需要21天。第一天非常难，后来就会越来越简单。\n- 一个人都有缺点，请做独一无二的你。","categories":["生活与话"]},{"title":"如何改变自己(一)","url":"/28002/","content":"\n# 如何改变自己\n\n### **前言**\n\n大多数人会在某些时刻对自己的人生或者自我感到不满足。如果你意识到自己需要做出很大改变，那么你是幸运的。因为你有了这样的意识，就能够改变。重大的改变虽然令人望而生畏，但只要你目标明确、计划清晰就可以做到。行为上的改变，最终会带来对自身整体看法的改变。\n\n### 一**.评估你的需求**。\n\n**1.发现问题。**你决定要改变，原因和具体措施是什么？看清引起你改变的那个问题，分析问题是解决问题的必要前提。你要知道改变会带来哪些好处。\n\n- 态度积极。列出你身上能被自我欣赏的优点，如果你觉得这很难，那就想想别人对你的评价，在改正坏习惯的过程中，你可以拿你的优点作为参照。<!--more-->\n- 简单来说，就是得明确你想要什么，别人对你的期待不等同于你自己的追求，假如你本身不渴望改变，那改变自然也不会发生。\n- 然后，列出你之所以想改变的原因，把原因写在纸上，当你看见时就会有动力，这能够让你坚持下去。\n\n**2.自我肯定**。认可自己的积极面，以此强化你的核心价值观，你就可以不断靠近理想中的自己，当然盲目的自我肯定并没有用，因为这种盲目无法激发你的潜能，而切合实际的肯定，可以让你保持积极心态，进而促使你更好的解决问题，有效的自我肯定。有效的自我肯定示例： \n\n- 用“我是”句式\n- 用“我能”句式\n- 用“我会”句式\n\n**3.将改变后的未来可视化。**可视化是一种心理预演，帮助你设想一个不同的情景。抽象的可视化在脑海中进行，具体的可视化即收集一些和你的目标相关的图片。有效的可视化，帮你细化目标和调整目标。可视化还能培养你对环境和人生的控制力。操作步骤：\n\n- 闭上眼睛。\n- 想象理想中未来的自己，你在哪？在做什么？环境发生了什么变化？那时的你什么样？哪些变化让你感到快乐？\n- 试着探索理想中未来的细节。动用视觉，听觉，嗅觉，味觉去想象。细节具体化能够让可视化，更为真实。\n- 运用积极的可视化帮你设立切实可行的阶段性目标。\n\n**4.好遇到障碍的准备。**人生有很多事情无法预料，每一条改变之路都充斥着困难和别人的阻挠，那些困难和最终的成功相比都是小事，而且也终将被克服，你要坚信这一点，才能够成功。\n\n- 切合实际是应对任何困难的最佳途径，遇到障碍时不要责怪别人或他人，因为阻碍是正常的，而且必然会发生。\n\n**5.表面的失败中学习。**很多时候你会觉得自己失败了，你没有达成目标，你遭遇坎坷，你不得不改变目标，但请你记住，失败只是表面的，实际上失败意义的新机遇，从失败中学得宝贵的经验，学会灵活的调整目标，这样你会更快乐。\n\n6.耐心。要是改变是轻而易举就能做到的，那就没有什么价值了，成果比你预想中来的慢，有时候旁人能够一眼看到你的改变和成果，只是你自己还不知道而已，你每天都有细微的改变，所以自己无法察觉，但改变的确发生了。\n\n- 大目标分成小目标有益于对自己进行阶段性评估，每当达成一个小目标适当的奖励自己，这样你就可以保持前进的动力。\n\n### **二.设立合理的目标。**\n\n1.在SMART法则指导下设立目标。定目标也是门艺术。目标定得好，才能够确保实现。SMART是5个英文单词首字母的集合，该法则是一个用于衡量目标的合理程度的有效工具。\n\n- 具体（Specific）／重要（Significant）\n- 可衡量（Measurable）／有意义（Meaningful）\n- 可达成（Achievable）／基于行动（Action-oriented）\n- 相关（Relevant）／基于成果（Results-oriented）\n- 有时限（Time-bound）／可追踪（Trackable）\n\n**2.制定具体的目标。** 也就是说目标要有针对性。假如目标过于宽泛，就难以据此制定实现目标的行动方案。\n\n**3.确保目标是可衡量的。** 你得知道怎样算达成目标。要是无法判断目标实现与否，离现实还有多少距离，那样的目标是不可衡量的。\n\n**4.确保目标可达成。**根据每个人的能力不同，因人而异。判断一个目标是否可达成，要考虑很多因素。有些因素是人为不可控的。需要考虑的是自己是否有足够的知识与技能去实现目标。判断该目标实现的可能性。\n\n**5.评估目标的相关性。**这个标准对于阶段性目标来说，尤为重要。你的阶段性目标必须和总目标相关，并且逐步促进最终目标达成。不相关的目标对成功没有帮助。\n\n**6.设定达成目标的时间**。 有效的目标应当有时限，否则努力就没有意义。\n\n### **三.付诸行动。**\n\n**1.从现在开始。** 别总想着明天再说，而明天又拖到后天。停止拖延是改变的第一步。如果你战胜不了拖延，那就不会有所成。\n\n**2.把大目标分解为小目标。** 总目标分解成阶段性目标，因为阶段性目标容易实现，带来的成就感使你继续努力的动力。\n\n- 永远的目标让人望而怯步，你先不要想的太过遥远，专注于第1个阶段性目标。\n- 尝试定制倒推式日程。从总目标的实现日期往前推算各阶段目标的达成日期，直到推及现在，在总时间既定的情况下，你可能需要调整几次日程安排或者必要时调整总时间。\n- 用倒推的办法安排日程，能够帮你推算出第1步该做什么，万事开头难知道第1步做什么，以后就会越来越顺利。\n\n**3.奖励自己**。 积极的看待自己的进步给予合理的奖励，这对于实现长远目标也很有帮助，放松一下。\n\n- 但是奖励不该和目标相违背。\n\n**4.恰当运用情绪。** 实现目标的过程中，你会有各种各样的情绪，这很正常，你需要学会借助这些情绪来促进目标的实现。\n\n- 当你实现一个阶段性目标，你应该开心开心，会让你更有动力继续努力。\n- 当你遇到困难你会感到沮丧，沮丧会让你更专注目标。\n- 当你接近目标时突然遇到阻碍，你会愤怒，把愤怒转化为最后一搏的动力。\n\n**5.走出自己的舒适区。** 多数人喜欢做自己喜欢的事，然而如果你想做出一个重大改变，你必须走出自身的舒适区，但是不要担心，不适感会给你带来新视角，助你成长。\n\n- 我们要再次提及分解目标的好处。你觉得目标让人望而怯步时，你就先专注于实现第1个阶段性目标，这样能够减少畏惧。\n- 向目标努力的过程中，试着走出自己的舒适区，这会让你开拓视野、增长经验、变得更积极。\n\n### **四.回顾成绩**\n\n**1.保持动力。**在改变自我的过程中，你会遇到意料之外的阻碍，这些时刻要尤为小心恰当的应对，让自己保持正确的方向。\n\n- 言出必行。\n- 别让自己过于疲惫。\n- 留意心理暗示。\n- 找到志同道合的朋友。\n\n**2.记录并追踪感受。** 记录自己的行为从中发现规律，以找到最有效的途径。\n\n- 你发现自己总是退回老习惯，无法改变时，写下时间、原因和细节。分析可能的因素。\n- 记录你的进步。如果这天你表现不错，写下来回顾自己的进步，会让你保持前进的动力。\n\n**3.保持健康。**身体健康什么事都变得更容易，身体健康，不仅提高生活质量，而且有助于保持积极的心态。\n\n- 合理饮食保证充足的睡眠，这是最基本的要求，毕竟改变自己和实现目标是很难的事情，你得用最佳的心理和身体状态来迎接挑战。\n- 身体不好的时候先调整好自身的状态。健康快乐是第1位，其次才是想法和目标。\n\n**4.调整目标。** 当你不断进步，在接近目标的过程中要不断调试，记录你的进步，据此调整计划，使它更适合你。\n\n- 当你进步飞速时，可以制定更有挑战性的新目标。\n- 如果你没有达到预期的成绩，不要自责，把目标调整的更为合理，别因挫败而放弃。\n\n**5.坚持。** 当你实现了预期的结果，不要停止努力，新的习惯需要花时间来保持，让自己慢慢适应新状态。\n\n- 让改变持续一生。","categories":["生活与话"]},{"title":"第三方评论Gitalk","url":"/4503/","content":"\n **前言**\n\n如何给博客集成Gitalk。Gitalk是基于GitHub Issue开发的评论插件，它是把GitHub 的issue集成在hexo博客中。\n\n首先你的hexo主题支持Gitalk。然后就是有个GitHub账号。\n\n**配置Gitalk**\n\n### Register Application\n\n在GitHub注册新应用\n登录GitHub->点击头像->Setting->Developer settings->OAuth Apps->New OAuth App\n顺序如图<!--more-->\n\n1.\n\n<img src=\"https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/Developer%20settings.png\" style=\"zoom: 67%;\" />\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/OAuth%20apps_2021-01-26_21-36-28.png)\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E6%96%B0%E5%BB%BAOAuth_2021-01-26_21-37-58.png)\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/michi_2021-01-26_21-58-01.png)\n\n\n\n### _config.yml\n\n在主题配置文件`xxx/_config.yml`中按需添加内容：\n\n```yml\ngitalk:\n  enable: true\n  githubID: github帐号  # 例：xxx  \n  repo: 仓库名称   # 例：xxxx.github.io\n  ClientID: Client ID\n  ClientSecret: Client Secret\n  adminUser: github帐号 #指定可初始化评论账户\n  labels: 'gitalk' #GitHub issues的标签\n  distractionFreeMode: true\n```\n\n以上就是添加gitalk评论的配置，博客上传到GitHub上后，打开页面进入某一博客内容下，就可看到评论处。","tags":["Gitalk"],"categories":["笔记"]},{"title":"简悦插件","url":"/61495/","content":"\n简于型 · 悦于心\n\n [简悦](https://simpread.pro/) - 为你提供「如杂志般沉浸式阅读体验」的扩展,免费使用，但是有些功能需要高级会员才能使用\n\n阅读模式\n\n独有功能，通过提取 标题 · 描述 ·正文 · 媒体 图片 / 视频 等资源\n生成符合中文阅读习惯的页面，具有零干扰 · 沉浸式特点，适合深入阅读\n\n聚焦模式\n\n不改变当前页面的结构，仅仅高亮需要阅读的部分\n适合临时阅读或者未适配阅读模式的网站\n","tags":["软件"],"categories":["应用与插件"]},{"title":"Notion笔记软件","url":"/14444/","content":"\n#      Notion\n\n[**Notion**](https://www.notion.so)是一款提供笔记、任务、数据库、看板、维基、日历和提醒等组件的应用程序。用户可以将这些组件连接起来，来创建自己的系统，用于知识管理、笔记记录、数据管理、项目管理等。这些组件和系统可以单独使用，也可以与他人进行跨平台协作。支持英语和韩语。官方消息说马上支持中文（还在本地化翻译）<!--more-->\n\n支持 谷歌插件 \n\nIOS & Android谷歌插件 \n\nMac & Windows\n\nWeb Clipper","tags":["软件"],"categories":["应用与插件"]},{"title":"SSH的建立","url":"/1715/","content":"\n```bash\nssh-keygen -t rsa -C \"youremail\"\n```\n\n然后一路回车，生成了`.ssh`的文件夹。在你的电脑中找到这个文件夹。\n\n```bash\n~/.ssh/id_rsa.pub\n```\n\n打开[github](https://github.com/)，在头像下面点击`settings`，再点击`SSH and GPG keys`，新建一个`SSH`，名字随便取一个都可以，把你的`id_rsa.pub`里面的信息复制进去。","tags":["git"],"categories":["Web前端"]},{"title":"CSS通用初始化","url":"/19570/","content":"\n 通用的CSS初始化（也许有用）\n\n**什么是css初始化？**\n\nCSS初始化是指重设浏览器的样式。不同的浏览器默认的样式可能不尽相同，所以开发时的第一件事可能就是如何把它们统一。如果没对CSS初始化往往会出现浏览器之间的页面差异。\n\n**为什么要初始化css？**\n\n因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。<!--more-->\n\n```css\n/*css reset*/\n\t/*清除内外边距*/\n\tbody, h1, h2, h3, h4, h5, h6, p, hr, /*结构元素*/\n\tul, ol, li, dl, dt, dd, /*列表元素*/\n\tform, fieldset, legend, input, button, select, textarea, /*表单元素*/\n\tth, td, /*表格元素*/\n\tpre {\n\t\tpadding: 0;\n\t\tmargin: 0;\n\t}\n\n\t/*重置默认样式*/\n\tbody, button, input, select, textarea {\n\t\t/*font: 12px/1 微软雅黑, Tahoma, Helvetica, Arial, 宋体, sans-serif;*/\n\t\tcolor: #333;\n\t\tfont: 12px/1 \"Microsoft YaHei\", Tahoma, Helvetica, Arial, SimSun, sans-serif;\n\t}\n\th1, h2, h3, h4, h5, h6 {\n\t\tfont-size: 100%;\n\t\tfont-weight: normal;\n\t}\n\tem, i {\n\t\tfont-style: normal;\n\t}\n\n\ta {\n\t\ttext-decoration: none;\n\t}\n\tli {\n\t\tlist-style-type: none;\n\t\tvertical-align: top;\n\t}\n\timg {\n\t\tborder: none;\n\t\t/*display: block;*/\n\t\tvertical-align: top;\n\t}\n\ttextarea {\n\t\toverflow: auto;\n\t\tresize: none;\n\t}\n\ttable {\n\t\tborder-spacing: 0;\n\t\tborder-collapse: collapse;\n\t}\n\n/*常用公共样式*/\n\t.fl {\n\t\tfloat: left;\n\t\tdisplay: inline;\n\t}\n\t.fr {\n\t\tfloat: right;\n\t\tdisplay: inline;\n\t}\n\t.cf:before,\n\t.cf:after {\n\t\tcontent: \" \";\n\t\tdisplay: table;\n\t\t\n\t}\n\t.cf:after {\n\t\tclear: both;\n\t}\n\t.cf {\n\t\t*zoom: 1;\n\t}\n```\n\n","tags":["CSS"],"categories":["Web前端"]},{"title":"vue完整框架大建","url":"/53924/","content":"\n##  **1.用`vue-cli`生成项目**\n\n​     1.1 使用 vue create 创建一个项目\n\n​          1.1.1在终端/cmd输入 vue create 项目名\n\n​           1.1.2按下下方向键选择自定义配置    回车（Enter）\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/vue配置.png)\n\n   按 空格键 选择  `Router`、`Vuex`、`CSS Pre-processors`、`Linter / Formatter` 其它按照默认即可 。选好后  回车 <!--more-->\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/配置1.png)\n\n​            选择2.x版本（或按需选择）回车\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/vue项目2.png)\n\n输入y 回车\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/项目4.png)\n\n 选择 Less 作为css预处理器\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/预编译less.png)\n\n选择 Standard 代码风格\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/代码风格.png)\n\n检查代码风格的时机：保存代码，提交代码 去做检查。\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/检查代码时机.png)\n\n依赖的工具，每一个工具对应生成一个配置文件。而不是统一写在package.json中。\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/依赖工具.png)\n\n是否记录以上选择操作，方便下次快速创建。不记录，因为每次都不一样。\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/记录操作.png)\n\n创建成功\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/创建成功.png)\n\n## **2.了解结构目录**\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/结构目录.png)\n\n## **3.调整目录结构**\n\n需要调整src的目录结构，分工明确，代码可维护性更好。\n\n```bash\nsrc\n├─api            # 接口相关代码，axios相关代码\n├─assets         # 静态资源，css  images ...\n├─components     # 公用级别组件\n├─router         # 路由相关代码\n├─styles         # less相关代码\n├─utils          # 全局工具模块相关代码\n├─views          # 路由级别组件\n└─App.vue        # 根组件\n└─main.js        # 入口文件\n```\n\n## 4.安装常用的npm包\n\n```\nnpm i axios  # 一款基于Promise API 的HTTP客户端   https://github.com/axios/axios\n```\n\n```\nnpm install mockjs    # 生成随机数据，拦截 Ajax 请求   http://mockjs.com/\n```\n\n```\nnpm install moment --save  # 一个轻量级的JS日期库，用于分析、校验、操作和格式化日期  http://momentjs.cn/\n```\n\n```\nnpm i --save lodash  # 一款JS库，封装了很多有用的JS API https://lodash.com/\n```\n\n带更新中.....","tags":["vue"],"categories":["Web前端"]},{"title":"HTTP重定向","url":"/33565/","content":"One of the most common and largely overlooked vulnerabilities by web developers is Open Redirect (also known as \"Unvalidated Redirects and Forwards\").\n\n> 其中一个最常见的，也是大部分被网站开发者忽视的漏洞是开放重定向（也称为 \"无效重定向和转发\"）。\n\n  A website is vulnerable to Open Redirect when parameter values (the portion of URL after \"?\") in an HTTP GET request allow for information that will redirect a user to a new website without any validation of the target of redirect.<!--more-->\n\n> 当HTTP GET请求中的参数值（\"? \"后的部分URL）允许提供信息，将用户重定向到一个新的网站，而不对重定向的目标进行任何验证时，网站就会受到Open Redirect的攻击。\n\n Depending on the architecture of a vulnerable website, redirection could happen after certain action, such as login, and sometimes it could happen instantaneously upon loading of a page.\n\n> 根据易受攻击网站的架构，重定向可能会在某些操作后发生，如登录，有时也可能在页面加载时瞬间发生。\n\nAn example of a vulnerable website link could look something like this: https://www.example.com/login.html?RelayState=http%3A%2F%2Fexample.com%2Fnext\n\n> 一个脆弱的网站链接的例子可能是这样的：: https://www.example.com/login.html?RelayState=http%3A%2F%2Fexample.com%2Fnext\n\nIn this example, \"RelayState\" parameter indicates where to send user upon successful login (In our example it is \"http://example.com/next\").If website doesn't validate the \"RelayState\" parameter value to make sure that target web page is legitimate and intended, attacker  could manipulate that parameter to send a victim to a fake page crafted by attacker: https://www.example.com/login.html?RelayState=http%3A%2F%2FEvilWebsite.com\n\n> 在这个例子中，\"RelayState \"参数表示在用户成功登录后将用户发送到哪里（在我们的例子中是 \"http://example.com/next\"）。如果网站没有验证 \"RelayState \"参数的值，以确保目标网页是合法的，攻击者可以操纵该参数，将受害者发送到一个由攻击者制作的虚假页面：https://www.example.com/login.html?RelayState=http%3A%2F%2FEvilWebsite.com。\n\nOpen Redirect vulnerabilities don't get enough attention from developers because they don't directly damage website and do not allow an attacker to directly steal data that belong to the company. However, that doesn't mean that Open Redirect attacks are not a threat. One of the main uses for this vulnerability is to make phishing attacks more credible and effective.\n\n> 开放式重定向漏洞没有引起开发者的足够重视，因为它们不会直接破坏网站，也不允许攻击者直接窃取数据，而这些数据是属于该公司。然而，这并不意味着Open Redirect攻击不构成威胁。这个漏洞的主要用途之一是使钓鱼攻击更加可信和有效。\n\nWhen an Open Redirect is used in a phishing attack, the victim receives an email that looks legitimate with a link that points to a correct and expected domain. What the victim may not notice, is that in a middle of a long URL there are parameters that manipulate and change where the link will take them.\n\n> 当开放重定向被用于网络钓鱼攻击时，受害者会收到一封看似合法的电子邮件，其中的链接指向一个正确的、预期的域名。受害者可能没有注意到的是，在长长的URL中间，有一些参数可以操纵和改变链接的位置。\n\n To make identification of the Open Redirect even more difficult, redirection could take place after victim provides login on a legitimate website first. Attackers have found that an effective way to trick a victim is to redirect him to a fake website after they enter their credentials on a legitimate page. The fake website would look identical to a legitimate website, and it would ask the victim to re-enter their password. After the victim re-enters their password it would be recorded by the attacker and victim would be redirected back to a valid website. If done correctly, victim would think that he mistyped password once and would not notice that his username and password were stolen.\n\n> 为了使识别开放重定向更加困难，重定向可能发生在受害者先提供登录合法网站之后。攻击者发现，欺骗受害者的有效方法是在受害者在合法网页上输入凭证后将其重定向到一个假网站。这个假网站看起来和合法网站一样，它会要求受害者重新输入密码。当受害者重新输入密码后，攻击者会记录下来，受害者会被重定向到一个有效的网站。如果操作得当，受害者会认为自己打错了一次密码，不会注意到自己的用户名和密码被盗。\n\nPhishing is used in most successful targeted hacks and also regularly in opportunistic attacks. Considering how prominent phishing is in our daily lives, Open Redirect vulnerabilities should not be dismissed.\n\n> 网络钓鱼被用于大多数成功的目标黑客，也经常用于机会主义攻击。考虑到网络钓鱼在我们的日常生活中是多么的突出，Open Redirect漏洞不应该被忽视。\n\nIt would have been unfair to single out any specific website or company as being vulnerable to Open Redirect because so many companies have it. Instead, it's more useful to demonstrate how common those websites are and how easy it is to find them.\n\n> 如果单独指出任何特定的网站或公司容易受到开放重定向的影响，这是不公平的，因为有这么多公司都有这种情况。相反，更有用的是展示这些网站有多普遍，以及找到它们有多容易。\n\nDoing a web search is one of the best tools to find Open Redirect on your own website and across a wider Internet.\n\n> 进行网络搜索是在自己的网站和更广泛的互联网上找到Open Redirect(开放重定向)的最佳工具之一。\n\nGoogle Search allows for a great flexibility in writing search queries, including queries that specifically search through URLs of pages.\n\n> Google搜索可以非常灵活地编写搜索查询，包括专门通过网页的URL进行搜索的查询。\n\nThe following operators and special symbols allow anyone to craft very targeted Google Searches for finding Open Redirects:\n\n> 以下操作符和特殊符号使任何人都可以针对特定的Google搜索，以查找开放重定向：\n\n**allinurl** - operator that tells Google to search within URL for all provided keywords\n\nExample: allinurl:ReturnUrl which searches for web pages that have \"ReturnUrl\" as part of their URL\n\n> allinurl - 操作符，告诉谷歌在URL中搜索所有提供的关键字。\n>\n> 例如：allinurl:ReturnUrl，它可以搜索URL中含有 \"ReturnUrl \"的网页。\n\n**site** - operator that tells to only return results that are on specific domain or a web site\nExample: site:example.com which searches for web pages from example.com\n\n> site - 操作符，指示只返回特定域名或网站上的结果。\n> 例如：site:example.com可以搜索example.com的网页。\n\n**\"\"** - double quotes are a special symbols that used to indicate to search for exact combination of words and symbols within quotes\n\n> \"\"--双引号是一种特殊的符号，用来表示搜索引号内的单词和符号的精确组合。\n\n\\*- The asterisk is a wildcard that represents one or more words\n\n> \\*- 星号是通配符，代表一个或多个词。\n\nUsing these allows us to search for certain tell tale signs of potential Open Redirect:\n\nWe can look for the general presence of \"http\" or \"https\" within parameter area of GET request. For instance:\n\n> 使用这些可以让我们搜索某些潜在的开放重定向的迹象：\n>\n> 我们可以在GET请求的参数区域中寻找 \"http \"或 \"https \"的一般存在。例如，我们可以在GET请求的参数区寻找 \"http \"或 \"https \"的存在:\n\nallinurl:%3Dhttps*\n\n allinurl:%253Dhttps* \n\nallinurl:%3Dhttp* \n\nallinurl:%253Dhttp*\n\nWe can also search for specific, common words related to forwarding within parameter area of GET request. For instance:\n\n> 我们还可以在GET请求的参数区中搜索与转发相关的特定的、常用的词。比如说:\n\nallinurl:\"\\<keyword>=https\" \n\nallinurl:\"\\<keyword>=http\" \n\nallinurl:\\<keyword>=https \n\nallinurl:\\<keyword>=http \n\nallinurl:\\<keyword>%3Dhttps \n\nallinurl:\"\\<keyword>%3Dhttps* \"\n\nallinurl:\\<keyword>%253Dhttps \n\nallinurl:\"\\<keyword>%253Dhttps* \"\n\n...\n\nInstead of \\<keyword>, we would use one of the following words typical of redirects:RelayState, ReturnUrl, RedirectUri, Return, Return_url, Redirect, Redirect_uri, Redirect_url,RedirectUrl, Forward, ForwardUrl, Forward_URL, SuccessUrl, Redir, Exit_url, Destination. This is by no means a comprehensive list of keywords. You can find more by analyzing results from the more general queries looking for a URL in the parameter section of the GET request.\n\n> 我们将使用以下典型的重定向词来代替\\keyword>：RelayState，ReturnUrl，RedirectUri，Return，Return_url，Redirect，Redirect_uri，Redirect_url，RedirectUrl，Forward，ForwardUrl，Forward_URL，SuccessUrl，Redir，Exit_url，Destination。这绝不是一个全面的关键词列表。你可以通过分析GET请求的参数部分中寻找URL的更一般查询的结果来找到更多。\n\nFor targeted searches, you can add \"site:<domain_name>\" to the end of your Google Queries. This can help you identify Open Redirect vulnerabilities on your own website.\n\n> 对于有针对性的搜索，你可以在Google查询的结尾添加 \"site:<domain_name>\"。这可以帮助你找出自己网站上的Open Redirect漏洞。\n\nUsing this simple search technique you can find dozens of Open Redirect vulnerabilities within minutes. List of vulnerable websites includes banking websites, websites of international corporations, trusted companies, beloved projects and numerous websites of smaller organizations. As an additional bonus, each time Google's web crawler comes across new website that has Open Redirect, we will get updated results through our queries.\n\n> 使用这种简单的搜索技术，你可以在几分钟内找到几十个Open Redirect漏洞。易受攻击的网站列表包括银行网站、国际公司网站、值得信赖的公司、心爱的项目和众多小型组织的网站。作为额外的奖励，每次Google的网络爬虫遇到有Open Redirect的新网站，我们都会通过查询得到更新的结果。\n\nThe best way to avoid Open Redirect vulnerability is to avoid redirecting based on parameter controlled by users or supplied through GET method. If redirecting is unavoidable,it can be dealt with by validating a redirect target and sanitizing it using whitelist of approved URLs.\n\n> 避免Open Redirect漏洞的最好方法是避免基于用户控制的参数或通过GET方法提供的重定向。如果重定向是不可避免的，可以通过验证重定向目标，并使用批准的URL白名单对其进行消毒处理。","tags":["http"],"categories":["笔记"]},{"title":"如何正确删除linux分区","url":"/10295/","content":"\n 原因：\n\n​         当初装双系统低估了win10的占量，高估了linux的占量。导致win10空间急速下降，之后找到了cmd终端替代品。就打算删除linux分区，（win10并不识别linux分区）就直接在win10自带的磁盘管理系统，直接删除了分区。结果导致开机无法正常启动系统\n\n解决办法：\n\n1、启动进入Windows系统\n\n2、下载Mbrfix\n\n3、解压到C盘根目录下 \n\n4、打开Windows命令行，也就是开始－运行－打入cmd<!--more-->\n\n5、在命令行下，键入：cd，然后回车\n\n在键入：mbrfix /drive 0 fixmbr /yes回车\n\n6、进入磁盘管理器，把将要删除的Ubuntu分区删除，这里说明一下，其实大家都知道哈，就是Windows里边有ntfs和fat格式，所以非Windows格式的分区即是Ubuntu的分区。\n\n7、右键新的分区，点击创建新的逻辑分区。\n\n8、重启，ok！\n\n如果说你像我一样已经删除了linux，无法进入，而我的做法是在安装一遍linux系统，然后在像上面操作一样\n\n","categories":["笔记"]},{"title":"vuepress上手","url":"/27784/","content":"\n1.创建并进入一个新目录\n\n```bash\nmkdir xxx && cd xxx\n```\n\n2.选择喜欢的包管理器进行初始化\n\n```bash\nyarn init & # npm init\n```\n\n3.将Vuepress安装为本地依赖(不推荐全局安装)\n\n```bash\nyarn add -D vuepress & # npm i -D vuepress\n```\n\n4.创建第一篇文档<!--more-->\n\n```bash\nmkdir docs && echo '# Hello worde' > docs/README.md\n```\n\n5.在packgae.json中添加scripts\n\n```bash\n{\n  \"scripts\": {\n    \"docs:dev\": \"vuepress dev docs\",\n    \"docs:build\": \"vuepress build docs\"\n  }\n}\n```\n\n5.在本地启动服务器\n\n```bash\nyarn docs:dev & # npm run docs:dev\n```\n\n6.在docs中新建`.vuepress`文件夹及config.js文件\n\n```bash\nmkdir .vuepress && cd .vuepress/ && touch config.js\n```\n\n7.在`.vuepress`文件夹新建`public`\n\n```bash\nmkdir public  // 用来放网页标签的图标\n```\n\n8.在config.js中写入\n\n```js\nmodule.exports = {\n    title: '名字',    // 网页标题\n    description: 'xxx',  // 随便起\n    // 注入到当前页面的 HTML <head> 中的标签\n    head: [\n      ['link', { rel: 'icon', href: '/favicon.ico' }], // 增加一个自定义的 favicon(网页标签的图标)\n    ],\n    base: '/xxx/', // github仓库地址\n    markdown: {\n      lineNumbers: true // 代码块显示行号\n    },\n    themeConfig: {\n      sidebarDepth: 2, // e'b将同时提取markdown中h3 和 h3 标题，显示在侧边栏上。\n      lastUpdated: 'Last Updated',// 文档更新时间：每个文件git最后提交的时间\n   //   主页导航栏\n      nav:[\n        { text: 'xxx', link: 'xxx' }, // link处添外部链接（仓库地址码云或者github）\n        // 下拉列表\n        {\n          text: 'xxx',\n          items: [\n            { text: 'xxx', link: 'xxx' },\n            {\n              text: 'xxx',\n              link: 'xxxx'\n            }\n          ]\n      }\n       ],\n        // 侧边栏\n        sidebar: [\n          ['/', 'xxx'],    // README.md\n          {\n            title: 'xxx',\n            collapsable: false,\n            children:[\n                ['/help/one.md', '标题名'],\n            ]\n          },     \n        ]\n          }\n    }\n```\n\n9.在你的项目(根目录)中创建一个`deploy.sh`文件（请自行判断去掉高亮行的注释）\n\n```sh\n#!/usr/bin/env sh\n\n# 确保脚本抛出遇到的错误\nset -e\n\n# 生成静态文件\nnpm run docs:build\n\n# 进入生成的文件夹\ncd docs/.vuepress/dist\n\n# 如果是发布到自定义域名\n# echo 'www.example.com' > CNAME\n\ngit init\ngit add -A\ngit commit -m 'deploy'\n\n# 如果发布到 https://<USERNAME>.github.io\n# git push -f git@github.com:<USERNAME>/<USERNAME>.github.io.git master\n\n# 如果发布到 https://<USERNAME>.github.io/<REPO>\n# git push -f git@github.com:<USERNAME>/<REPO>.git master\n\ncd -\n```\n\n10.写完之后运行sh打包上传\n\n```bash\nsh deploy.sh\n```\n\n","tags":["vue"],"categories":["Web前端"]},{"title":"Cygwin安装配置","url":"/35930/","content":"\n<a href='https://www.cygwin.com/'>Cygwin</a>是：\n\n- GNU和开放源代码工具的大量集合，它们提供的功能类似于 Windows上的 Linux发行版。\n\n- 提供实质性POSIX API功能的DLL（cygwin1.dll）。<!--more-->\n\n  ## 安装\n\n  ### 1.下载Cygwin\n\n  <img src=\"https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/下载Cygwin.png\" style=\"zoom: 50%;\" />\n\n### 2.打开安装包\n\n<img src=\"https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/下一步.png\" style=\"zoom: 67%;\" />\n\n### 3.按需选择\n\n<img src=\"https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/选择.png\" style=\"zoom:67%;\" />\n\n### 4.选择安装目录\n\n<img src=\"https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/安装目录.png\" style=\"zoom: 80%;\" />\n\n### 5.选择本地目录（里面文件可以删除）\n\n<img src=\"https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/创建本地目录.png\" style=\"zoom: 80%;\" />\n\n### 6.设置代理\n\n<img src=\"https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/设置代理png.png\" style=\"zoom:80%;\" />\n\n### 7.选择镜像源\n\n<img src=\"https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/镜像源的选择.png\" style=\"zoom:80%;\" />\n\n### 8.下一步\n\n<img src=\"https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/弹出框.png\" style=\"zoom: 50%;\" />\n\n### 9.下一步\n\n### 10.完成\n\n## 配置 需要安装（dos2unix、wget、lynx）\n\n### 还是打开安装程序按照安装过程到第8步(先不要关闭！！！先不要关闭！！！先不要关闭！！！)  \n\n<img src=\"https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/full.png\" style=\"zoom:67%;\" />\n\n先从github克隆<a href='https://github.com/transcode-open/apt-cyg'>apt-cyg</a>  [git clone https://github.com/transcode-open/apt-cyg]   <font color=#c91627 size=5>PS：在Cygwin上克隆</font>\n\ncd apt-cyg   【进入apt-cyg目录】\n\ninstall  apt-cyg   /bin    【将apt-cyg安装到/bin目录下】\n\n下载东西【例如：apt-cyg install vim】，如果不出意外会出报错\n\n> /usr/bin/apt-cyg:行25: $'\\r': 未找到命令 \n>\n> /usr/bin/apt-cyg:行121: 未预期的符号 `$'{\\r'' 附近有语法错误`\n>\n>  ` 'usr/bin/apt-cyg:行121: `function wget {\n\n### 需要下载dos2unix\n\n<img src=\"https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/dos2unix.png\" style=\"zoom:67%;\" />\n\n**1.在终端输入cd ../..  && ls**\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/重新编译.png)\n\n2.   **cd usr/bin/**\n\n在终端输入 dos2unix apt-cyg会显示dos2unix: 正在转换文件 apt-cyg为Unix格式...，然后在运行apt-cyg install vim 就不会报上面的错误\n\n但是下载的时候会显示\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/wget.png)\n\n或者  lynx: 未找到命令\n\n需要安装lynx和安装wget  和下载doswunix一样\n\n之后下一步下一步\n\n## QAQ:\n\n### 1.如何切换zsh？\n\n vim  .bash_profile\n\n在最后一行加入exec zsh 保存退出\n\n【ps： 按i  最后一行输入exec zsh  按Esc  按:输入wq 按enter】\n\n重新打开\n\n### 2.切换zsh重新打开乱码？\n\n需要安装oh-my-zsh\n\n<a href='https://ohmyz.sh/'>官网</a>或者\n\n链接：https://pan.baidu.com/s/1pKsMhbz1ahx1F9fWj57k_g \n提取码：obva   \n\n注：百度盘不一定是最新的(但可以更新到最新)\n\n### 3.如何更新oh-my-zsh？\n\nomz update\n\n### 4.如何查看oh-my-zsh安装成功？\n\n如下图显示就安装成功了\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/oh-my-zsh.png)\n\n失败请安装git 【apt-cyg install git】\n\n### 5.主题如何获取？\n\n<a href='https://github.com/ohmyzsh/ohmyzsh/wiki/Themes'>主题地址</a>\n\n### 6.如何更改zsh主题？\n\n终端输入vim  .zshrc\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/主题名称.png)\n\n箭头处更改主题名称\n\n### 7.为什么不能输入/如何保存退出？\n\n按 i 进入编辑   更改完成后 按 ESC   然后按 :  输入wq 按Enter 重新启动\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/i.png)\n\nps：别忘了按ESC\n\n\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/wq.png)\n\n### 8.如何更改Cygwin语言设置？\n\n终端任意位置点击鼠标右键\n\n<img src=\"https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/设置.png\" style=\"zoom: 55%;\" />\n\n点击Options （看图UI language选择语言） \n\n<img src=\"https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/语言.png\"  />\n\n选择（zh_CN）完之后点击Apply\n\n### 9.如何调整窗口大小（不是关闭恢复原状）？\n\n设置 -窗口（调整窗口到合适大小）-点击当前大小---然后应用\n\n### 10.如何打开Windows中的文件/文件夹？\n\n*cygstart*  xxx\n\n","tags":["软件"],"categories":["应用与插件"]},{"title":"如何部署vuepress","url":"/5652/","content":"\n  在项目中，创建一个`deploy.sh`文件（请自行判断，去掉高亮行的注释）\n\n```sh\n#!/usr/bin/env sh\n\n# 确保脚本抛出遇到的错误\nset -e\n\n# 生成静态文件\nnpm run docs:build\n\n# 进入生成的文件夹\ncd docs/.vuepress/dist\n\n# 如果是发布到自定义域名\n# echo 'www.example.com' > CNAME\n\ngit init\ngit add -A\ngit commit -m 'deploy'\n\n# 如果发布到 https://<USERNAME>.github.io\n# git push -f git@github.com:<USERNAME>/<USERNAME>.github.io.git master\n\n# 如果发布到 https://<USERNAME>.github.io/<REPO>\n# git push -f git@github.com:<USERNAME>/<REPO>.git master\n\ncd -\n```\n\n**如何在windows下运行sh？**\n\n如果有Git则直接打开终端输入`sh xxx.sh`(ps:xxx为你起得名字)","tags":["vue"],"categories":["笔记"]},{"title":"Sandboxie沙盒","url":"/42744/","content":"\n[Sandboxie](https://sandboxie-plus.com/Sandboxie) ，是一款从底层操作系统层面，将真实系统环境与虚拟系统隔离，以防止个人数据、程序等不受未知程序或有风险操作影响的**Windows端沙盘/沙箱软件。**\n\n[GitHub](https://github.com/sandboxie-plus/Sandboxie/releases)下载","tags":["软件"],"categories":["应用与插件"]},{"title":"EndNote软件","url":"/63264/","content":"\n 借助 EndNote X9 更智能地研究，告别设置文献格式、全文查找、搜索和整理参考书目之类的繁琐工作\n\n整理pdf以及word或者文献<a href='https://buy.endnote.com/1603/purl-buy'>EndNote X9</a> [官网需要购买PS：贵。淘宝：不能升级（废且51元）]<font color='#d65071' size=5>都不建议购买,除非你确定买来不吃灰</font>\n\n","tags":["软件"],"categories":["应用与插件"]},{"title":"当代心理学观点","url":"/60125/","content":"\n​          当代心理学观点是一种观察心理学议题的方式或者取向，并在五个观点的基础上进行折中取向。生物观点以生物取向来区辨出行为和心理现象下的生物神经过程，探究行为与心理历程的神经生物过程的研究取向。行为观点则是以条件作用与强化作用观点来探究可观察行为的研究取向如：S-R（刺激-反应）。认知观点回归认知基础但并非以内省法为基础，而是以两种假设为前提（1.心智历程的研究可着完全了解有机体的所作所为2.心智历程的研究可着眼于对特殊行为的客观观察，并以内在心智历程观点解释。）来探索诸如知觉、记忆、决策于问题解决等心理过程，以及它们与行为关系。心理分析则是以认知概念与生物基本本能的想法结合，以源自性与攻击冲动的无意识观点，来探索，并提出大多数行为的产生来自无意识过程，即人们不自知但却可影响其行为的思想、恐惧和欲望等。\n\n​       主观论者以人们主动建构的主观现实，来探究行为与心理历程，并主张人类行为是他所知觉的世界，而非客观世界。【朴素的现实主义⑴】 与认知论（格式塔）来对抗行为论的狭缢论点\n\n⑴指人们会倾向于将自己建构好的、主观的现实，理解为忠实地表现了客观世界","tags":["西尔格德心理学导论"],"categories":["爱好心理学"]},{"title":"React-Redux技术要点","url":"/45636/","content":"\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/react.jpg)\n\n<!--more-->\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E7%BB%84%E5%BB%BA%E9%80%9A%E8%AE%AF.jpg)","tags":["react"],"categories":["Web前端"]},{"title":"涂鸦？","url":"/1374/","content":"\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E7%9B%86%E6%A0%BD.jpg)","tags":["画"],"categories":["生活与话"]},{"title":"Krita软件","url":"/4494/","content":"\n<a href=\"https://krita.org/zh/\">Krita </a> 是一款由社区驱动的自由开源数字绘画软件，可免费使用，无任何商用限制，让每一位画师都可以随心所欲地表达创意。\n\n- 适合：概念草图、插画、漫画、动画、接景和 3D 贴图\n\n- 支持：数位板、压感、防抖、图层、滤镜、色彩管理等\n\n- 中文：软件、文档和网站内建官方中文版\n\n  <a href='https://docs.krita.org/zh_CN/'>Krita 4.3文档</a>","tags":["软件"],"categories":["应用与插件"]},{"title":"如何建立自己的知识体系?","url":"/46898/","content":"\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.jpg)\n\n","tags":["知识点"],"categories":["笔记"]},{"title":"怎样才算会读书？","url":"/37166/","content":"\n> 类比一下这个问题：“怎么才算会吃饭？”\n>\n> 一口尝出七八味作料算会吃（**对书本理解非常透彻**），还是吃完之后能舌灿如花地点评（**善于写各种书评**）算会吃？\n> 吃完了马上到厨房COPY一份几乎尝不出差别的复制品（**能够学以致用指导人生**）算会吃，还是悠悠道来这道菜的悠久历史（**善于触类旁通**）才算会吃？\n>\n> 活到现在基本健康的人们都出来回答一下，你觉得怎么才算会吃饭？\n>\n> 读个书而已，多大点事啊。\n>\n> 知乎对读书的矫枉过正也不是一两天了~但是读书不过就是读书啊，想要读成博士或者想要读成大师，想要通透地理解一本书，跟“会读书”应该不是一个概念吧。而且呀，知行合一不是那么容易做到的，古人说<u>“知易行难”</u>诚不欺我也啊。\n>\n> 读书跟吃饭都是个动宾短语，一个是供养精神，一个是供养身体，真的没必要搞得跟参拜一样。能在西餐厅礼仪万方地吃饭，不意味着在大排档站着聊天啃串的人就不会吃饭了。\n>\n> 邯郸学步大概就是说这个状态。有人善于走猫步，漂亮潇洒高端大气，但这不意味着别人都不会走路了。而且我也不觉得只有那样才叫“会走路”。\n>\n> **想读书，就读；跟饿了就吃饭一样。**\n\n<怎样才算读书?> <a href='https://www.zhihu.com/question/21293180'>知乎</a>  \n\n\n\n\n","tags":["我的读书笔记"],"categories":["笔记"]},{"title":"腾讯COS+PicGo","url":"/49917/","content":"\n1.1登录<a href='https://cloud.tencent.com/'>腾讯云</a>搜索COS（对象存储）\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/Snipaste_2020-07-28_12-57-59.png)\n\n1.2点击立即使用![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/Snipaste_2020-07-28_13-00-06.png)\n\n1.3之后是实名认证之类的（微信）\n\n1.4进入对象存储桶列表创建存储桶<!--more-->\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/Snipaste_2020-07-28_13-03-31.png)\n\n1.5填写(看情况填写)\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/Snipaste_2020-07-28_13-15-09.png)\n\n1.6申请API密钥\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/Snipaste_2020-07-28_13-17-29.png)\n\n会提示（继续使用）\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/Snipaste_2020-07-28_13-18-19.png)\n\n新建密钥\n\n2.在PicGo填写\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/Snipaste_2020-07-28_13-26-05.png)\n\n注：COS版本选择V5（我选V4不能上传）","tags":["软件"],"categories":["应用与插件"]},{"title":"Github图床+PicGo","url":"/39897/","content":"\n1.新建图床仓库\n\n  1.1 在Github中创建一个仓库\n\n  1.2在Github生成一个token（给PicGo使用）<!--more-->\n\n![image](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/%E8%AE%BE%E7%BD%AE.jpg)\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/Snipaste_2020-07-27_19-35-02.png)\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/Snipaste_2020-07-27_19-36-52.png)\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/Snipaste_2020-07-27_19-40-03.png)\n\n1.3之后点最下面的<button>Generate token</button>,会生成一串token，注：生成的token最好保存到本地，因为下次再进GitHub的时候，这个token就不再显示了。\n\n2.PicGo客户端\n\n<a href=\"https://github.com/Molunerfinn/PicGo/releases\">PicGo下载</a>\n\n![](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/Snipaste_2020-07-27_20-13-48.png)\n\nPS:仓库名就是github用户名/仓库名，前/后什么都不加。分支默认master。上一部生成的token。存储路径可写可不写\n\n","tags":["软件"],"categories":["应用与插件"]},{"title":"vue知识体","url":"/29737/","content":"\n![image](https://img-1302744895.cos.ap-hongkong.myqcloud.com/img/123.jpg)","tags":["vue"],"categories":["Web前端"]},{"title":"html语义化（基本）","url":"/32840/","content":"\n  根据内容的结构化，选择合适的标签\n\n优点：\n\n有利于SEO。有利于开发与维护。有利于用户阅读，在丢失样式时，能让页面呈现清晰的结构。方便设备解读\n\n扩展：\n\nhtml5是什么？\n\n是html标准的最新演进的版本，多样化，功能更强大\n\n<!--more-->\n\n新特征：\n\n1.语义特性\n\n2.多媒体\n\n3.图像效果\n\n4.设备兼容性\n\n5.离线或存储\n\n6.性能与集成特性\n\n\n\ncss选择器\n\n通配符选择器 。 类选择器。 id选择器 。伪类选择器 。 后代选择器 。 属性选择器\n\n！important -行内样式 - id选择器 - 类选择器 - 伪类选择器 - 通配符选择器 - 继承 - 默认","tags":["面试题"],"categories":["算法与面试题"]},{"title":"rem和em的区别","url":"/26937/","content":"\n   rem：表示根元素字体的大小 em：表示父元素（fontsize）大小","tags":["面试题"],"categories":["算法与面试题"]},{"title":"W3C标准是什么","url":"/8065/","content":"\n1.结构标准，代表语言是xHTML\n\n2.表现标准，代表语言是CSS\n\n3.动作标准，代表语言是JavaScrip\n\n除了以上的标准，还有XML，DOM标准\n\n<!--more-->\n\n扩展：\n\nXHTML\n\n可扩展超文本标记语言，是一种[标记语言](https://baike.baidu.com/item/标记语言)，表现方式与超文本标记语言（HTML）类似，不过语法上更加严格。\n\nXML\n\n   XML 被设计用来传输和存储数据。","tags":["面试题"],"categories":["算法与面试题"]},{"title":"MVC开发思想","url":"/37639/","content":"\nMVC即Model、View、Controller即模型、视图、控制器。是一种软件架构的思想，将一个软件按照模型、视图、控制器进行划分。模型用来封装业务逻辑，视图用来实现表示逻辑，而控制器用来协调模型与视图","tags":["面试题"],"categories":["算法与面试题"]},{"title":"c语言学习思路","url":"/7790/","content":"\n1）数据类型：\n需要死记硬背。其中--浮点数表示法 需要学习下 程度达到能理解就行\n二进制 十进制 十六进制 8进制也需要了解\n整数的负数表示方法\n2) 判断 分支 循环 和 数组\n会了数组和循环后,就可以学基础的三个排序算法: 选择 冒泡 插入,其中冒泡在吧里讨论最广泛,有很多问题出现\n\n然后会接触到 随机函数，时间函数，和 个别的数学函数\n3) 基本的输入和输出函数\nprintf 和 scanf 需要非常熟悉, 同样有很多问题会拿出来讨论\n4) 流程图 以及 NS流程图的画法\n5) 函数 以及 函数调用栈\n6) 字符串、字符串输入输出、字符串常用函数\n7) 指针：\n需要多练练，需要弄得很懂。字符串的几个函数和指针的联系很紧，尝试用自己的方法实现字符串的几个常用函数，对理解指针会很有帮助。\n\n8) 文件和文件输入输出\n9) 结构体 联合体\n10) 数据结构和算法中的基础部分 ---链表","tags":["C"],"categories":["语言与Linux"]},{"title":"Git命令","url":"/19993/","content":"\n  git branch <分支名>     新建分支\n\n  git checkout <分支名>    切换分支\n\n合并分支：\n\ngit merge一:\n\n| git checkout -b <分支名> | 新建并切换分支名 |\n| ------------------------ | ---------------- |\n| git commit -m '注释'     | 提交注释         |\n| git push origin <分支名> | 上传             |\n| git checkout master      | 切换主分支       |\n| git merge <分支名>       | 合并分支         |\n\ngit rebase二： \n\n| git checkout -b <分支名> | 新建并切换分支名 |\n| :----------------------- | ---------------- |\n| git commit -m '注释'     | 提交注释         |\n| git checkout master      | 切换主分支       |\n| git commit -m '注释'     | 提交注释         |\n| git checkout <分支名>    | 切换分支         |\n| git rebase master        | 合并到主分支     |\n\n相对引用：\n","tags":["git"],"categories":["语言与Linux"]},{"title":"话十肆","url":"/54747/","content":"\n我们没有人可以凭借与众不同而与众不同，因为与众不同是你所能做的最与众不同的事情，因为它是一件会自然而然地发生在每个人身上的事情。所以，相比“做一个与众不同的人”,我们或许更应该说：“尽情地做个显而易见的混蛋吧，因为与众不同已经让别人占有了。”——已经被所有人占有了，这可真讽刺呀！\n\n  或者，我们应该把这句话改为“不要甘于平庸，要做一个最平庸的人”。","tags":["话"],"categories":["生活与话"]},{"title":"Linux美化","url":"/50051/","content":"\n主题图标网址：https://www.pling.com/browse/cat/381/order/latest/\n\n管理界面：https://github.com/elementary-tweaks/elementary-tweaks","tags":["Linux"],"categories":["语言与Linux"]},{"title":"推理小说","url":"/63311/","content":"\n- [x]  怪盗的二十面相\n- [ ] 魔术师\n- [x] 八声甘州\n- [ ] 蜘蛛男（3/10）\n- [ ] 钟表馆事件<!--more-->\n- [ ] 血字研究\n- [ ] 四签名\n- [ ] 红发会\n- [ ] 跳舞的小人\n- [ ] 北方夕鹤2/3杀人事件\n- [x] 占星术杀人魔法\n- [ ] 东方快车谋杀事件\n- [ ] 尼罗河上的惨案\n- [ ] 无人生还\n- [ ] 斜屋犯罪\n- [ ] 异邦骑士\n- [ ] 奇想，天动\n- [ ] 克莱因壶","categories":["笔记"]},{"title":"词","url":"/41277/","content":"\n| 拼音                        | 词解释                                 |\n| --------------------------- | -------------------------------------- |\n| lian pian lei du（2 1 3 2） |                                        |\n| 连篇累牍                    | 篇幅过多，文辞冗(rong)长               |\n| an cun (4 3)                |                                        |\n| 暗忖                        | 思量，盘算，推算                       |\n| ao sang (4 4)               |                                        |\n| 懊丧                        | 因事情不如意而情绪低落                 |\n| an zi si cun (4 4 1 3)      |                                        |\n| 暗自思忖                    | 在私底下里思量；在暗地：~盘算 \\| ~高兴 |\n| ji ( 4)                     |                                        |\n| 蓟                          | 草本植物：大蓟                         |\n|                             |                                        |\n\n","categories":["笔记"]},{"title":"话十叁","url":"/17423/","content":"\n“愿灵魂安息吧。” 这句话相当自私。它的根本意思是：“待在你的坟墓里，别在我身边游荡”。 相反的一句话会是：“动不动翻个身吧” 和 “去跑个步吧”。","tags":["话"],"categories":["生活与话"]},{"title":"话十二","url":"/4488/","content":"\n了解一件事是桥梁和道路上回转的可能性，解释一件事却是专横独断，有时甚至是谋杀了。","tags":["话"],"categories":["生活与话"]},{"title":"c语言的数据类型","url":"/9374/","content":"\n|      | 基本类型 |                           |\n| ---- | -------- | ------------------------- |\n| 整型 | 字浮型   | 实型（浮点型）            |\n| int  | char     | 单精度型    \\|   双精度型 |\n|      |          | float        \\|    double |\n\n------\n\n\n\n|          |          | 构造类型 |            |            |\n| -------- | -------- | -------- | ---------- | ---------- |\n| 枚举类型 | 数组类型 |          | 结构体类型 | 共用体类型 |\n\n------\n\n\n\n|      |      | 指针类型 |      |      |\n| ---- | ---- | -------- | ---- | ---- |\n|      |      |          |      |      |\n\n------\n\n\n\n|      |      | 空类型 |      |      |\n| ---- | ---- | ------ | ---- | ---- |\n|      |      |        |      |      |\n\n小记：浮点数据指带小数点后的数字","tags":["C"],"categories":["语言与Linux"]},{"title":"歌声","url":"/65017/","content":"\n在时间的沙池中 我终于听到了 那柔和的心跳声 可是却无法触碰 在爱的阳炎下 赤着脚丫 飞驰而去  我和你是相反的存在 在那个我们相互追逐的春天里的某一天 在风儿的带动下 沙砾翩翩起舞 如果这个世界宛如瓶底的话 把它翻转过来的话 我们的明天就能永远描绘下去 在最后 请把爱的残月给予我 仅需那一秒的时间 就那么一秒钟 宛如剥落星辰一般 脸庞传来你指尖的感触 把拂晓照亮了","categories":["笔记"]},{"title":"第一章复习题","url":"/27154/","content":"\n1.对编程而言，可移植性意味着什么？\n\n{% spoiler 答 %}\n在一中系统中编写的c程序稍作修改或不修改就能在其他系统运行\n{% endspoiler %}\n\n2.解释源代码文件、目标代码文件、可执行文件有什么区别？\n\n{% spoiler 答 %}\n源代码文件包含程序员使用的任何编程语言编写的代码。\n\n目标代码文件包含机器语言代码，它不必是完整的代码。\n\n可执行文件包含组成可执行程序的完整机器语言代码。\n{% endspoiler %}\n\n3.编程的7个主要步骤？<!--more-->\n\n{% spoiler 答 %}\n1.定义程序的目标\n2.设计程序\n3.编写代码\n4.编译\n5.运行程序\n6.测试和调试程序\n7.维护和修改程序\n{% endspoiler %}\n\n4.编译器的任务是什么？\n\n{% spoiler 答 %}\n把源代码转换成中间代码\n{% endspoiler %}\n\n5.链接器的任务是什么？\n\n{% spoiler 答 %}\n把中间代码和其他代码合并，生成可执行文件\n{% endspoiler %}\n\n\n\n","tags":["C"],"categories":["语言与Linux"]},{"title":"C基础","url":"/51326/","content":"\nC（嵌入式语言）是一门功能强大的专业化编程语言。强大的控制结构、快速、代码紧凑、可移植性。\n\nC语言中的6个语句：\n\n语句：【标号语句  复合语句 表达式语句 选择语句 迭代语句 跳转语句】-----关键字、标识符、运算符、数据\n\n```c#\n【典型的c程序】\n    |                                          <stdio.h>--------------头文件(包含了编译器创建最终可执行程序要用的到信息)\n    |----#include---------预处理器指令\n    |-----int main ()----------------总是第一个被调用的函数\n    |                     |________________________________语句--------------组成函数的语句\n    |------function a()\n    |                 |________________________语句\n    |\n    |-------function b()\n    |               |     |__________________语句\n    |   函数是C程序的构造块                      \n```\n\nmain()函数 c语言一定从main函数执行。圆括号用于识别main（）是一个函数<!--more-->\n\nint则是main函数返回类型。\n\n注释：编译器会忽视\n\n```js\n/* 这是一种注释*/\n// 这也是一种注释\n```\n\n花括号、函数体、块\n\n```c\n{\n    ...   // 花括号会把main函数扩起来。也就是开始和结束。也可以把函数中的多条语句合并为一个单元格或块\n}\n```\n\n声明：c语言中声明是最重要的特性之一\n\nEg：int mun   mun是一个变量，int则表明mun是一个整数（int则是一种数据类型）\n\n命名：给变量命名时要使用有意义的变量名或标识符 PS: c99和c11允许使用更长的标识符名，但编译器只识别前63个~~(但是没意义，63个手不累吗？)~~\n\nEg：可以用小写字母、大写字母、数字、下划线( _ ) 来命名。注：名字的第一个字符必须是字母或下划线，<font color=#D32525>不能是数字</font>。c语言的命名大小要区分，一个字母的大小写会被视为两个不同的字符。\n\n声明变量的4个理由：\n\n1.把所有的变量放在一处，方便读者查找和理解程序的用途。变量名要有意义，如果无法表述清楚，则注释解释变量的含义、\n\n2.声明变量会促使在编写程序之前做些计划\n\n3.声明变量有助于发现隐藏的bug。拼写错误等\n\n4.未声明变量则无法编译\n\n赋值：从右侧把值赋到左侧\n\nprintf()函数：一个标准函数PS：打印？\n\nreturn语句：返回值的c函数要有return语句...\n\n<font color=#138091 size=5>扩展：</font>","tags":["C"],"categories":["语言与Linux"]},{"title":"vscode代码片段(html篇)","url":"/20701/","content":"\n   此篇用于创建html代码片段，代码如下：\n\n“prefix”: “vh”,指的是你自定义的快捷代码,输入vh就会出现快速生成代码提示，也可以自定义其他字段。\n\n<!--more-->\n\n```html\n{\n\t \"Html5-Vue\": {\n        \"prefix\": \"vh\", \n        \"body\": [\n            \"<!DOCTYPE html>\",\n            \"<html lang=\\\"zh-CN\\\">\\n\",\n            \"<head>\",\n            \"\\t<meta charset=\\\"UTF-8\\\">\",\n            \"\\t<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\">\",\n            \"\\t<meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"ie=edge\\\">\",\n            \"\\t<title>Document</title>\",\n            \"</head>\\n\",\n            \"<body>\",\n            \"\\t<script>\",\n\t\t\t\"\\t</script>\",\n            \"</body>\\n\",\n            \"</html>\"\n        ]\n    }\n}\n```\n\n\n\n","tags":["代码片段"],"categories":["Web前端"]},{"title":"vscode代码片段(vue篇)","url":"/33475/","content":"\n 此篇用于快速创建vue模板，代码如下: \n\n管理------>用户代码片段---------->新建全局代码片段 `xxx.json`  PS：覆盖\n\n“prefix”: “vue”,指的是你自定义的快捷代码，输入vue就会出现快速生成代码提示，也可以自定义其他字段。\n\n<!--more-->\n\n```vue\n{\n\n\t\t\"Print to console\": {\n\t\t  \"prefix\": \"vue\",  \n\t\t  \"body\": [\n\t\t\t\"<!-- $1 -->\",\n\t\t\t\"<template>\",\n\t\t\t\"<div></div>\",\n\t\t\t\"</template>\",\n\t\t\t\"\",\n\t\t\t\"<script>\",\n\t\t\t\"export default {\",\n\t\t\t\"data() {\",\n\t\t\t\"return {\",\n\t\t\t\"\",\n\t\t\t\"}\",\n\t\t\t\"},\",\n\t\t\t\"//生命周期 - 创建完成（访问当前this实例）\",\n\t\t\t\"created() {\",\n\t\t\t\"\",\n\t\t\t\"},\",\n\t\t\t\"//生命周期 - 挂载完成（访问DOM元素）\",\n\t\t\t\"mounted() {\",\n\t\t\t\"\",\n\t\t\t\"}\",\n\t\t\t\"}\",\n\t\t\t\"</script>\",\n\t\t\t\"<style scoped>\",\n\t\t\t\"/* @import url(); 引入css类 */\",\n\t\t\t\"$4\",\n\t\t\t\"</style>\"\n\t\t  ]\n\t\t}\n\t  \n}\n```\n\n","tags":["代码片段"],"categories":["Web前端"]},{"title":"javascript语句","url":"/48715/","content":"\n语句：使用一或多个关键字来完成给定任务\n\nif语句：可以嵌套多个if...esle...\n\n```js\nif () {\n    ...\n  } else {\n    ...\n}\n```\n\ndo-while语句: 一种后测试循环语句  PS：最常用于循环体中的代码至少要被执行一次的情形<!--more-->\n\n```js\ndo {\n    ...\n} while (...)\n```\n\nwhile语句: 在某个条件表达式为真的前提下，循环执行指定的一段代码，直到那个表达式不为真时结束循环。\n\n```js\nwhile (...) {\n    ...    \n   }\n```\n\nfor语句：用于创建一个循环，它包含了三个可选的表达式\n\n```js\nfor ([initialization]; [condition]; [final-expression]) {\n    ...\n}\n```\n\nfor-in语句：以任意顺序遍历一个对象的 \n\n```js\nfor (variable in object) {\n    ...\n}\n```\n\n注：for...in是为遍历对象属性而构成的，不建议与数组一起使用 PS：数组可以用`Array.prototype.forEach()` 和 `for...of`\n\nlabel语句：标记就是在一条语句前面加个可以引用的标识符（identifier）（了解？？？）","tags":["js"],"categories":["Web前端"]},{"title":"常见错误(二)","url":"/26624/","content":"\n### 17.'vue-cli-service' 不是内部或外部命令，也不是可运行的程序\n\n解决：\n\n删除`node_modules`文件夹，重新运行`npm install`\n\n### 18.npm install 报错（npm ERR! errno -4048，Error: EPERM: operation not permitted,）\n\n> npm ERR! code EPERM\n> npm ERR! syscall unlink\n> ......\n> npm ERR!   errno: -4048,\n> npm ERR!   code: 'EPERM',\n> npm ERR!   syscall: 'unlink',\n> npm ERR!   path: 'C:\\\\Users\\\\15969\\\\Desktop\\\\vue-admin-beautiful\\\\node_modules\\\\.staging\\\\echarts-9aadd223\\\\dist\\\\echarts-en.common.min.js',\n> npm ERR!   parent: 'vue-admin-beautiful'\n> npm ERR! }\n> npm ERR!\n> npm ERR! The operation was rejected by your operating system.\n> npm ERR! It's possible that the file was already in use (by a text editor or antivirus),\n> npm ERR! or that you lack permissions to access it.\n> npm ERR!\n> npm ERR! If you believe this might be a permissions issue, please double-check the\n> npm ERR! permissions of the file and its containing directories, or try running\n> npm ERR! the command again as root/Administrator.\n\n解决方案：<!--more-->\n\n```text\n首先检查是不是管理员运行，如果不是则用管理员运行命令。\n```\n\n或\n\n```text\n 清除npm缓存npm cache clean --force\n```\n\n或\n\n```text\n删除C:\\Users\\{账户}\\下的.npmrc文件..\n```\n\n终极方案：npm cache verify  PS：大概估计也许可能有用。我没用过[npm](https://docs.npmjs.com/cli/cache)\n\n### 19.Git报错：error: failed to push some refs to\n\n```\nTo https://xxx.com/xxx/xxx.git\n ! [rejected]        master -> master (fetch first)\nerror: failed to push some refs to 'https://xxx.com/xxx/xxx.git'\nhint: Updates were rejected because the remote contains work that you do\nhint: not have locally. This is usually caused by another repository pushing\nhint: to the same ref. You may want to first integrate the remote changes\nhint: (e.g., 'git pull ...') before pushing again.\nhint: See the 'Note about fast-forwards' in 'git push --help' for details.\n```\n\n错误原因：在推送前没有进行本地仓库和远程服务器的同步\n\n解决方法：\n\n如果确定本地是最新的则强行推送\n\n`git push -f origin master`\n\n### 20.解决Git建立远程分支关联时fatal the current branch master has no upstream branch 问题\n\n发生的原因：\n\n  执行sh的时候推送没推上去，sh中没由写master\n\n解决办法：\n\ngit push -u  origin master\n\n### 21.Linux磁盘分区格式化efi报错\n\nbad number of fats : 32\n\n原因：\n\n是虚拟机CapsLock无效\n\n解决办法：\n\n命令mkfs.fat -f32 /dev/sda1\n\n把小写f改成F\n\n### 22.Arch显示不支持EFI变量。\n\n虚拟机设置---选项---高级---选择uefi（如果是灰色需要关闭虚拟机）\n\n注：一定要提前设置好 不然之前的做的工作就白整了^_^\n\n### 23.Linux安装基础包出错\n\n> error : partition / too full:107378 blocks needed\n> error: failed to commit transaction (not enough free disk space)\n> failed to install packages to new root\n>\n> 错误：分区/太满：需要107378个块。\n> 错误：事务提交失败（没有足够的可用磁盘空间）。\n> 未能安装软件包到新的根目录\n\n没挂载sda2\n\nmount /dev/sda2  /mnt\n\n### 24.Linux设置时区出错\n\n> ln: target '/etc/localtime': No such file or directory\n>\n> ln: 目标'/etc/localtime'。没有这样的文件或目录\n\n把`ln -sf /usr/share/zoneinfo $(tzselect) /etc/localtime`\n\n改成`ln -sf /usr/share/zoneinfo$(tzselect) /etc/localtime`\n\n### 25.错误：未能获得'/boot/EFI'的规范路径。\n\n> error :failed to get canonical path of '/boot/EFI'\n>\n> 错误：未能获得'/boot/EFI'的规范路径。\n\n重新安装pacman -S grub efibootmgr \n\n在运行grub-install --target=x86_64-efi --efi-directory=/boot/EFI\n\n### 26.子系统安装hexo-all-minifier报错\n\n**原因一：**缺少依赖\n\n安装依赖\n\n```bash \nsudo apt-get install libtool automake autoconf nasm\n```\n\n**原因二：**网络问题 其中一个包需要在raw.githubusercontent.com下载\n\n需要改host,在终端测试`ping  raw.githubusercontent.com`\n\n然后把测的ip地址放到host里\n\n```bash\nvim /etc/hosts #确保有hosts的更改权限\n```\n\n例如xxx.xxxx.xxx.xx   raw.githubusercontent.com 这样格式。如果还是不行请重启电脑或者尝试多次安装\n\n\n\n","tags":["错误"],"categories":["笔记"]},{"title":"findIndex","url":"/35177/","content":"\n`findIndex()`方法返回数组中满足提供的测试函数的第一个元素的**索引**。否则返回-1。\n\n<font color=#2be5e5>语法：</font>\n\n```js\n   arr.findIndex(callback[, thisArg]) \n```\n\n<font color=#2be5e5>参数：</font>\n\n`callback¹`——>针对数组中的每个元素，都会执行该回调函数，执行时会自动传入三个参数:`element`——>当前元素。`index`——>元素的索引。`array`——>调用findIndex的数组。\n\n`thisArg²`——>（可选）执行`callback`时作为this对象的值。\n\n<font color=#2be5e5>返回值：</font> 数组中通过提供测试函数的第一个元素的**索引**。否则，返回-1","tags":["HTML"],"categories":["Web前端"]},{"title":"选择排序","url":"/51203/","content":"\n  原理：：每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，以此循环，直至排序完毕。\n\n代码：\n\n````js\nvoid select_sort(int arr[], int len){\n    //每次从后边选择一个最小值\n    for (int i = 0; i < len-1; i++){     //只需选择n-1次\n        int min = i;\n        for (int j = i+1; j < len; j++){\n            if (arr[min]>arr[j]){\n                min = j;\n            }\n        }\n        if (min != i){\n            swap(arr[i], arr[min]);\n        }\n    }\n}\n````\n\n","tags":["排序"],"categories":["算法与面试题"]},{"title":"vscode中ESLint配置","url":"/23467/","content":"\n在创建项目选择ESLint，创建项目之后会看到根目录下有个`.eslintrc.js`.\n\n在vscode中对eslint进行配置：在根目录下创建一个文件夹`.vscode`，并在文件夹下创建一个名为`settings.json`的文件，填写一下内容：PS：按下ctrl + s保存代码：自动调试eslint修复\n\n```json\n{\n    \"eslint.run\":\"onType\",\n    \"editor.codeActionsOnSave\": {\n        \"source.fixAll.eslint\": true\n    },\n    \"eslint.alwaysShowStatus\": true\n}\n```\n\n或<!--more-->\n\n管理----设置  然后点击工作区 点击右上角的打开设置（json）添加一下内容：\n\n```json\n{\n    \"eslint.run\":\"onType\",\n    \"editor.codeActionsOnSave\": {\n        \"source.fixAll.eslint\": true\n    },\n    \"eslint.alwaysShowStatus\": true\n}\n```\n\nPS：核实用户设置（json）的插件设置（禁用，防止设置失效）\n\n或\n\n运行`npm run lint` 命令用来eslint检查并自动修复代码中的问题\n\n\n\n如果上述还是报错：\n\n直接在脚手架关掉eslint：首先在根目录下创建一个`vue.config.js`写入以下内容：\n\n```\nmodule.exports = {\n  lintOnSave: false // 默认是true\n}\n```\n\n\n\n","tags":["vue"],"categories":["Web前端"]},{"title":"操作符","url":"/63470/","content":"\n算术操作符（如加号和减号）、位操作符、 关系操作符和相等操作符\n\n<font color=#208dc9 size=4>一元运算符：</font>只能操作一个值的操作符\n\n1.递增或递减\n\n```js\n// 递增\nvar age = 29; \n++age;\n// 递减\nvar age = 29;\n--age;\n```\n\n2.一元加和减操作符  <!--more-->\n\n```js\n// 加\nvar num = 25;\nnum = +num;\n// 减\nvar num = 25;\nnum = -num;\n```\n\n<font color=#208dc9 size=4>位操作符：</font>按内存中表示数值的位来操作数值。（了解？）\n\n<font color=#208dc9 size=4>布尔操作：</font>逻辑运算符\n\n逻辑与(&&) --AND\n\n```js\nx1 && x2 // \n```\n\n逻辑或(||)--OR\n\n```js\nx1 || x2\n```\n\n逻辑非(!)--NOT\n\n```js\n!x\n```\n\n双重非(!!)运算符\n\n```js\n!!x\n```\n\n<font color=#208dc9 size=4>乘性操作符: </font>乘法、除法和求模\n\n1. 乘法  `*`\n2. 除法 `/`      PS：第二个操作数除第一个操作数的计算\n3. 求模`%`     Eg：var result = 26 % 5;\n\n<font color=#208dc9 size=4>加性操作符：</font>加与减----+与-   PS：如果要和字符串相加会被转换成字符串“ var a = 5; var b = \"2\"  a+ b= \"52\";”\n\n<font color=#208dc9 size=4>关系操作符：</font>\n\n小于（<）大于（>）小于等于（<=） 大于等于（>=）\n\n<font color=#208dc9 size=4>相等操作符：</font>\n\n1.相等和不相等\n\n​    ① ==\n\n​    ② !=\n\n2.全等和不全等\n\n​     ① ===\n\n​     ② !==\n\n<font color=#208dc9 size=4>条件操作符：</font>（三元）\n\n语法\n\n```js\ncondition ? exprIfTrue : exprIfFalse\n```\n\n<font color=#208dc9 size=4>赋值操作符:</font> 右侧的值赋给左侧的变量\n\n```js\n// 赋值      // 乘赋值      // 除赋值      // 模赋值     // 加赋值     // 减赋值     // 左移赋值     // 有符合右移赋值   // 无符号右移赋值\nvar a = 10; var a *= 10;  var a /= 10;  var a %= 10;  var a += 10;  var a -= 10;  var a <<= 10;  var a >>= 10;      var a <<<= 10; \n```\n\n<font color=#208dc9 size=4>逗号操作符：</font>逗号操作符多用于声明多个变量","tags":["js"],"categories":["Web前端"]},{"title":"变量与数据类型","url":"/40754/","content":"\nECMAScript的变量是松散类型：可以用来保存任何类型的数据 var let  const\n\n```js\nvar message = 'hello word' // 右边赋值到左边  var 声明语句声明一个变量\nlet message = 'hello word'  // let声明一个块级作用域的本地变量\nconst messgae = 'hello word' // 常量是块级作用域，很像使用 let 语句定义的变量。常量的值不能通过重新赋值来改变，并且不能重新声明。\n```\n\n注：在严格模式下，不能定义名为 eval 或 arguments 的变量，否则会导致语法错误\n\n### <font color=#4dc1bb size=4>数据类型：</font>\n\n5中简单数据类型（基本数据类型）：一种复杂数据类型<!--more-->\n\n| Undefined      | Null                                                         | Boolean                                    | Number                                                       | String                                               |\n| -------------- | ------------------------------------------------------------ | ------------------------------------------ | ------------------------------------------------------------ | ---------------------------------------------------- |\n| 未定义(一个值) | 空对象指针(一个值)                                           | 布尔值                                     | 数值                                                         | 字符串(不可变)                                       |\n|                |                                                              | true与false                                |                                                              | 由双 引号（\"）或单引号（'）表示（左右引号必须匹配*） |\n|                | 如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null 而不是其他值 | true 不一定等于 1，而 false 也不一定等于 0 | 十进制表示外，整数还可以通过八进制（以 8 为基数）或十六进制（以 16 为基数）的字面值 来表示。 | 由零或多个 16位Unicode字符组成的字符序列             |\n|                |                                                              |                                            | 八进制字面值的第一位必须是零（0），然后是八进制数字序列（0～7）。如果字面值中的 数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析。（八进制字面量在严格模式下是无效的，会导致支持的 JavaScript引擎抛出错误。）* |                                                      |\n\n\n\n| Object                                | 对象可以通过执行 new 操作符后跟要创建 的对象类型的名称来创建。 |\n| ------------------------------------- | ------------------------------------------------------------ |\n| 一组数据和功能的集合                  | 即在 ECMAScript中， Object 类型是所有它的实例的基础。        |\n| 复杂数据类型                          | “Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。” |\n| 构造函数（constructor） 就是 Object() |                                                              |\n\nObject 本质上是由一组无序的名值对组成的\n\ntypeof操作符：检测给定的数据类型[它是一个操作符而不是一个函数]\n\nPS：typeof 操作符会返回一些令人迷惑但技术上却正确的值。比如，调用 typeof null 会返回\"object\"，因为特殊值 null 被认为是一个空的对象引用\n\n### <font color=#22a1b5 size=4>转换：</font>\n\n<font color=#22a1b5>数值转换:</font>\n\n3个函数可以把非数值转换为数值：Number()、parseInt()和 parseFloat()。第一个函数， 即转型函数 Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。\n\n<font color=#22a1b5>转换为字符串：</font>\n\ntoString()方法\n\nPS：null 和 undefined 没有 toString()方法","tags":["js"],"categories":["Web前端"]},{"title":"关键字与保留字(了解)","url":"/38093/","content":"\n   特定用途的关键字，来表示控制语句的开始或结束，或用于执行特定的操作。但是不能用作标识符\n\n| break     | do       | instanceof | typeof |\n| --------- | -------- | ---------- | ------ |\n| case      | else     | new        | var    |\n| catch     | finally  | return     | void   |\n| continue  | for      | switch     | while  |\n| debugger* | function | this       | with   |\n| default   | if       | throw      |        |\n| delete    | in       | try        | 关键字 |\n\n<!--more-->\n\n保留字\n\n| abstract | enum       | int       | short        |\n| -------- | ---------- | --------- | ------------ |\n| boolean  | export     | interface | static       |\n| byte     | extends    | long      | super        |\n| char     | final      | native    | synchronized |\n| class    | float      | package   | throws       |\n| const    | goto       | private   | transient    |\n| debugger | implements | protected | volatile     |\n| double   | import     | public    | 保留字       |\n\n....","tags":["js"],"categories":["Web前端"]},{"title":"语句","url":"/8278/","content":"\n  语句以一个分号结尾`;`如果省略分号，则由解析器确定语句的结尾。虽然语句结尾分号不是必须的，但最好不要省略它，∵加上分号可以避免很多错误（输入不完整）压缩js的时候也不会导致压缩错误，也可以增进代码的性能。多条语句组合到一个代码块中，则需要左花括号（ `{` ）开头,右花括号（`{`）结尾\n\n","tags":["js"],"categories":["Web前端"]},{"title":"javascript概念基础","url":"/21164/","content":"\n 区分大小写，不能用关键字命名，标识符则指变量、函数、属性的名字，或者函数的参数：\n\n 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；其它字符可以是字母、下划线、美元符号或数字。命名的时候首字母不能是数字\n\nPS：不能把关键字、保留字、true、false 和null 用作标识符\n\n<!--more-->\n\n注释可以使用单行注释:两个斜杠开头\n\n```js\n// 单行注释\n```\n\n也可使用块级注释:一个斜杠和一个星号（/ `*`）开头，以一个星号和一个斜杠（`*`/）结尾\n\n```js\n/* * 这是一个多行\n* （块级）注释\n*/\n```\n\n扩展：\n\n严格模式是为 JavaScript 定义了一种不同的 解析与执行模型。\n\n在严格模式下，ECMAScript 3中的一些不确定的行为将得到处理，而且对某些不安全 的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码： \"use strict\";","tags":["js"],"categories":["Web前端"]},{"title":"文档模式(了解)","url":"/39869/","content":"\nHTML文档模式是通过使用文档类型DOCTYPE来指定的。DOCTYPE中会引用对应的dtd文件，这个文件告诉浏览器按什么标准、规则来解析文件。html5标准不依赖于SGML规则，所以不需要引用dtd文件。\n\n文档模式是：混杂模式（quirks mode） 和  标准模式（standards mode）以及IE提出的  准标准模 式（almost standards mode）。而准标准模式，则可以通过使用过渡型（transitional）或框架集型（frameset）文档类型来触发，","tags":["js"],"categories":["Web前端"]},{"title":"html中使用JavaScript","url":"/22888/","content":"\njavascript在html中主要使用方法是`<script>`元素,有6个属性：\n\n| async                            | charset        | defer                                        | language | src                | type             |\n| -------------------------------- | -------------- | -------------------------------------------- | -------- | ------------------ | ---------------- |\n| 可选                             | 可选(少)       | 可选                                         | 废用     | 可选               | 可选             |\n| 立即下载脚本，不妨碍页面其它操作 | 指定代码字符集 | 延迟文档完全被解析和显示之后执行外部脚本有效 |          | 执行代码的外部文件 | 脚本语言内容类型 |\n\n两种使用方式：直接页面嵌入js代码 和引入包含外部js文件\n\n<!--more-->\n\n而包含元素内部的js则是<font color=#258f9d>从上往下</font>依次解析，但在使用`<script>`嵌入js代码时，不要在任何地方出现`<script>`字符串，会报错，使用转义字符“/”可以解决。\n\n引入外部js文件使用src引入，但不能在其`<script>`下写格外的js代码，还有一点就是引入的先后顺序，则点尤为重要。引入的位置则是在body中，这样在解析js代码之前，页面的内容将完全展现在浏览器中，从而感到打开页面速度变快了。\n\n如果想要延迟脚本，需要加defer属性也就是`defer=\"defer\"`，但defer只适用于外部js文件. 还有一个和他相同行为的属性`async`异步脚本但不同的是async的脚本并不保证按照指定它们的先后顺序执行，而是不让页面等待两个脚本下载和执行，来达到异步加载页面其它内容。\n\n一般来说推荐使用外部引入文件：\n\n可维护性   可缓存  ","tags":["js"],"categories":["Web前端"]},{"title":"侧记","url":"/27617/","content":"\n不要过分强调选择什么语言。选择一种语言，这将有助于你学习编程，并完成你的任务。😊 不要担心什么很酷或最新的东西适合你。不管怎样，你以后还是会学习新的语言。因此，只要你有基本的编程概念，并放下技术，你就能更容易地学习一门新语言。最重要的部分是玩得开心！享受你正在做的事情，或者为什么这样做？\n","categories":["生活与话"]},{"title":"话十一","url":"/29833/","content":"\n**过高地估计了你和别人的关系，希望越大，失望也会越大。一旦期待落空，那种强烈的落差感就会让人寒心。**","tags":["话"],"categories":["生活与话"]},{"title":"小狼毫输入法","url":"/18704/","content":"\n[RIME](https://rime.im/) 是一个跨平台、开源、免费、且特别简洁流畅的输入法框架 (输入法引擎)","tags":["软件"],"categories":["应用与插件"]},{"title":"话十","url":"/23384/","content":"\n  想要能获得什么 就必须付出相应的代价","tags":["话"],"categories":["生活与话"]},{"title":"扩展运算符(...)","url":"/39277/","content":"\n扩展运算符(spread)：是三个点（...）。主要用于函数调用/数组构造是，将数组表达式或者string在语法层面展开，但值得注意的是如果扩展运算符后面是一个空数组，则不产生任何效果，而且只有函数调用时，扩展运算符才可以放在圆括号中，否则会报Uncaught SyntaxError: Unexpected number\n\n语法：\n\n函数调用\n\n```js\nmyFunction(...iterableObj);\n```\n\n数组结构或字符串<!--more-->\n\n```js\n[...iterableObj, '4', ...'hello', 6];\n```\n\n进行克隆或者属性拷贝（原数组不受影响）\n\n```js\nvar arr = [1, 2, 3];\nvar arr2 = [...arr]; // like arr.slice()\narr2.push(4); \n// arr2 此时变成 [1, 2, 3, 4]\n// arr 不受影响let objClone = { ...obj };\n```\n\n放置表达式?\n\n```js\nconst arr = [\n  ...(x > 0 ? ['a'] : []),\n  'b',\n];\n```\n\n扩展：\n\n扩展运算符等价与apply的方式\n\n```js\nfunction myFunction(x, y, z) { }\nvar args = [0, 1, 2];\nmyFunction.apply(null, args);\n```\n\nPS：使用new关键字调用构造函数时，不能直接使用数组+apply的方式（`apply` 执行的是调用 `[[Call]]` , 而不是构造 `[[Construct]]`）","tags":["js"],"categories":["Web前端"]},{"title":"Atom插件合集","url":"/46189/","content":"\n 代码美化：\n\nfile-icons 显示文件类型对应的图标\n\natom-beautify 支持大多数语言的代码格式化\n\npigments 颜色提示\n\nminimap 代码预览图\n\n提升效率：\n\nautocomplete-paths 补全路径\n\n<!--more-->\n\natom-ternjs 补全 JS\n\nemmet 超有名的前端工具\n\ndocblockr   代码注释\n\nvim-mode  在 Atom 上使用 Vim\n\nplatformio-ide-terminal 集成终端\n\nmarkdown-writer  markdown工具\n\nautoclose-html  自动闭合html标签\n\n代码相关：react\n\nlanguage-babel  atom内开发react的核心插件\n\nlanguage-javascript-jsx   JavaScript, ES6, ES7, react，JSX, Flow支持\n\natom-react-autocomplete  组件名及状态的自动补全 \n\nautocomplete-js-import   模块导入智能提示 \n\nreact-es6-snippets   es6写法的react snippet   &&    react-snippets\n\n代码相关：vue\n\nlanguage-vue  atom内开发vue的核心插件\n\nvue2-autocomplete  vue中自动补全插件\n\nvuejs2-snippets   vue碎片提示","tags":["Atom"],"categories":["应用与插件"]},{"title":"彻底删除软件依赖包","url":"/26071/","content":"\napt-get remove --purge xxx # 移除应用及配置\napt-get autoremove # 移除没用的包\n\n 1.删除已安装包（不保留配置文件）\n\n```csharp\napt-get purge\n```\n\n2. 删除为满足依赖而安装且不需要的软件包（保留配置文件）\n\n```csharp\napt-get autoremove \n```\n\n3.删除已安装的软件包（保留配置文件），不会删除依赖软件包，且保留配置文件。\n\n```csharp\napt-get remove\n```","tags":["Linux命令"],"categories":["语言与Linux"]},{"title":"rm删除命令","url":"/60824/","content":"\nrm删除文件:  <font color=#2874A6>rm [选项]  文件夹名</font>\n\n选项：\n\n```text\n-d：直接把欲删除的目录的硬连接数据删除成0，删除该目录；\n-f：强制删除文件或目录；\n-i：删除已有文件或目录之前先询问用户；\n-r或-R：递归处理，将指定目录下的所有文件与子目录一并处理；\n--preserve-root：不对根目录进行递归操作；\n-v：显示指令的详细执行过程。\n```\n\n注：指定被删除的文件列表，如果参数中含有目录，则必须加上`-r`或者`-R`选项。","tags":["Linux命令"],"categories":["语言与Linux"]},{"title":"Width(了解)","url":"/7993/","content":"\n   width的默认值是auto。但至少包含栏4种不同的宽度表现：\n\n1）充分利用可用空间。也叫作fill-available(了解)\n\n2）收缩与包裹。也就是浮动、绝对定位、 inline-block元素或者table元素。\n\n3）收缩到最小。 min-content\n\n4）超出容器限制。max-content\n\nPs：除非有明确的width设置，否则不会超过父容器宽度。Eg：white-space:nowrap","tags":["CSS"],"categories":["Web前端"]},{"title":"块级元素","url":"/61048/","content":"\n“块级元素”和“display 为 block 的元素”不是一个概念。\n\n由于“块级元素”具有换行特性，因此理论上它都可以配合 clear 属性来<font color=#3db2c6>清除浮动 </font>带来的影响。\n\n使用 block或使用 table，但不会使用list-item && Ps:设置display：list-item,会出现项目符号，他就会生成了一个附加盒子，学名“标记盒子”（marker box）用于存放原点、数字项目符号.\n\n.在此之后又增添了display：inline-block ------”内在盒子“也叫作”容器盒子“。<!--more-->\n\n<font color=#1c67af size=4>display: block和display: inline-block与display: inline-table区别：</font>\n\n值为block的元素盒子实际由外在的”块级盒子“和内在的”块级容器盒子“组成，而inline-block的元素则是由外在的”内联盒子“和内在的”块级容器盒子“组成，值为inline的元素则内外均是“内联盒子”.display: inline-table的话则是外面是“内联盒子”，里面是“table 盒子”\n\ndisplay:inline-block元素既能和图文一行显示，又能直接设置宽与高，外面的盒子是inline，而里面盒子是block\n\n~~Ps：display：block 可以理解为block-block，虽然没什么人说就是~~\n\n而宽或高作用在“容器盒子上”","tags":["css"],"categories":["Web前端"]},{"title":"CSS术语","url":"/26840/","content":"\n<font color=#5eb3e0 size=5>术语：</font>\n\n<font color=#5eb3e0 size=4>属性：</font>\n\n<font color=#5eb3e0 size=4>值：</font>整数值，数值，百分比 ， 长度值 ，颜色值\n\n<font color=#5eb3e0 size=4>关键字：</font>~~很关键的字~~\n\n<font color=#5eb3e0 size=4>变量：</font>也可以说自定义属性或级联变量\n\n<!--more-->\n\n   自定义属性：\n\n```css\n element {\n    --main-bg-color: brown;\n}\n```\n局部变量：\n\n```css\nelement {\n    background-color： var(--main-bg-color)\n}\n```\n\n<font size=2 color=#d30f2d>注：具体内容请查看<a href=https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_custom_properties>MDN web docs</a></font>\n\n<font color=#5eb3e0 size=4>长度单位：</font>px em rem等 %是不是长度单位，是一个完整的值\n\n​      <font color=#d64395 size=3>○相对长度单位</font>\n\n​          •对字体长度单位，如 em 和 ex,rem\n\n​          •相对视区长度单位，如 vh、vw、vmin 和 vmax\n\n​      <font color=#d64395 size=3>  ○绝对长度单位</font>\n\n​           •px   \n\n<font color=#5eb3e0 size=4>功能符：</font>值以函数的形式指定\n\n​       ○颜色（rgba 和 hsla）、 背景图片地址（url）、元素属性值、计算（calc）和过渡效果等\n\n<font color=#5eb3e0 size=4>属性值：</font>属性冒号后面的所有内容统一称为属性值。\n\n<font color=#5eb3e0 size=4>声明：</font>属性名加上属性值就是声明\n\n<font color=#5eb3e0 size=4>声明块：</font>花括号（{}）包裹的一系列声明\n\n<font color=#5eb3e0 size=4>规则或规则集：</font>选择器+声明块\n\n<font color=#5eb3e0 size=4>选择器：</font>\n\n​            <font color=#d64395 size=3>  ○类选择器：</font>指以“.”这个点号开头的选择器\n\n​            <font color=#d64395 size=3>  ○ID 选择器：</font>“#”打头，权重相当高。\n\n​            <font color=#d64395 size=3>  ○属性选择器：</font>指含有[]的选择器\n\n​            <font color=#d64395 size=3>  ○ 伪类选择器：</font>一般指前面有个英文冒号（:）的选择器\n\n​            <font color=#d64395 size=3>  ○伪元素选择器： </font>就是有连续两个冒号的选择器\n\n<font color=#5eb3e0 size=4>关系选择器：</font>\n\n​       <font color=#d64395 size=3>  ○后代选择器：</font>选择所有合乎规则的后代元素。<font color=#5eb3e0 size=4>空格连接</font>。\n\n​      <font color=#d64395 size=3>  ○相邻后代选择器： </font>又称“子 选择器”。仅仅选择合乎规则的儿子元素，孙子、重孙元素忽略，<font color=#5eb3e0 size=3>>连接</font>。适用于 IE7 以上版本。\n\n​      <font color=#d64395 size=3>  ○ 兄弟选择器： </font>选择当前元素后面的所有合乎规则的兄弟元素。<font color=#5eb3e0 size=4>~连接</font>。适用于 IE7 以上 版本。\n​        <font color=#d64395 size=3>  ○相邻兄弟选择器： </font>仅仅选择当前元素相邻的那个合乎规则的兄弟元素。<font color=#5eb3e0 size=4>+连接</font>。适用于\nIE7 以上版本。","tags":["CSS"],"categories":["Web前端"]},{"title":"CSS简述（了解）","url":"/10525/","content":"\nCSS 世界的诞生就是为图文信息展示服务的，CSS世界构建的基石是HTML，而HTML最具代表的两个基石<\\div>和<\\span>正好是CSS 世界中<u>块级元素</u>和<u>内联级元素</u>的代表.\n\n对 CSS2.1 的全面支持是从微软公司的 IE8 开始的\n\n<!--more-->\n\nCSS3:\n\n（1）布局更为丰富。\n\n • 移动端的崛起，催生了 CSS3 媒介查询以及许多响应式布局特性的出现，如图片元素 的 srcset 属性、CSS 的 object-fit 属性。\n• 弹性盒子布局（flexible box layout）\n\n • 格栅布局（grid layout）\n（2）视觉表现长足进步。\n\n • 圆角、阴影和渐变让元素更有质感。\n\n • transform 变换让元素有更多可能。\n\n • filter 滤镜和混合模式让 Web 轻松变成在线的 Photoshop；\n• animation 让动画变得非常简单。\n\n","tags":["CSS"],"categories":["Web前端"]},{"title":"如何在Linux安装zsh","url":"/26714/","content":"\n**Z shell**（**Zsh**）是一款可用作[交互式](https://zh.wikipedia.org/w/index.php?title=交互式&action=edit&redlink=1)登录的[shell](https://zh.wikipedia.org/wiki/殼層)及[脚本编写](https://zh.wikipedia.org/wiki/Shell脚本)的[命令解释器](https://zh.wikipedia.org/wiki/命令行界面)\n\n下载`zsh`  <font color=#316666 size=4>sudo apt-get install  zsh</font>\n\n下载<a href=https://ohmyz.sh/ style=\"text-decoration:none\">Oh My ZSH!</a>   \n\n------\n\n根据官网的两条命令会出现以下错误\n\nsh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n\n> curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused\n\nsh -c \"$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)\"\n\n> 正在解析主机 raw.githubusercontent.com (raw.githubusercontent.com)… 0.0.0.0\n> 正在连接 raw.githubusercontent.com (raw.githubusercontent.com)|0.0.0.0|:443… 失败：Connection refused。\n\n------\n\n解决办法就是：<!--more-->\n\n科学上网在浏览器输入https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh 像是保存js或者css一样。<font color=#f42b56 size=4>Ctrl + S</font>保存到文件夹然后在终端运行 `./install.sh`\n\n切换shell命令：\n\n<font color=#316666 size=4>chsh -s /bin/zsh</font>\n\n然后重启\n\n配置主题：<a href=https://github.com/ohmyzsh/ohmyzsh/wiki/Themes style=\"text-decoration:none\">主题地址</a>\n\n~vim .zshrc     ps:修改前需要先修改文件权限\n\n更新oh my zsh： `omz update`\n\n<font color=#005300 size=5>扩展:</font>\n\n查看当前使用的shell\n\n> echo $SHELL\n\n或\n\n> echo ＄０","tags":["Linux"],"categories":["应用与插件"]},{"title":"javascript基础二","url":"/10733/","content":"\njavascript由以下三个不同的部分组成：核心（ecmascript）文档对象模型（dom）浏览器对象模型（bom）\n\n规定：语法 类型 语句 关键字 保留字  操作符 对象","tags":["js"],"categories":["Web前端"]},{"title":"词汇","url":"/39229/","content":"\n能够以所有人都能理解、并且具有说服力的方式，来清晰阐明得出的结论的原因。或许可以说，让别人去接纳你所断定的结论，正好是逻辑思维的职责所在。在逻辑思维中，不能一下子从最初的论点直接跳到结论，而是应当以事实前提作为基础通过一系列判断的积累，形成起思考的调理。而其中的每一个判断，也都要清晰明确。\n\n  为此，在做出每个判决时，除了严谨的思维，果断也很重要。即便面对暧昧的灰色区域，你也可以基本一些前提，做出明确的判断（“黑色”），这才是现实中逻辑思维的使用方法。\n\n~~当所有人都说错的时候，对的也变成错的。当所有人都说对的时候，错的也是对的。~~","categories":["笔记"]},{"title":"React动态路由与404","url":"/3730/","content":"\n​    \n\n<font color=#7D9EC0 size=4>动态路由在Router组件的path属性:</font> {/url/:parameter}\n\n```jsx\n<Router path='/xxx/:id' component={xxx} />\n```\n\nSwitch组件配置404页面：\n\n","tags":["react"],"categories":["Web前端"]},{"title":"React路由的基本组件","url":"/35790/","content":"\nReact路由基础组件:\n\n1.路由组件(router components)\n\n  `<BrowserRouter>` （推荐）和`<HashRouter>`两种路由组件\n\nEg:\n\n```react\nimport { BrowserRouter } from \"react-router-dom\";\nReactDOM.render(\n     <BrowserRouter>\n             <App />\n    </BrowserRouter>,\n\tdocument.getElementById('root')\n)\n```\n\n2.路由匹配组件（router matching components)\n\n`<Route>`和`<Switch>`路由匹配组件。<!--more-->\n\nRoute:通过`<Route>`组件的path属性匹配当前地址，当匹配成功时就渲染component属性指定的组件。\n\n```jsx\nimport { Route, Switch } from \"react-router-dom\";\n....\n// 当前路径是'/about'\n<Route path='/about' component={About}/> // renders <About/>\n<Route path='/contact' component={Contact}/> // renders null\n<Route component={Always}/> // renders <Always/>\n```\n\nSwitch:遍历所有子Route元素，并仅渲染与当前地址匹配的第一个元素。实现404组件\n\n```jsx\n<Switch>\n       ....\n  <Route component={NoMatch}/>\n</Switch>\n```\n\n3.导航组件(nacigation components)\n\n`Link`和`NavLink`主要导航组件。\n\nLink: 创建连接，渲染后为html的a标签\n\n```jsx\n<Link to='/'>Home</Link>    =>  <a to='/'>Home</a>\n```\n\nNavLink:特殊类型的Link，当to属性与当前地址匹配时，自动添加active状态。\n\n```jsx\n<NavLink to=\"/react\" activeClassName=\"active\">React</NavLink>\n```\n\n","tags":["react"],"categories":["Web前端"]},{"title":"React路由的基本使用","url":"/42023/","content":"\n   前段路由是一套映射规则，在React中，是URL路径与组件的对应关系。就是配置路径和组件（一一对应）\n\n1.React路由安装：\n\n```bash\n$ npm i react-router-dom\n```\n\n2.导入路由的三个核心组件：Router / Route / Link\n\n```jsx\nimport { BrowserRouter as Router , Route, LInk } from 'react-router-dom'\n```\n\n3.使用Router组件包裹整个应用（重要！！！）<!--more-->\n\n```jsx\n<Router>\n  <nav className=\"menu\">\n\t\t// ... \t\t\t\n  </nav>\n  <div className=\"app\">\n\t\t// ...路由配置\n  </div>\n</Router>\n```\n\n4.使用Link组件作为导航菜单（路由入口）\n\n```jsx\n<Link> ... </Link>\n```\n\n5.使用Router组件配置路由规则和要展示的组件（路由出口）\n\n```jsx\nclass Home extends Component{\n    render () {\n         return (\n           .....\n         )\n    }\n}\n.....b\n<Router>\n  <nav className=\"menu\">\n    <Link to=\"/home\">home</Link>\n  </nav>\n  <div className=\"app\">\n    <Route path=\"/home\" component={Home} />\n  </div>\n</Router>\n```\n\n注：Router组件：包裹整个应用，一个React应用只需使用一次\n\n​        Router Ｌink组件：须在Ｒouter组件内部","tags":["react"],"categories":["Web前端"]},{"title":"React脚手架","url":"/19812/","content":"\n<font color=#2F4F4F size=4>使用脚手架初始化项目：</font>\n\n1.初始化项目，命令npx create-react-app  xxx\n\n2.启动项目，在项目根目录执行命令：npm start\n\n```react\npublic/                                                                                                                       // 公共资源\n         index.html                                                                                                     // 首页（必须）\n         manifest.json\n\n\nsrc /\n     index.js                                                                                                                 // 项目入口文件（必须）\n    App.js                                                                                                                    // 项目的根组件\n    App.test.js                                                                                                          //  App组件的测试文件\n    serviceworker.js                                                                                            //    实现pwa（可选）\n```\n\n扩展：<!--more-->\n\nnpx是npm V5.2.0引入的一条命令，提升包内提供的命令行工具使用体验\n\n<font color=#2F4F4F size=4>在脚手架使用react：</font> \n\n  1.导入react 和 react-dom 两个包\n\n  2.调用React.createElement()方法创建react元素\n\n  3.调用ReactDOM.render()方法渲染react元素到页面\n\n","tags":["react"],"categories":["Web前端"]},{"title":"JQuery效果","url":"/52303/","content":"\n<font color=#86d7ed size=4>常见的动画效果：</font>动画或效果一旦触发就会执行，如果触发多次，就造成多个动画或效果排队执行。但可以停止动画排队：stop() \n\n| 显示隐藏             | 滑入滑出             | 淡入淡出             | 自定义动画                  |\n| -------------------- | -------------------- | -------------------- | --------------------------- |\n| show()               | slideDown()          | fadein()             | animate()                   |\n| hide()               | slideUp()            | fadeOut()            |                             |\n| toggle()             | slideToggle()        | fadeToggle()         |                             |\n|                      |                      | fadeTo()×××          |                             |\n| [speed,[easing],[fn] | [speed,[easing],[fn] | [speed,[easing],[fn] | [params,speed,[easing],[fn] |\n\n <font color=#86d7ed size=4>显示语法：</font>show([speed,[easing],[fn] )    <!--more-->\n\n参数：都可以省略，无动画直接显示。\n\nspeed：三种预订速度之一的字符串（“slow”， “noemal”，“fast”）或者表示动画时长的毫秒数值（1000）\n\neasing：(Optional)用来指定切换效果，默认“swing”，可选“linear”。\n\nfn：回调函数，在动画完成时执行的函数，且每个元素执行一次。\n\n <font color=#86d7ed size=4>隐藏语法：</font>hide( [speed,[easing],[fn] )\n\n同上略....\n\n<font color=#86d7ed size=4>切换语法：</font>toggle( [speed,[easing],[fn])\n\n同上略....注：没特殊情况，则不带参数，直接显示隐藏即可\n\n×××：参数：opacity 透明度必须写，取值0～1之间。speed：必须写\n\n<font color=#dd5325 size=5>自定义动画：</font>模拟上面所有动画！！！\n\n语法：animate(params, [speed],[easing],[fn])\n\nparams：更改样式属性则以对象形式传递，必须写。属性名可以不带引号，复合属性则需采用驼峰命名法\n\n<font color=#0c1e76 size=4>停止动画排队：</font>stop()方法用于停止动画或效果。须写到动画或效果前面，相当于停止结束上一次动画。\n\n也就是说每次使用动画前，先调用stop()在调用动画。\n\n<font color=#203149 size=4>事件的切换：</font>hover([over], out)类似css中伪类 :hover\n\nover：鼠标移到元素上触发的函数（相当于mouseenter）\n\nout：鼠标移出元素上触发的函数（相当于mouseleave）","tags":["JQ"],"categories":["Web前端"]},{"title":"React表单处理","url":"/44815/","content":"\n受控组件(双向绑定（v-model）)：\n\n  ","tags":["react"],"categories":["Web前端"]},{"title":"类组件中state和setState()","url":"/4860/","content":"\n<font color=#408d96 size=4>state的基本使用：</font>状态（state）即是数据,是组件内部的私有数据，只能在组件内部使用，且state的值是对象，表示一个组件中可以有多个数据\n\n<font color=#305991 size=4>初始语法：</font>\n\n```react\nclass KEL extends React.Component {\n    constructor() {\n        super () {\n            // 初始化state\n            this.state = {\n                count: 0\n            }\n        }\n        render () {\n            return {\n                <div>有状态组件</div>\n            }\n        }\n    }\n}\n```\n\n<font color=#305991 size=4>简化语法：</font><!--more-->\n\n```react\nclass KEL extends React.Component {\n            // 初始化state\n          state = {\n                count: 0\n            }\n          render () {\n            return {\n                <div>有状态组件, {this.state.count}</div>\n            }\n      }\n  }\n```\n\n<font color=#305991 size=4>  获取状态：</font>this.state\n\n```react\n{this.state.count}\n```\n\n<font color=#39abe8 size=4>setState()修改状态：</font>注：不要直接修改state中的值，【this.state.num=2】<-错误。【数据驱动视图】\n\n语法：this.setState({key:val, key2:val2})\n\n作用：修改state和更新UI\n\n<font color=#305991 size=4>Eg：</font>\n\n```react\n// 正确\n  this.setState({\n      count: this.state.count + 1\n  })\n// 错误\nthis.state.count += 1\n```\n\n","tags":["react"],"categories":["Web前端"]},{"title":"类组件中this指向(注)","url":"/20412/","content":"\n只有类组件下有这个问题（函数组件没有this）\n\n<font color=#406497 size=4>利用bind修改this指向组件：</font>\n\n```react\nclass HEL extends React.Comonent {\n    num = 0;\n    addNum() {\n        this.num += 1;\n        alert(this.num)\n    }\n    render () {\n        return (\n         <div>\n           <h1 onClick={this.addNum.bing(this)}>数字加一</h1>   \n         </div>\n        )\n    }\n}\n```\n\n<font color=#406497 size=4>利用箭头函数方法（推荐）：</font>该语法是实验性语法，由于babel的存在可以直接使用 <!--more-->\n\n```react\nclass HEL extends React.Comonent {\n    num = 0;\n    addNum = () => {\n        this.num += 1;\n        alert(this.num)\n    }\n    render () {\n        return (\n         <div>\n           <h1 onClick={this.addNum.bing(this)}>数字加一</h1>   \n         </div>\n        )\n    }\n}\n```\n\n","tags":["react"],"categories":["Web前端"]},{"title":"React事件处理","url":"/20995/","content":"\n​    <font color=#4b8ce5 size=4>事件绑定：</font>React事件绑定语法与DOM事件语法相似，而语法则是<font color=#2fd36a size=3>on+事件名称={事件处理程序fn}</font>需要注意的是React事件则采用<font color=#368499 size=3>小驼峰命名法：除第一个单词之外，其他单词首字母大写。</font>\n\n <font color=#287a7a size=4> 类 组件绑定：</font>\n\n```react\nclass KL extends React.Component {\n    headrClick () {\n        ...\n    }\n     render () {\n         return (\n          <button  onClick={this.headrClick}></button>\n         )\n     }\n }\n```\n\n<font color=#287a7a size=4> 函数组件绑定: </font>     <!--more-->\n\n```react\nfunction KL() {\n    function headeClick() {\n        ...\n    }\n        return (\n       <button  onClick={headeClick}></button>\n       )\n}\n```\n\n<font color=#287a7a size=4>事件对象: </font>通过处理程序的默认参数获取到事件对象，但是在React中事件对象叫做：合成事件（对象）<-----兼容所有浏览器------->\n\n```react\nfunction hadeClick (e) {\n    e.preventDefault()\n}\n   <a href=\"...\" onClick={hadeClick}></a> // 阻止跳转\n```\n\n\n\n","tags":["react"],"categories":["Web前端"]},{"title":"es5类的创建与继承","url":"/11961/","content":"\n父类：\n\n<!--more-->\n\n```js\nfunction Parent(name) {\n   // 实例的属性\n    this.name = name\n}\n\n// 定义静态属性 =》不在实例\nParent.a = 1;\nParent.fn = function () {\n    console.log(this.abc, Parent.a)\n}\n```\n\n原先方法：\n\n```js\n// 原型方法\nParent.prototype.getName = function () {\n  console.log(this.name)\n}\n\n// 子类：继承 \nfunction Child(name) {\n  // 继承实例的属性\n  Parent.call(this, name)\n}\n\n// Child.prototype = new Parent();\nChild.prototype = Object.create(Parent.prototype, {\n  constructor: {\n    value: Child\n  }\n})\n\n// 测试\nlet Chi = new Child('普京');\nconsole.log(Chi)\n\n```\n\n","tags":["面试题"],"categories":["算法与面试题"]},{"title":"JQuery样式操作","url":"/42493/","content":"\n<font color=#48ded5 szie=4>Query中常用的样式操作：</font>Jcss()和设置类样式方法\n\n <font color=#48ded5 size=4>操作css方法：</font>JQuery使用css方法修改简单元素样式，操作类，修改多个样式\n\n ```js\n// 1.参数只写属性名，则返回属性值\n var strColor = $(this).css('color');\n// 2.参数是属性名，属性值，逗号分隔（英文），设置一组样式，属性须加引号，如果是数字可不用加单位和引号\n $(this).css(\"color\", \"red\");\n// 3.参数可以是对象形式(css()用于样式少时)\n$(this).css({\"color\":\"white\", \"font-size\":\"20px\"});\n ```\n\n<font color=#48ded5 size=4>设置类样式：</font>等同于classList，可以操作样式，注：操作类不加点且不会覆盖原先的类名<!--more-->\n\n```js\n1.添加类\n$(\"div\").addClass(\"current\");\n2.删除类\n$(\"div\").removeClass(\"current\");\n3.切换类\n$(\"div\").toggleClass(\"current\");\n\n```","tags":["JQ"],"categories":["Web前端"]},{"title":"React组件","url":"/62118/","content":"\n <font color=#65c1e0 size=5>  React组件创建：</font>特点：复用 独立 可组合\n\n<font color=#eb60aa size=3>    函数创建：</font>使用JS函数或<u>箭头函数</u>创建的组件\n\n```react\nimport React from 'react';\nconst Dnz = () => {\n    \n     return (\n       <div>\n             <h2>函数组件</h2>\n              <p onClick={fn}>点击</p>\n       </div>\n     )\n}\nReactDOM.render(<Dnz />, root)\n```\n\n【注意事项：\n\n​           1.类与函数名称都需以大写字母开头，使用<font color=#4aeadb>大驼峰命名法</font>。\n\n​           2.函数组件必须有返回值，表示该组件的结构，而类组件则需提供render()方法。<!--more-->\n\n​          3.函数的组件标签闭合，而类的render()方法须有返回值表示该组件的结构 \n\n】\n\n   <font color=#65c1e0 size=4>  class创建组件：</font>使用ES6的class关键字创建的组件\n\n  类组件应继承React.Component父类，从而可以使用父类中提供的方法和属性。有关继承请访问<a href=#>es5类的创建与继承</a>与<a href=#>es6类的创建与继承</a>\n\n```react\nimport React from 'react';\nclass Hello extends React Component {\n    render() {\n        return <div>Hello Class Component!</div>\n    }\n}\nReactDOM.render(<Hello />, root)\n```\n\n<font color=#55a7ce size=4>组件抽离：</font>将每个组件放到单独的JS文件中。独立体放单独JS文件中\n\n 步骤:\n\n​      1.创建JS文件\n\n​      2.在JS中导入React核心包\n\n​      3.创建组件（函数或类）\n\n​       4.在JS中导出组件\n\n​       5.在index.js中导入组件\n\n​      6.渲染组件\n\n------\n\n<font color=#3f98b8 size=4>扩展：</font>\n\n状态组件与无状态组件\n\n<font color=#db638f>函数组件：</font>无状态组件\n\n<font color=#db638f>类组件class：</font>有状态组件\n\n区别：\n\n- 类组件有自己的状态，负责更新 UI，让页面“动” 起来 （响应式）\n- 函数组件没有自己的状态，只负责数据展示（静）","tags":["react"],"categories":["Web前端"]},{"title":"数组","url":"/32766/","content":"\njavascript的Array对象是用于构造数组的全局对象，数组是类似于列表的高阶对象。\n\n创建数组：属性——Array.length于Array.prototype[]\n\n```js\nvar fruits = ['App', 'ios']\n// 打印数组\nconsole.log(fruits.length)\n```\n\n遍历数组：\n\n```js\nfruits.forEach( (item, index, array) => {\n         console.log(item, index);           \n     })\n```\n\n","tags":["js"],"categories":["Web前端"]},{"title":"JSX基本使用","url":"/39460/","content":"\nBabel会把JSX转译成一个名为React.createElement()函数调用\n\n<font color=#1688a0 size=4>原生创建recat元素：</font>\n\n```react\nconst span = React.createElement('span', null, 'span')\n```\n\n<font color=#1688a0 size=4>用JSX创建react元素：</font>\n\n```react\nconst ul = <div><ul><li><span>hello worde!!!</span></li></ul></div>\n```\n\n<font color=#1688a0 size=4>JSX中使用JS表达式：</font>\n\n 语法：{JavaScript表达式}\n\n <font color=#de5c6a size=3> 注：语法中是单大括号，不是双大括号</font>       <!--more-->\n\n```react\nconst name = 'kl'\n const div = (\n   <div>XXX:{name}</div>\n )\n```\n\n<font color=#1688a0 size=4>使用jsx注意事项：</font>自身也是js表达式\n\n​       1.添加类名需小驼峰命名法：第一个单词首字母小写，从第二个单词及以后的首字母是大写开头\n\n​       2.声明的jsx元素需圆括号下只能有一个根元素\n\n       3.不能在{}中出现语句和对象（if/for,{a:555}等）\n\n<font color=#1688a0 size=4>数据类型支持：</font>\n\n单大括号：值、变量、函数调用、三元运算符、数组（基本类型，jsx）","tags":["react"],"categories":["Web前端"]},{"title":"React初体验","url":"/7770/","content":"\n  引入react react-dom\n\n  安装包：npm Install react  react-dom\n\n   react：创建元素 react-dom：渲染元素\n\n<font color=#0baba5 size=4>创建元素：</font>\n\n```js\n  const h1 = React.createElement('h1', {classNmae: 'k', id: 'hh'}, 'hello react')\n```\n\n<font color=#0baba5 size=4>渲染元素：</font>\n\n```js\n React.render(div, document.getElementById('app'))\n```\n\n\n\n","tags":["react"],"categories":["Web前端"]},{"title":"JQuery选择器","url":"/49804/","content":"\nJQuery选择器：原生 JS 获取元素方式很多，很杂，而且兼容性情况不一致，因此 jQuery 做了封装，使获取元素统一标准。\n\n <font color=#08a9b7 size=4> 基础选择器：</font>\n\n   ```js\n$('选择器') // 直接写css选择器，需加引号\n   ```\n\n| 名称       | 用法            | 描述                     |\n| ---------- | --------------- | ------------------------ |\n| ID选择器   | $(\"#id\")        | 获取指定的ID的元素       |\n| 全选选择器 | $('*')          | 匹配所有元素             |\n| 类选择器   | $('.class')     | 获取同一类class的元素    |\n| 标签选择器 | $('div')        | 获取同一类标签的全有元素 |\n| 并集选择器 | $('div,p,li')   | 选取多个元素             |\n| 交集选择器 | $('li.current') | 交集元素                 |\n\n<font color=#08a9b7 size=4>层级选择器：</font>后代选择器和子代选择器<!--more-->\n\n| 名称       | 用法       | 描述                                                       |\n| ---------- | ---------- | ---------------------------------------------------------- |\n| 自带选择器 | $('ul>li') | 使用>号获取亲儿子层级的元素；注：并不会获取孙子层级的元素  |\n| 后代选择器 | $('ul li') | 使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等 |\n\n<font color=#08a9b7 size=4>筛选选择器：</font>选择满足条件进行筛选选择\n\n| 语法       | 用法          | 描述                                                      |\n| ---------- | ------------- | --------------------------------------------------------- |\n| :first     | $('li:first') | 获取第一个li元素                                          |\n| :last      | $('li:last')  | 获取最后一个li元素                                        |\n| :eq(index) | $('li:eq(2)') | 获取到的li元素中，选择索引号为2的元素，索引号index从0开始 |\n| :odd       | $('li:odd')   | 获取到li元素中，选择索引号为奇数的元素                    |\n| :even      | $('li:even')  | 获取到的li元素中，选择索引号为偶数的元素                  |\n\n<font color=#189cbd size=4>扩展：</font>\n\n| 语法               | 用法                           | 说明                             |\n| ------------------ | ------------------------------ | -------------------------------- |\n| parent()           | $('li').parent()               | 查找父级                         |\n| children(selector) | $('ul').children('li')         | 相当于$('ul>li'),最近一级        |\n| find(selector)     | $('ul').find(\"li\")             | 相当于$(\"ul li\"),后代选择器      |\n| siblings(selector) | $('.first').siblings(\"li\")     | 查找兄弟节点，不包括本身         |\n| nextAll([expr])    | $('.first').nextAll()          | 查找当前元素之后所有的同辈元素   |\n| prevtAll([expr])   | $('.last').prevtAll()          | 查找当前元素之前所有的同辈元素   |\n| hasClass(class)    | $('div').hasClass('protected') | 检查当前的元素是否有某个特定的类 |\n| eq(index)          | $('li').eq(2)                  | 相当于$('li:eq(2)'),index从0开始 |\n\n","tags":["JQ"],"categories":["Web前端"]},{"title":"心流","url":"/28029/","content":"\n<font size=4 color=#29c7ca>心流的成因和特征：</font>\n第一，注意力。(自律、集中注意力)\n第二，有一个愿意为之付出的目标。(目标是什么不要紧，只要那目标将他的注意力集中于此)\n第三，有即时的回馈。\n第四，因全神贯注于此，日常恼人的繁琐被忘却和屏蔽。\n第五，达到了忘我的状态。\n\n","tags":["心理学"],"categories":["爱好心理学"]},{"title":"安装依赖包","url":"/26927/","content":"\napt -f install","tags":["Linux命令"],"categories":["语言与Linux"]},{"title":"如何安装linux中安装typora","url":"/54370/","content":"\nTypora给您既是读者又是作家的无缝体验。它删除了预览窗口，模式切换器，降价源代码的语法符号以及所有其他不必要的干扰。相反，它提供了真正的实时预览功能，可帮助您专注于内容本身。\n\n如何在linux中安装typora：\n\n第一步：\n\n```\nwget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -\n```\n\n第二步：<!--more-->\n\n```\nsudo add-apt-repository 'deb https://typora.io/linux ./'\nsudo apt-get update\n```\n\n第三步：\n\n```\nsudo apt-get install typora\n```\n\n如果报错请查看<a href=https://kid1412.cc/blog/2020/03/12/%E6%97%A5%E5%B8%B8%E7%8A%AF%E9%94%99%E8%AF%AF/>12条</a>\n\n或者到<a href=https://www.typora.io/#linux>官网下载</a>","tags":["Linux"],"categories":["应用与插件"]},{"title":"remove卸载命令","url":"/54742/","content":"\nsudo apt-get remove  XXX","tags":["Linux命令"],"categories":["语言与Linux"]},{"title":"Linux下安装.ded文件","url":"/44404/","content":"\ncd到安装包目录   dpkg -i 安装包名字\n\n注：如果无法安装请尝试一下方法\n\ncd到安装包目录  rpm -ivh 安装包名字\n","tags":["Linux命令"],"categories":["语言与Linux"]},{"title":"话玖","url":"/26041/","content":"\n有时候 周围无意的一句话远比施暴的人更伤人","tags":["话"],"categories":["生活与话"]},{"title":"chmod777与555","url":"/14385/","content":"\nchmod修改文件与文件夹权限：<font color=#0dcc8d size=4>chmod 777  xxx </font>所有用户都有读、写、执行权限。<font color=#0dcc8d size=4>chmod 755 xxx</font> 所有用户都是读取、执行权限\n\n\n\n","tags":["Linux命令"],"categories":["语言与Linux"]},{"title":"JQuery基本使用","url":"/32426/","content":"\n<font color=#28b0de size=4> JQuery中常见的两种入口函数：</font>\n\n```js\n第一种：简单易用\n$(function () {\n    ... // 此处是页面DOM加载完成的入口\n})\n第二种：繁琐，（不推荐）\n$(document).ready(function() {\n    ... 此处是页面DOM加载完成的入口\n})\n```\n\n<font color=#28b0de size=4>JQuery中的顶级对象$:</font> \n\n$是JQuery的顶级对象，相当于原生JavaScript中的window。把元素利用*包装成JQuery对象。<!--more-->\n\n<font color=#28b0de size=4>JQuery对象和DOM对象：</font> \n\n<font color=#e5a490 size=3>  JQuery方法和原生js获取的元素是不一样的：</font>\n\n​               1.用原生的js获取来的对象就是DOM对象\n\n​               2.JQuery方法获取的元素就是JQuery对象\n\n  <font color=#e5a490 size=3>JQuery对象本质是：</font>利用$对DOM对象包装后产生的对象（伪数组形式存储）\n\n------\n\n注：只有JQuery对象才能使用JQuery方法，DOM对象册使用原生的JavaScript方法.常用的是把DOM对象转换为JQuery对象\n\n------\n\n<font color=#28b0de size=4>JQuery对象和DOM对象转换：</font> \n\n   原生的一些属性和方法JQuery没有封装，需将JQuery对象转换为DOM对象才能使用\n\n```js\n// 1.DOM对象转换成JQuery对象\n  var box = document.getElementById('box') // 获取\n  var JQueryObject = $(box) // 把DOM对象转换为JQuery对象\n// 2.JQuery对象转换为DOM对象\n  var domObject = $('div')[0] // 第一种\n  var domObject = $('div').get[0] // 第二种\n```\n\n","tags":["JQ"],"categories":["Web前端"]},{"title":"如何下载公司github的代码","url":"/27938/","content":"\n找个地方命令窗口输入<font color=#e50b6d sizr=4>git clone 仓库地址</font>等待....\n\n<font color=#06bcaf size=4>cd 仓库名</font>\n\n","tags":["面试题"],"categories":["算法与面试题"]},{"title":"返回上两级目录","url":"/4362/","content":"\ncd ../..返回上两级目录","tags":["Linux命令"],"categories":["语言与Linux"]},{"title":"话八","url":"/17630/","content":"\n不是所有的事情都能两全 任何事情 不管是好是坏 都要付出代价","tags":["话"],"categories":["生活与话"]},{"title":"话七","url":"/2719/","content":"\n这世上那来什么幸与不幸    那全都是看你怎么解读","tags":["话"],"categories":["生活与话"]},{"title":"前端交互动画优化","url":"/21706/","content":"\n最基本的优化思路就是优化DOM的读写操作\n\n<font color=#192e4d size=4>减少对DOM元素读操作：</font>\n\n缓存DOM引用","tags":["面试题"],"categories":["算法与面试题"]},{"title":"touch和mkdir","url":"/43934/","content":"\n创建文件：<font color=#229bcc size=5>touch XXX</font> 创建文件夹：<font color=#1a6f94 size=5>mkdir XXX</font>\n\n\n\n","tags":["Linux命令"],"categories":["语言与Linux"]},{"title":"Vue如何实现组件缓存","url":"/15385/","content":"\nkeep-alive：组件级缓存\n\n两种模式：全局缓存/局部组件缓存\n\n页面跳转到详情页面时，需要保持列表页的滚动条的深度，等返回的时候也然在这个位置。\n\n<font color=#395e92 size=4>使用方式：</font>keep-alive是抽象组件（或称为功能型组件），实际不会被渲染在\tDOM树中。它的作用是在内存中缓存组件（不让组件销毁），等到下次渲染的时候，还保持其中的所有状态，并触发activated钩子函数。缓存的额需要通常出现在页面切换时\n\n<font color=#2f87b0 size=4>全局缓存 </font>    <!--more-->\n\n```js\n<keep-alive>\n       <router-view /> \n</keep-alive>\n```\n\n<font color=#2fb0a5 size=4>局部缓存：</font>使用keep-alive组件的include/exclude属性。include属性表示要缓存的组件名（组件定义时的name属性）\n\n```js\n    <!--缓存想要缓存的页面，实现后退不刷新-->\n    <!--加上v-if的判断，可以自定义想要缓存的组件，自定义在router里面-->\n    <keep-alive>\n      <router-view v-if=\"$route.meta.keepAlive\"></router-view>\n    </keep-alive>\n    <router-view v-if=\"!$route.meta.keepAlive\"></router-view>\n```\n\n在router文件加上meta判断\n\n```js\nexport default new Router({\n    {\n    // home会被缓存\n    path:\"/home\",\n    component:home,\n    meta:{keepAlive: true}\n    },\n      {\n     // home不会被缓存\n    path:\"/home\",\n    component:home,\n    meta:{keepAlive: false}                \n       }                    \n})\n```\n\n<font color=#18919b size=4>注：</font>如果想要看有没有缓存成功，可以再各个组件的created钩子里面打印输出标志，缓存成功就是首次进入页面，created会请求数据，后面就不会再次请求而是直接调用缓存的\n\n","tags":["面试题"],"categories":["算法与面试题"]},{"title":"watch用箭头函数会出现什么情况？","url":"/6214/","content":"\nthis是undefined，typeError错误。Cannot read property ‘xxx’ of undefined","tags":["面试题"],"categories":["算法与面试题"]},{"title":"箭头函数和普通函数的区别","url":"/55686/","content":"\n1.箭头函数没有this对象，因此不可以用构造函数，不能用call(), apply(), bin()这些方法去改变this指向\n\n<!--more-->\n\n2.不绑定arguments对象，不过可以使用rest参数来解决\n\n3.不能使用new操作符，会报错\n\n4.没有prototype属性（原型）\n\n5.不能作用生成器\n\n总结：\n\n箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或 new.target。这些函数表达式最适合用于非方法函数(non-method functions)，并且它们不能用作构造函数。\n\n扩展：\n\n箭头函数的 `IIEF`:\n\n```js\n(() => {\nconsole.log('1');\n})(); \n```\n\n上面的是可以，但是下面的写法就会报错\n\n```js\n(() => {\nconsole.log('1');\n}());\n```\n\n原因：","tags":["面试题"],"categories":["算法与面试题"]},{"title":"vuex常用的属性","url":"/30915/","content":"\n \n\n| state        | geters   | muations                 | acions                       | modules    |\n| ------------ | -------- | ------------------------ | ---------------------------- | ---------- |\n| 全局基本数据 | 计算属性 | 提交更改数据的方法，同步 | 提交更改数据的方法，可以异步 | 分割成模块 |\n\n","tags":["面试题"],"categories":["算法与面试题"]},{"title":"mv命令","url":"/26599/","content":"\n Linux mv命令用来为文件或目录改名 或这文件或目录移动到其它位置\n\nmv 源文件名 目标文件名   表示将源文件名改为目标文件名\n\n命令格式：\n\n| 命令格式         | 结果                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| mv 文件名 文件名 | 将源文件名改为目标文件名                                     |\n| mv 文件名 目录名 | 将文件移动到目标目录                                         |\n| mv 目录名 目录名 | 目标目录已存在，将源目录移动到目标目录；目标目录不存在则改名 |\n| mv 目录名 文件名 | 出错                                                         |\n\n参数：<!--more-->\n\n| -i   | 若存在同名文件，则向用户询问是否覆盖                         |\n| ---- | ------------------------------------------------------------ |\n| -f   | 覆盖已有文件时，不进行任何提示                               |\n| -b   | 当文件存在时，覆盖前为其创建一个备份                         |\n| -u   | 当源文件比目标文件新，或者目标文件不存在时，才执行移动此操作 |\n| -t   | 复制多个文件或文件夹                                         |\n\n","tags":["Linux命令"],"categories":["语言与Linux"]},{"title":"Vue的两种路由模式","url":"/30846/","content":"\n在vue-router路由对象中，有两种模式：<font color=#F6416C>hash</font>和<font color=#9708CC>history</font>，默认的是hash模式\n\n扩展:\n\n<font color=#130CB7 size=4>hash路由:</font>监听路由的变化：`onhashchange事件`，只有#后的地址发生变化，可以在window对象上监听：\n\n```js\nwindow.onhashchange = function(event) {\n    let hash = loaction.hash\n}\n```\n\n<font color=#130CB7 size=4>history路由:</font>模式充分利用 `history.pushState` API 来完成 URL 跳转而无须重新加载页面。<!--more-->\n\n```js\nconst router = new VueRouter({\n  mode: 'history',\n  routes: [...]\n})\n```\n\n注：使用history需要后台配置支持，因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问网页就会返回 404。\n\n只需在服务器增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 `index.html` 页面，这个页面就是你 app 依赖的页面","tags":["面试题"],"categories":["算法与面试题"]},{"title":"Vue全家桶","url":"/7863/","content":"\n<font color=#0080FF>Vue  </font><font color=#DF3A01>vue-router</font>       <font color=#086A87>vue-cli </font>  <font color=#8A084B>  Vuex-resource</font>\n\n","tags":["面试题"],"categories":["算法与面试题"]},{"title":"路由的动态获取","url":"/53218/","content":"\n第一种利用<font color=#4C83FF>$route.query</font>属性获取连接上的参数，url参数使用？形式\n\n第二种利用<font color=#4C83FF>$route.params</font>获取参数，url形式是/参数形式\n\n","tags":["面试题"],"categories":["算法与面试题"]},{"title":"jquery和react区别","url":"/22299/","content":"\nReact是UI库而JQuery则是工具库，然后就是对Dom操作的不同，<font color=#16d9e3 size=4>Reactjs</font>提供了一整套的vistualDom（虚拟Dom）所有的操作都在这个虚拟的额Dom上而非\n\n真实的Dom，React默认这个真实Dom是不会被改变，而改变的只有虚拟的Dom，然后通过这个虚拟的Dom来对真实的Dom进行渲染。<font color=#37ecba size=4>JQuery</font>则是操作真实的Dom，处理事件方式就是用选择器筛选出需要改变的Dom元素，或者监听Dom，最后改变真实的Dom来达到预期的结构","tags":["面试题"],"categories":["算法与面试题"]},{"title":"2.x与3.x脚手架的区别","url":"/16190/","content":"\n3.x启动npm run serve\n\n2.x启动npm run dev","categories":["算法与面试题"]},{"title":"项目脚手架的创建与运行","url":"/48786/","content":"\n下载：\n\n```bash\nnpm install -g @vue/cli\n# OR\nyarn global add @vue/cli\n```\n\n然后用<font color=#7AC5CD>vue --version</font>检查版本是否正确\n\n创建项目：<font color=#7AC5CD>vue create  XXX</font>\n\n   注： 根据需要选择\n\n运行项目：<font color=#7AC5CD>npm run serve</font>","tags":["面试题"],"categories":["算法与面试题"]},{"title":"Vue双向数据绑定的原理","url":"/48826/","content":"\n<font color=#00C5CD size=4>vue的双向数据绑定：</font>是通过数据劫持 结合 发布订阅模式的方式实现。数据和视图同步，数据发生变化，视图也跟着变化，数据也随之发生改变。\n\n简单来说就是通过Object对象的defineProperty属性，重写data的set和get函数来实现的\n\n------\n\n<font color=red>核心就是Object.defineProperty()方法</font>\n\n<font color=#008B8B size=5>扩展：</font>Object.defineProperty()方法\n\nObject.defineProperty(obj，prop，descriptor)参数：obj（定义属性对象）prop（定义或修改的属性）descriptor（具体的改变方法）<!--more-->\n\n用这个方法定义一个值，当调用时使用它里面的get方法，当给属性赋值时，又用到set方法\n\n```js\nvar obj = {};\n Object.defineProperty(obj, 'hello',{\n     get: function () {\n         console.log('调用了get方法')\n     },\n     set: function (newVal) {\n         console.log('调用了set方法，方法的值为' + newVal)\n     }\n })；\n obj.hello;\nobj.hello = 'hi';\n```\n\n<font color=#00C5CD size=5>JS双向数据绑定</font>通过添加事件监听keyup来触发set方法，而set在修改访问器属性的同时，在修改了dom样式，改变了span标签的文本\n\n```js\n<script>\n   var obj = [];   // 定义一个空对象\n\n   var k = 'once'; // 赋予初始值\n     \n    Object.defineProperty(obj, 'k', {\n        get: function () {\n            return k;\n        },\n\n        set: function (newK) {\n            k = newK;   // 定义k等于修改后的内容\n                // 让文本框的内容等于k\n            document.getElementById('a').value = k  \n            // 让span的内容等于k\n            document.getElementById('b').innerHTML = k  \n        }\n    });\n    document.addEventListener('keyup', function (e) {\n         //当在文本框输入内容时让对象里你定义的val等于文本框的值\n        obj.k = e.target.value;                                   \n    })\n\n</script>\n```\n\n<font color=#00C5CD size=5>vue的双向数据绑定：</font>就是普通单向绑定和事件组合来完成的\n\n```vue\n<div id=\"vm\">\n           \n        <p>邮箱<input v-model=\"email\"></p>\n            <span>{{email}}</span>\n        <p>名字<input v-model=\"name\"></p>\n     <span>{{name}}</span>\n       </div>\n            \n       \n        <script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n        <script type=\"text/javascript\">\n            var vm = new Vue({\n                el: '#vm',\n                data: {\n                    email: '',\n                    name: ''\n                }\n            });   \n    </script>\n```\n\n<font color=red size=5>理解：</font>\n\n①将vue中的data中的内容绑定到输入文本框和文本节点中\n\n②文本框的内容改变时，vue实例中的data也同时发生改变\n\n③当data中的内容发生改变时，输入框及文本节点的内容也发生变化\n\n<font color=#A52A2A>注：如果使用appendCid方法将原dom树中的节点添加到DocumenntFragment中时，会删除原来的节点</font>","tags":["面试题"],"categories":["算法与面试题"]},{"title":"导航守卫的理解","url":"/53584/","content":"\n<font color=#04b8cf size=4>导航守卫</font>主要用来**通过跳转或取消的方式守卫导航**。\n\n​         简单来说就是路由跳转过程中的一些钩子函数\n\n------\n\n<font color=#04b8cf size=4>扩展：</font>\n\n钩子函数执行顺序：\n\n全局前置守卫：beforeEach——>路由beforeEnter守卫——>组件路由守卫beforeRouteEnter（this并不指向该组件实例）——>全局解析守卫：beforeResolve——>全局后置守卫：afterEach——>组件生命周期：beforeCreate——>组件生命周期created——>组件生命周期beforeMount——>组件声明周期mounted——>组件路由守卫beforeRouteEnter的next回调\n\n<font color=#04b8cf size=4>导航守卫分为：</font>\n\n`全局`、`单个路由独享`、`组件内`三种。 <!-- more-->\n\n------\n\n<font color=#04b8cf size=4>全局：</font>指路由实例上直接操作的钩子函数，所有路由配置的组件都会触发，大白话就是触发路由就会触发这些钩子函数。\n\n<font color=#ed8c86>beforeEach</font>、<font color=#ed8c86>beforeResolve（2.5+）</font>、<font color=#ed8c86>afterEach</font>\n\n```js\nconst router = new VueRouter({\n  \n    router.beforeEach((to, from, next) => {\n    ....\n  })\n})\n```\n\n<font color=#ed8c86>[beforeEach]</font> :在路由跳转前触发，参数包括to，from，next作用：用于登录验证，路由没跳转前告知\n\n<font color=#ed8c86>[beforeResolve]（2.5+）</font> :以上类似，<a href=\"(https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#全局前置守卫)\">官方文档</a>：区别是在导航被确认之前，<u>**同时在所有组件内守卫和异步路由组件被解析之后**</u>，解析守卫就被调用。\n\n<font color=#ed8c86>[afterEach]</font>:在路由跳转后触发，参数to ，from  发生在beforeEach和beforeResolve之后，beforeRouteEnter之前\n\n------\n\n<font color=#04b8cf size=4>路由独享:</font>指单个路由配置的时候设置钩子函数\n\n```js\nconst router = new VueRouter({\n    roues: [\n        {\n        path: '',\n        component: ,\n        beforeEnter: (to, from ,next) => {\n           ....\n       }\n     }                     \n    ]\n})\n```\n\n<font color= #ed8c86>[beforeEnter] ：</font>和...Each相同，都设置在...Each之后执行参数to,from,next\n\n------\n\n<font color=#04b8cf size=4>组件内：</font>指在组件内执行钩子函数，类似组件的生命周期，相当于为路由组件添加生命周期钩子函数\n\n  <font color=#ed8c86>beforeRouteEnter</font>、<font color=#ed8c86>beforeRouteUpdate（2.2+）</font>、<font color=#ed8c86>beforeRouteLeave</font>\n\n```js\n export default {\n     name: '',\n     data () {\n         return {\n             ....\n         }\n     },\n      beforeRouteEnter (to, from, next) {\n          // 在渲染组件的对用路由被confirm前调用\n          // 不能用this！！不能用this！！不能用this！！\n          // this并不指向该组件实例\n      }，\n      beforeRouteUpdate (to, from, next) {\n          // 当前路由改变，组件被复用时调用\n          // 可以访问组件实例！！this！！\n      }，\n      beforeRouteLeave （to, from, next）{\n          // 导航离开组件的对应路由时调用\n          // 可以访问组件实例 ！！this！！\n      }\n }\n```\n\n<font color=#ed8c86>[beforeRouteEnter] :</font>路由之前调用，参数to，from，next\n\n   在全局守卫beforeEach和独享守卫beforeEnter之后，全局beforeResolve和全局afterEach之前调用。在beforeCreate生命周期前触发。\n\n**<u>注：该守卫访问不到组件实例，this为undefined</u>**\n\n**★★★可以通过传一个回调给next来访问组件实例，在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数，可以在这个守卫中请求服务端获取数据，当成功获取并能进入路由时，调用next并在回调中通果vm访问组件实例进行赋值等操作需注意的是next中函数的调用在mounted之后：主要是为了确保能对组件实例的完整访问**\n\n ```js\nbeforeRouteEnter （to, from, next）{\n    next (vm => {\n        // 通过vm访问组件实例\n    })\n}\n ```\n\n<font color=#ed8c86>[beforeRouteUpdate] (2.2+) :</font>路由改变时，且组件被复用时调用（this可以！！！）参数：to，from， next\n\n<font color=#7719AA><b>★★什么时候路由改变？ &&  什么时候组件被复用？</b></font>\n\n   1.带有动态参数的路径\n\n   2.路由query变更时，该守卫会被调用\n\n<font color=#7719AA>★★★<b>补充：query和params的用法区别</b></font>\n\n   <font color=#e04f82 size=3>query:</font>\n\n```js\nthis.$router.push({\n    path: '',\n    query: {\n        type: ,\n        typeDesc: \n    }\n})\n```\n\n【query用path引入，params要用name引入。接收参数类似：`this.$route.query.name`和 `this.$route.params.name `                     query在浏览器地址中显示参数params则不显示 \n\n【注：query刷新不会丢失query里面的数据。params刷新会丢失params里面的数据】<u>**看需求使用**</u>      \n\n​    如：刷新获取不同的值用params，反之就用query】\n\n<font color=#e04f82 size=3 >params:</font>\n\n```js\nthis.$router.push({\n    name: '',\n    params: {\n        type: ,\n        typeDesc:\n    }\n})\n```\n\n<font color=#ed8c86>[beforeRouteLeave] :</font>导航组件离开组件的对应路由时调用（this可以！！！）\n\n参数：to, from, next\n\n------\n\n<font color=#04b8cf size=4>回调参数:</font>【重点★★★★】\n\nto: 目标路由对象\n\nfrom：离开的路由对象\n\nnext：下一个钩子\n\n值得注意的是但凡涉及到next参数的钩子，需调用next（）才能继续执行下一个钩子，否则路由跳转会停止。还有就是如果要中断当前的导航要调用next(false)【用于登录验证不通过处理】，URL的改变（手动或浏览器回退按钮）会让URL地址重置到from路由对应的地址。当然next也可以如以下方法使用：next('/')或next({path:'/'}):跳转到一个不同的地址。白话就是当前导航被中断，则执行一个新的导航。参数<a href=\"https://router.vuejs.org/zh/guide/essentials/navigation.html\">router.push</a>一致\n\nbeforeRouteEnter钩子中的next（（vm）=> {}）内接受的回调函数参数为当前组件的实例vm，在生命周期mounted之后调用。最后执行的钩子函数\n\nnext(error)：（v2.4.0+）如果传入next的参数是一个Error实例，则导航会被终止该错误会被传递给<a href=\"https://router.vuejs.org/zh/api/#router-onerror\">router.onError</a>注册过得回调\n\n**被调用的错误如以下情形：**\n\n> - 错误在一个路由守卫函数中被同步抛出；\n> - 错误在一个路由守卫函数中通过调用 `next(err)` 的方式异步捕获并处理；\n> - 渲染一个路由的过程中，需要尝试解析一个异步组件时发生错误。","tags":["面试题"],"categories":["算法与面试题"]},{"title":"clear命令","url":"/36300/","content":"\nclear ：清空终端","tags":["Linux命令"],"categories":["语言与Linux"]},{"title":"如何安装Cmder","url":"/24383/","content":"\n  替换win10自带的`cmd`和`power shell`，两项方案：\n\n​    方案一：`Windows terminal`\n\n在微软商场下载`Windows terminal`不过只能win10下载而且版本号要升级到1903版本以上\n\n  方案二：`Cmder`\t\n\n​    在<a href=\"https://cmder.net/\">官网</a>下载Cmder,不要下载Mini（不支持Git）下载Download Full\n\n​    ①安装：把下载的压缩包解压到`C:\\Users\\XXX`进入文件夹（免安装直接运行但是需要配置）\n\n​    ②需要把这个地址（解压的地址）加到系统的path环境中   **<u>(Cmder的c要大写！！！Cmder的c要大写！！！Cmder的c要大写！！！)</u>**      <!-- more -->\n\n>        win-->搜索编辑系统环境变量-->环境变量-->用户变量/系统变量-->新建-->变量名CMDER_ROOT/值**(解压地址+Cmder.exe)**\n\n   ③配置`cmder`到右键菜单：**右键Cmder.exe属性-兼容性-以管理员身份运行此程序**然后重新打开Cmder.exe输入`Cmder.exe /REGISTER ALL`\n\n补充：`Cmder.exe /REGISTER ALL`开头一定大写，有可能会报错\n\n也可以到<a href=\"https://github.com/cmderdev/cmder/wiki/Setting-up-Environment-Variables\">github</a>上参考官方设置\n\n------\n\n了解：\n\n`Windows terminal`是微软在2019年5月6日至5月8日的 Build 2019 大会上展示了 `Windows Terminal`且开源\n\n`Cmder`是一个增强型命令行工具，不仅可以使用windows下的所有命令，也可以使用linux的命令,shell命令。","tags":["软件"],"categories":["应用与插件"]},{"title":"编译的三个步骤（了解）","url":"/22558/","content":"\n 分词/词法分析（Tokenizing/Lexing）\n\n   将由字符组成的字符串分解成有意义的代码块，被称为`词法单元`\n\n他们俩的主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的\n\n解析/语法分析（Parsing）\n\n 将词法单元流（`数组`）转换成一个有元素逐级嵌套所1组成的代表了程序语法结构的书，被称为`抽象语法树`也就是常说的AST，全名为Abstract Syntax Tree\n\n代码生成\n\n将AST转化为可执行代码的过程称为代码生成\n\n**<u>注：这里说的是传统编译器</u>**","tags":["js"],"categories":["Web前端"]},{"title":"话六","url":"/18014/","content":"\n生命中总有不期而遇的惊喜和生生不息的希望。","tags":["话"],"categories":["生活与话"]},{"title":"话五","url":"/25822/","content":"\n记忆是一种相聚的方式，放下是一种自由的形式。不必悲伤，不必忧愁，邂逅的回忆都是美好的故事。","tags":["话"],"categories":["生活与话"]},{"title":"话四","url":"/61655/","content":"\n如果结果不如你所愿 就在尘埃落定的那一刻，奋力一搏！","tags":["话"],"categories":["生活与话"]},{"title":"冒泡排序","url":"/21238/","content":"\n`冒泡排序:`的实现思路是比较任何两个相邻的项, 如果前者比后者大, 则将它们互换位置.\n\n​    生成指定个数的随机数组\n\n```js\n   const generateArr = (num = 10) => {\n  let arr = []\n  for(let i = 0; i< num; i++) {\n    let item = Math.floor(Math.random() * (num + 1))\n    arr.push(item)\n  }\n  return arr\n}\n    \n```\n​      `冒泡排序:`         <!--more-->\n\n```js\nbubbleSort(arr = []) {\n    let lkz = arr.length\n    for(let i = 0; i< lkz; i++) {\n      for(let j = 0; j < lkz - 1; j++) {\n        if(arr[j] > arr[j+1]) {\n          [arr[j], arr[j+1]] = [arr[j+1], arr[j]]\n        }\n      }\n    }\n    return arr\n  }\n\n```\n\n `const arr = generateArr(60)`\n\n   `冒泡排序优化:`\n\n```js\nbubbleSort(arr = []) {\n  let lkz = arr.length\n  // 优化\n  for(let i = 0; i< lkz; i++) {\n    for(let j = 0; j < lkz - 1 - i; j++) {\n      if(arr[j] > arr[j+1]) {\n        // 置换\n        [arr[j], arr[j+1]] = [arr[j+1], arr[j]]\n      }\n    }\n  }\n  return arr\n}\n```\n\n","tags":["排序"],"categories":["算法与面试题"]},{"title":"线性思维","url":"/753/","content":"\n引：`通常夸大生活事件所带来的消极影响的倾向称之为“恐怖化”`\n\n而线性思维所带来最大的负面影响，就是让人容易产生恐怖化的情绪\n\n一但有什么事情没有按照既定的线性往上发展的时候，我们就会给自己给自己制造障碍，自己给自己加戏，对，你没听错是加戏。但实际上，让我们焦头烂额的事情其实是受制于这样的线性思维，往往会刻意夸大现在的痛苦....\n\n1.用`追求卓越`来替代`追求优秀`\n\n2.紧盯`别人`的成功，不如记录`自己`的想法\n\n3.再多思考一层","tags":["心理学"],"categories":["爱好心理学"]},{"title":"token","url":"/32630/","content":"\n`响应拦截器：` 处理token过期问题\n\n 替换token\n\n<!--more-->\n\n```js\n// Add a 响应拦截器 interceptor\nrequest.interceptors.response.use(function (response) {\n  // Any status code that lie within the range of 2xx cause this function to trigger\n  // Do something with response data\n  return response\n}, async function (error) {\n  // 有错误到这里来,只处理401错误(是由token过期，错误导致)。\n  if (error.response.status === 401) {\n    if (store.state.user && store.state.user.refresh_token) {\n      try {\n        // 用refresh_token去求一个特殊的接口以获取新的token\n        const result = await axios({\n          url: 'http://ttapi.research.itcast.cn/app/v1_0/authorizations',\n          method: 'PUT',\n          headers: {\n            Authorization: `Bearer ${store.state.user.refresh_token}`\n          }\n        })\n\n        // 从接口返加值中去取出新token，更新到当前的vuex中\n        // mutations去改token\n        store.commit('updateToken', result.data.data.token)\n        console.log('更新token ok')\n        // console.log(result)\n        // error.config 就是当前错误发生时，axios中的配置\n\n        // 更新了token请求重发一次\n        return request(error.config)\n        // store.state.user.token = result.data.data.token\n      } catch (e) {\n        console.log('更新token，refresh_token 失败')\n        // 消除vuex的token\n        store.commit('setUser', null)\n        // 必须要重新登陆\n        router.push({\n          path: '/login',\n          query: {\n            // router中有一个属性currentRoute\n            from: router.currentRoute.fullPath\n          }\n        })\n      }\n    } else {\n      console.log('没有refresh token,准备去重新登陆吧')\n      router.push({\n        path: '/login',\n        query: {\n          // router中有一个属性currentRoute\n          from: router.currentRoute.fullPath\n        }\n      })\n    }\n    console.log('响应拦截器')\n    console.dir(error)\n  } else {\n    return Promise.reject(error)\n  }\n})\n```\n\n","tags":["vue"],"categories":["Web前端"]},{"title":"节流与防抖","url":"/10377/","content":"\n`防抖:`抖：高频率的发送请求\n\n`思路：`当函数被调用时，不立即执行，而是延迟10秒执行。\n\n如果在这10秒内再次调用了这个函数，则从当前被调用的时间开始计算\n\n<!--more-->\n\n ```js\nhSearch () {\n if (this.timer) {\n    cleraTimeout(this.timer)\n } \n  this.timer = setTimeout(async () => {\n     if (!this.keyword) {\n      return\n}\n   const result = await getSearchSuggestions(this.keyword)\nthis.searchSuggestions = result.data.data.options\n}, 0.3 * 1000)\n}\n ```\n\n`节流：`低频率发送请求\n\n` 思路：`如果这个函数距离上一次被调用的时间之间相隔不到10秒，则本次调用，不执行代码\n\n两次有效调用时间，并且至少相隔10秒\n\n```js\nhSearch () {\n// 只有this.timer是null，才会开启下一个定时器\n if (!this.timer) {\n// 只要setTimeout一执行，this.timer就有值了\n   this.timer = setTimeout(async () => {\n      this.timer = null\n      if (!this.keyword) {\n         return\n}\n  const result = await getSearchSuggestions(this.word)\n}, 0.3 * 1000)\n}\n}\n```\n\n","tags":["vue"],"categories":["Web前端"]},{"title":"话三","url":"/3359/","content":"\n正义从来不是道德的标杆，而是立场的选择","tags":["话"],"categories":["生活与话"]},{"title":"话二","url":"/28382/","content":"\n人会有`前`  `后`的观念，只不过因为视野太小， 所谓的前进 也就只是向着狭小视野的方向移动罢了","tags":["话"],"categories":["生活与话"]},{"title":"关于如何使用跨组件","url":"/50152/","content":"\n事件总线三种方法：\n\n`$on`,`$emit`,`$off` \n\n- 画图： \n\n  1.index.vue. \n\n  2.articleList.vue \n\n  3.moreAction.vue \n\n  4.channelEdit.vue \n\n  eventBus ","tags":["vue"],"categories":["Web前端"]},{"title":"Electron安装问题","url":"/12545/","content":"\n### 关于如何安装eletron卡在node install.js的解决方法\n\n①在`.npmrc`里写入以下数据：在`C:\\Users\\***`下\n\n`electron_mirror=\"https://npm.taobao.org/mirrors/electron/\"`\n\n②`npm`安装`node-sass`   网速慢可以切换淘宝的镜像源或`npm i nrm`工具\n\n在`.npmrc`里写入以下数据：\n\n `registry=https://registry.npm.taobao.org` `sass_binary_site=https://npm.taobao.org/mirrors/node-sass/` `phantomjs_cdnurl=http://npm.taobao.org/mirrors/phantomjs` `ELECTRON_MIRROR=http://npm.taobao.org/mirrors/electron/`\n\n注：需要删除已安装的`node_modules`然后重新安装`electron`，如果有其它的包则需要重新`npm install`下。~~应该都有初始化吧`npm init`~~\n\n​\tEg:`npm install --save-dev electron`\n\n","categories":["应用与插件"]},{"title":"话一","url":"/3039/","content":"\n要别人肯定你的同时，首先自己要先肯定自己，自己若不能肯定自己，那你最大的敌人永远也是你自己，这个观念讲起来很简单，但你有认真想过吗？自己是如何输给自己，又是如何赢了自己，又要如何才能超越自己。有些事没必要想的太复杂。犹豫不决，所换到的结果就是浪费时间，时间不是你想掌握就会停止的东西..所以珍惜现在吧\n\n","tags":["话"],"categories":["生活与话"]},{"title":"vuex的核心","url":"/49063/","content":"\n`state：`作用：定义全局数据(`保存所以公共数据`)。类似data\n\n```js\nexport default new Vue.store({\n    state:{\n        \n    }\n  })\nexport default store\n```\n\n获取数据：`state`\n\n直接使用：`1.this.$store.state.自定义`\n\n映射的方式：`2.computed:{...mapState([''])}`     <!--more-->\n\n<u>**注：在Vue中不推荐直接在组件内部通过`this.$store.state.全局数据名称=新值`来修改Vue**</u>\n\n`mutation`作用：修改公共数据\n\n```js\nconst store = new Vuex.Store({\n    state: {\n        \n    },\n    mutations: {\n        \n    }\n})\n```\n\n修改：`mutations`\n\n直接使用：`this.$store.commit('','')`**<u>不推荐</u>**\n\n`map`映射的方式：`{\nmethods:{\n// 相当于是在当前组件内部的methods加了对应的方法\n   ...mapMutations(['mutation名'，'mutation名'])\n}\n}`\n\n\n\n`※action`作用：可以执行异步代码；可以同时调用多个mutation\n\n```js\nnew Vuex.store ({\n    state: {},\n    actions: {\n       函数名 :function（参数1，参数2）{\n        \n   }\n  }\n})\n```\n\n使用：`actions`\n\n直接使用：`this.$store.dispatch`\n\n`map`映射的方式：`methods:{...mapActions ([''])}`\n\n","tags":["vue"],"categories":["Web前端"]},{"title":"组建之间共享方式","url":"/52631/","content":"\n`vuex`独立于所有的组件\n\n作用\n\n   `对所以组件需要用到的公共数据,进行管理`\n\n是一种新的组建之间数据共享的方式\n\n`父子`\n\n`eventBus`\n\n`Vuex`\n\n`payload`\n\n`mapMutations`\n\n`mapState`\n\nactions 中 调用 ———————— 去修改数据？ \n\n`mutation`","tags":["vue"],"categories":["Web前端"]},{"title":"vertical-align","url":"/65060/","content":"\n  [CSS](https://developer.mozilla.org/en-US/docs/CSS) 的属性 **`vertical-align`** 用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。\n\n语法：vertical-align: ;\n\n#### **行内元素的值:**\n\n​    **<u>相对父元素的值：</u>**这些值使元素相对其父元素垂直对齐：\n\n`baseline`\n\n使元素的基线与父元素的基线对齐。\n\n`sub`\n\n使元素的基线与父元素的下标基线对齐。<!--more-->\n\n`super`\n\n使元素的基线与父元素的上标基线对齐。\n\n`text-top`\n\n使元素的顶部与父元素的字体顶部对齐。\n\n`text-bottom`\n\n使元素的底部与父元素的字体底部对齐。\n\n`middle`\n\n使元素的中部与父元素的基线加上父元素x-height（译注：[x高度](https://www.zhangxinxu.com/wordpress/2015/06/about-letter-x-of-css/)）的一半对齐。\n\n`<length>`\n\n使元素的基线对齐到父元素的基线之上的给定长度。可以是负数。\n\n`<percentage>`\n\n使元素的基线对齐到父元素的基线之上的给定百分比，该百分比是[`line-height`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-height)属性的百分比。可以是负数。\n\n**<u>相对行的值：</u>**使元素相对整行垂直对齐\n\n`top`\n\n使元素及其后代元素的顶部与整行的顶部对齐。\n\n`bottom`\n\n使元素及其后代元素的底部与整行的底部对齐。\n\n没有基线的元素，使用外边距的下边缘替代。\n\n#### **表格单元格的值**\n\n`baseline` (以及 `sub`, `super`, `text-top`, `text-bottom`, `<length>`, `<percentage>`)\n\n使单元格的基线，与该行中所有以基线对齐的其它单元格的基线对齐\n\n`top`\n\n使单元格内边距的上边缘与该行顶部对齐。\n\n`middle`\n\n使单元格内边距盒模型在该行内居中对齐。\n\n`bottom`\n\n使单元格内边距的下边缘与该行底部对齐。\n\n可以是负数。\n\n**注： `vertical-align` 只对行内元素、表格单元格元素生效：不能用它垂直对齐[块级元素](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Block-level_elements)。**","tags":["CSS"],"categories":["Web前端"]},{"title":"重定向与编程式导航与路由嵌套","url":"/44027/","content":"\n####  **vue-router-重定向**\n\n  指：访问某一个路由，自动跳转到另外一个路径\n\n 核心代码：{path:\"/\",redirect:\"/home}\n\n#### **vue-touter-编程式导航**\n\n指：通过js的方式触发路由的跳转\n\n核心代码：`提供路由相关函数`跳转方法this.$router.push()\n\n  注：`route是获取路由相关信息`路由传参  this.$route.params <!--more-->\n\n#### **vue-router-路由嵌套**    \n\n指：套娃\n\n核心：children\n\n引：要进行路由的嵌套，只需要在**<u>一级路由规则</u>**下，加上一个属性` children`，即可定义二级路由规则。","tags":["vue"],"categories":["Web前端"]},{"title":"语法糖","url":"/36835/","content":"\n​       Vue指令\n\n1.v-model 指令是一个语法糖（简写）就是简写了：:value 与 @input 两段代码\n\n```\n:value = 'msg' 与 @input = 'msg=$event.target.value'\n```\n\nclass:  :class绑定类\n\nstyle: 绑定行内样式\n\n <!--more-->\n\nv-mode: 1\n\nv-cloak:  [v-cloak]{display:none};      浏览器解析插值表达式闪烁问题\n\nv-once:指渲染一次，之后不受影响 没有值\n\n### **自定义过滤器：**\n\n#### **全局：** api使用方法 Vue.filter('过滤器名称',' 处理函数')\n\n```\n    Vue.filter('up',(value)=>{})\n```\n\n#### **局部：**vue实例管理的视图才可以使用\n\n```\nconst vm = new Vue ({\n\n  filter:{\n  up(value){}\n  }\nel:''\ndata:{\n\n}\n\n\n})\n```\n\n使用过滤器：进行格式转换，使用过滤器\n\n```\n<div>\n {{***|up}}\n 术语：管道符\n\n\n</div>\n```\n\n### Vue操作DOM:获取dom操作dom\n\n 1.`Vue.filter('过滤器名称','处理函数') `固定\n\n2.`filter:{'过滤器名称':'处理函数'}`固定\n\n3.`处理函数return使用固定`\n\ndom：给需要获取的表签加上ref属性\n\neg:`<div ref='myDom'></div>`\t\t\n\n 1.`ref固定`\n\n2.`this.$refs也是固定`\n\n3.`myDom自定`\n\n### **Vue自定义指令**\n\n#### **全局自定义指令：**Vue.directive('指令的名称','指令的配置对象')  基本语法\n\n指令的名字在定义时候不需要加v-，在是用的时候才需要加v-\n\n    固定属性：inserted 在使用指令的元素渲染完毕后触发的函数\n    这个函数执行了，代表元素渲染完毕，才可以操作元素。\n    最后根据你指令的需求，实现业务逻辑。el 是使用指令的dom元素\n     Vue.directive('focus', {\n    \n       inserted (el) {\n    \n         el.focus()  \n         dom提供的api用了获取焦点\n       }\n    })\n\n#### **局部自定义指令：** directives:{ key: value }基本语法\n\nkey是 指令的名称 要求：定义时候不需要加v-，在是用的时候才需要加v-\n\n```\n   \nvalue是 指令的配置对象\n\n  directives: {\n      focus: {\n        inserted (el) {\n      el.focus()\n             }\n         }\n      },\n       el: '#app'\n       })\n```\n\nvue的计算属性：\n\n```\ncomputed: {\n \t\t// \n    reversedMessage () {\n      // 反转逻辑，处理之后的结果，是一定要return出去\n      return this.message.split('').reverse().join('')\n    }\n  }\n})\n```\n\n使用：直接使用\n\n```\n<div id=\"app\">\n  {{reversedMessage}}\n</div>\n```\n\n","tags":["vue"],"categories":["Web前端"]},{"title":"术语与指令","url":"/63531/","content":"\n选项：\n\nel: 获取指定的容器（具体的标签）element的缩写注：不能指定html和body容器作为试图容器\n\ndata: 数据驱动视图  响应式数据必须是 **显性的声明**       响应式数据必须在data当中提前声明\n\nmethods: 声明函数   可以给vm使用也可以提供视图使用 不可使用箭头函数\n\n <!--more-->\n\n指令： 标签的扩展功能属性\n\nv-text ：相当于innerText\n\nv-html：相当于innerHTML\n\nv-show：样式隐藏display：none \n\n- v-show使用场景：当元素要频繁的切换显示和隐藏 \n\n- v-if使用常用场景：当渲染的时候，就需要判断是否显示，今后不需要频繁切换\n- true显示 false 隐藏\n\nv-if：通过创建和移除元素隐藏\n\nv-on：事件   简写方式：@click=处理函数\n\n如果给绑定的函数传参需要带括号而且必须带$event\n\n  事件修饰符\n\nv-for：遍历 in 或of都一样\n\nv-bind：","tags":["vue"],"categories":["Web前端"]},{"title":"前后端的身份验证（概念）","url":"/12592/","content":"\n**Web 开发模式：**\n\n#### 1**.服务器端渲染的传统模式Web开发模式**\n\n服务器通过字符串的拼接，动态生成的\n\n**优点：**\n\n① 前端耗时少。因为服务器端负责动态生成 HTML 内容，浏览器只需要直接渲染页面即可。尤其是移动端，更省电。\n\n② 有利于SEO。因为服务器端响应的是完整的 HTML 页面内容，所以爬虫更容易爬取获得信息，更有利于 SEO。\n\n**缺点：**  <!--more-->\n\n① 占用服务器端资源。即服务器端完成 HTML 页面内容的拼接，如果请求较多，会对服务器造成一定的访问压力。\n\n② 不利于前后端分离，开发效率低。使用服务器端渲染，则无法进行分工合作，尤其对于前端复杂度高的项目，不利于\n项目高效开发。\n\n#### **2.前后端分离的新型Web开发模式**\n\n依赖于 Ajax 技术，也就是后端只负责提供 API 接口，前端使用 Ajax 调用接口的开发模式\n\n**优点：**\n\n① 开发体验好。前端专注于 UI 页面的开发，后端专注于api 的开发，且前端有更多的选择性。\n\n② 用户体验好。Ajax 技术的广泛应用，极大的提高了用户的体验，可以轻松实现页面的局部刷新。\n\n③ 减轻了服务器端的渲染压力。因为页面最终是在每个用户的浏览器中生成的。\n\n缺点：\n\n① 不利于 SEO（解决方案：利用Vue、React等前端框架SSR）\n\n#### **如何选择 Web 开发模式**\n\n看需求  没有复杂的交互用服务器........","tags":["HTML"],"categories":["Web前端"]},{"title":"常见错误","url":"/7535/","content":"\n### **1.nodemon不是内部或外部命令，也不是可运行的程序**\n\n问题解决： 全局安装nodemon包，这样新创建的node.js应用都可以使用nodemon 运行起来   \n\n  `npm install -g nodemon`\n\n### **2.不小心把磁盘变成EFI分区了**\n\n解决办法：\n\n用管理员打开 CMD 或者 PowerShell\n\n第一步——输入`diskpart` 提示：在计算机上：*****\n\n第二步——输入`list vol` 显示EFI分区<!--more-->\n\n第三步——输入`sel vol `多余EFI分区的号\n卷 * 是所选的卷\n\n第三步——`del vol override\n`成功删除了卷\n\n注：别删错EFI分区\n\n### **3.U盘启动盘提示缺少mmx64.efi的问题**\n\n  解决：\n\n把U盘里的EFI/BOOT里的文件随便一个文件名命名为mmx64.efi\n\n4.关于ThinkPad笔记本安装 双系统的问题\n\n  BIOS设置：Secure Boot设置为Enabled\n\n 分区：没试过，直接选择和win10共存\n\n关于UEFL设置：\n\n 第一.将U盘设为第一启动项 `shift +`\n\nStarup=>boot=>enter=>选择USB HDD ...=>shift 加 '+'\n\n第二.将`Boot Mode`设为`Quick`\n\n第三.将`Secure Boot`设置为`Enabled`\n\n### **4.Linux下如何升级nodejs**\n\n​     方案：\n\n​     安装n模块：`npm install -g n`\n\n​     升级node.js到最新稳定版\n\n​    ` n stable(推荐)`\n\n​     升级node.js到最新版\n\n​     ` n latest`\n\n报错：\n\n```\ncp: cannot stat `/usr/local/n/versions/node/12.16.1/lib': No such file or directory\ncp: cannot stat `/usr/local/n/versions/node/12.16.1/include': No such file or directory\ncp: cannot stat `/usr/local/n/versions/node/12.16.1/share': No such file or directory\n```\n\n 执行 n - 版本号\n\n然后重新安装\n\n注：可能需要酸酸乳\n\n### **5.无法找到add-apt-repository命令**\n\n  解决办法：\n\n  ~~sudo apt-get install python-software-properties~~\n\n sudo apt-get install software-properties-common\n\n### 6.Linux下报错internal/modules/cjs/loader.js:985 throw err\n\n解决：\n\n卸载npm--------`sudo apt-get remove --purge npm`\n\n删除--------------`rm -rf npm folder in`\n\n删除 -------------`rm -rf cahce_npm folder in`\n\n然后重新下载`npm------sudo apt-get install npm`\n\n### 7.如何切换包管理器\n\nWindows：\n\n解决：\n\n①直接删除`c:/用户/**/`下的`.vuerc`\n\n再次创建`vue create xx`或提示选择配置\n\n②手动修改`.vuerc`下的包\n\n注：*修改为`npm`或者`yarn`\n\n```\n{\n  \"useTaobaoRegistry\": true,\n  \"packageManager\": \"***\"\n}\n```\n\nLinux：\n\n`~/.vuerc`\n\n> 被保存的 preset 将会存在用户的 home 目录下一个名为 `.vuerc` 的 JSON 文件里。如果你想要修改被保存的 preset / 选项，可以编辑这个文件。\n\n终端下输入`vim .vuerc`修改\n\n### 8.如何删除`hexo`中的分类\n\n解决：\n\n首先删除`source文件夹`中的分类文件与删除`_postos`里的`.md`文件\n\n然后删除`db.json`文件\n\n在然后`hexo clean`接着`hexo g`和`hexo d`\n\n### 9.如何解决`ssh: connect to host github.com port 22: Connection timed out`\n\n问题的原因：`.ssh目录缺少config配置文件`\n\n解决：\n\n进入`.ssh`文件夹，创建`config`文件写入`xxx为你的邮箱地址`\n\n> Host github.com \n>\n>   User xxxxx@xx.com  \n>\n>  Hostname ssh.github.com \n>\n>   PreferredAuthentications publickey  \n>\n>  IdentityFile ~/.ssh/id_rsa \n>\n>   Port 443\n\n然后输入`ssh -T git@github.com`会出现一下提示\n\n> RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.                   Are you sure you want to continue connecting (yes/no/[fingerprint])? y\n> Please type 'yes', 'no' or the fingerprint: yes\n\n其实写入yes就可以了\n\n### 10.如何解决npm下载错误问题？\n\n> npm ERR! Unexpected end of JSON input while parsing near '...TURE-----\\r\\n\"}},\"1.2'\n>\n\n问题的原因可能是：`1.网络问题：需替换淘宝镜像源`，`2.解析时JSON输入的意外结束`\n\n解决：\n\n1.运行`npm cache clean --force`\n\n2.更换淘宝镜像源`npm config set registry=https://registry.npm.taobao.org/`\n\n### 11.下载node-sass报错\n\n> npm ERR! code ELIFECYCLE\n>\n> npm ERR! errno 1\n>\n> npm ERR! node-sass@4.14.1 postinstall: `node scripts/build.js`\n>\n> npm ERR! Exit status 1\n>\n> npm ERR!\n>\n> npm ERR! Failed at the node-sass@4.14.1 postinstall script.\n>\n> npm ERR! This is probably not a problem with npm. There is likely additional logging output above.\n\n​    原因：在github上克隆代码`npm install`时候报错，也无法run项目\n\n解决：\n\n1.更换源`npm install -g mirror-config-china --registry=http://registry.npm.taobao.org`\n\n然后在单独下载`npm install node-sass`\n\n`node-sass`的 <a href=https://github.com/sass/node-sass>github</a>地址\n\n### 12.deepin下typora安装报错\n\n`Error: could not find a distribution template`\n\n解决办法：\n\n​     终端打开 /etc/apt/sources.list 添加\n\n​     deb https://typora.io/linux ./\n\n注：首先要修改文件权限，在更改\n\n### 13.误操作导致硬盘格式化\n\n问题：\n\n安装linux分区的时候，不小心点击格式化\n\n解决办法：\n\n  下载大白菜做pe启动盘\n\n  bios设置u盘启动\n\n 进入pe系统后点击分区工具（diskgenius）进入之后，点击搜索分区....\n\n搜索完毕后，点击保存更改\n\n重启系统\n\n### 14.数据恢复后，重启显示verification failed:(15) access denied\n\n  解决办法：进入BIOS里面关闭安全启动（secure boot ----Enabled）\n\n重新启动\n\n### 15.重新启动后开机引导方式变成PCI LAN选项\n\n问题：\n\n开机的引导方式变成`PCI LAN`,并且前面有一个小箭头,无法正常启动加载。在BIOS中重置调整启动顺序也无法解决。无法进入U盘启动盘\n\n解决办法：\n\n1.进入BIOS找到`ecurity-->Secure Boot`选项回车\n\n2.回车后,把`Secure Boot`回车改成`Disabled`\n\n3.接着按ESC返回上一级菜单,选择StartUp选项,把UEFI/Legacy Boot回车改成Both把UEFI/Legacy Boot Priority改成`Legacy First`，把 CSM Support改成`YEs`，接着按F10-YES保存即可\n\n重新启动\n\n### 16.运行nrm时候PowerShell显示系统禁止运行脚本\n\n解决办法：\n\n以管理员打开PowerShell输入<font color=#2296a2 size=4>set-executionpolicy remotesigned</font>\n\n恢复原来设置则<font color=#2296a2 size=4>set-executionpolicy Restricted</font>\n\n已完（开新）[常见错误（二）](https://kisskisso.com/26624/)...\n\n\n\n","tags":["错误"],"categories":["笔记"]},{"title":"模块从缓存中加载（了解）","url":"/45350/","content":"\n**模块的加载机制：**优先从缓存中加载\n\n**<u>模块在第一次加载后会被缓存</u>**。这也意味着多次调用require() 不会导致模块的代码被执行多次。\n\n**注意：**不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率。\n\n**内置模块的加载机制：**内置模块的加载优先级最高。<!--more-->\n\n**自定义模块的加载机制：**必须指定以**./** 或 **../** 开头的路径标识符加载否则会把它当作内置模块或第三方模块进行加载。\n\n如果按确切的文件名没有找到模块，则Node.js 会尝试带上 .js、 .json 或 .node 拓展名再加载。\n\n⚫ .js 文件会被解析为JavaScript 文本文件\n\n⚫ .json 文件会被解析为JSON 文本文件\n\n⚫ .node 文件会被解析为通过process.dlopen() 加载的编译后的插件模块\n\n**第三方模块的加载机制：**从当前模块的父目录开 始，尝试从它的/node_modules 目录里加载模块。\n\n**目录作为模块：**","tags":["模块"],"categories":["Web前端"]},{"title":"基本SQL语句的学习","url":"/51039/","content":"\n-- **SELECT** 和 **FROM** 是 SQL 中的关键字，因此被高亮了\n\n-- SELECT * FROM users\n\n-- 只查询 id 和 username 两列\n\n-- 列之间使用英文的 , 进行分隔\n\n-- SELECT id, username FROM users\n\n-- 向 users 表中插入一条新数据\n\n-- insert into users (？, ？) values ('？', '？')\n-- select * from users <!--more-->\n\n-- 把 id 为 1 的这个用户的密码，更新为 888888\n\n-- 注意：在使用 update 更新数据的时候，千万要记得添加 where 条件，否则整张表的数据都会被更新\n\n-- update users set ？ where id=？\n\n-- 需求：更新 id 为 2 这个用户，把密码更新成 admin123 同时把status更新为 1\n\n-- update users set password='admin123', status=1 where id=2\n\n-- 删除 id 为 4 的这条用户数据\n-- delete from users where id=4\n\n-- 总结：\n\n-- select   insert into    update    delete\n\n-- 演示常用的 WHERE 子句运算符\n\n-- 不等于 <> 或 !=\n\n-- select * from users where id<>2\n\n-- select * from users where id!=2\n\n-- 大于和小于  >     <\n\n-- select * from users where id>2\n\n-- select * from users where id<2\n\n-- 大于等于    >=\n\n-- select * from users where id>=2\n\n-- 小于等于    <=\n\n-- select * from users where id<=2\n\n-- 查询 status 为 0 且 id 小于 10 的用户\n\n-- select * from users where status=0 and id<10\n\n-- 查询status为1或username为zs的用户列表\n\n-- select * from users where status=1 or username='zs'\n\n\n\n-- order by 用来根据指定的列进行排序\n\n-- desc 代表降序排序\n-\n\n- asc  代表升序排序\n- -- 按照 status 对结果进行降序排序\n- -- select * from users order by status desc\n- -- 按照 id 对结果进行降序排序\n- -- select * from users order by id desc\n","tags":["SQL"],"categories":["Web前端"]},{"title":"开发自己的包","url":"/15526/","content":"\n初始化包的基本结构：\n\n① 新建 itheima-utils文件夹，作为包的根目录\n\n② 在 itheima-utils文件夹中，新建如下三个文件：\n\n ⚫ package.json （包管理配置文件） \n\n ⚫ index.js          （包的入口文件） \n\n ⚫ README.md  （包的说明文档）\n\n  将不同的功能进行模块化拆分\n\n <!--more-->\n\n 编写包的说明文档\n\n注册npm账号\n\nnpm login \n\nnpm publish  【根目录】\n\n 注：包名不能一样\n\n删除已发布的包-----npm unpublish 包名 --force命令\n\n注意：\n\n① npm unpublish 命令只能删除 72 小时以内发布的包\n\n② npm unpublish 删除的包，在 24 小时内不允许重复发布\n\n③ 发布包的时候要慎重，尽量不要往npm 上发布没有意义的包\n\n~~发布包：不要乱发包~~\n\n","tags":["npm"],"categories":["Web前端"]},{"title":"npm命令合集","url":"/30590/","content":"\n命令：\n\nnpm -v -------可以查看版本号\n\nnpm init -y --------初始化【文件夹不能是中文】package.json\n\nnpm install 包的完整名  && npm i 包的名字（所以完整包）\n\nnpm uninstall 包 --------卸载指定的包\n\nnpm i 包安装包 @版本号----------安装指定版本的包\n\nnpm i 包名 -D --------项目上线不使用的包记录进去\n\n查看当前的下包的镜像源： <!--more-->\n\nnpm config get registry\n\n切换镜像源：\n\n~~npm config set registry=https://registrytaobao.org/~~\n\n`npm config set registry=https://registry.npm.taobao.org/`\n\n检查镜像源是否下载成功：\n\nnpm config get registry\n\n简单：\n\n下载nrm工具\n\nnpm i nrm -g ------将nrm安装为全局可用工具\n\n查看所有可用的镜像源\n\nnrm ls\n\n切换镜像源：\n\nnrm use taobao","tags":["npm"],"categories":["Web前端"]},{"title":"npm与包","url":"/50039/","content":"\n#### **什么叫做包？**\n\n就是指第三方模块，叫法同而已  ~~ps:感觉就像是闲的无聊~~\n\n包的来源？有网就可以下载，不是很麻烦  但是下载速吧。。。可能会让你抓狂\n\n#### **为什么需要包？**\n\n​    为了提高开发效率\n\n像是JQuery和浏览器内置API的关系\n\n官网： https://www.npmjs.com  ps：没有中文请自备翻译器\n\n初次安装包后，项目多node_module的文件夹和package-lock.json配置文件 <!--more-->\n\n**node_modules** 文件夹用来存放所有已安装到项目中的包。require() 导入第三方包时，就是从这个目录中查找并加载包。\n\n**package-lock.json**配置文件用来记录node_modules 目录下的每一个包的信息，例如包的名字、版本号、下载地址等。\n\n注意：不要手动修改node_modules 或 package-lock.json文件中的任何代码，npm 包管理工具会自动维护它们   ~~ps：估计没人会手贱吧(￣.￣)~~\n\n####   **多人协作问题：**\n\n  遇到的问题：第三方包的体积过大，不 方便团队成员之间共享项目源代码。\n\n解决方法：\n\n共享时剔除node_modules\n\n package.json，用来记录项目中安装了哪些包。\n\n注：运行时npm i 自动安装包和版本号\n\n####  **dependencies 节点：**\n\npackage.json 文件中，有一个dependencies 节点，专门用来记录您使用npm install 命令安装了哪些包。\n\n**注意：**npm install 命令运行完毕之后，会自动把包的信息，添加到package.json 的 dependencies 节点中。\n\n####  **devDependencies 节点：**\n\n某些包只在项目开发阶段会用到，在项目上线之后不会用到，则建议把这些包记录到devDependencies 节点\n\n#### **包的分类：**\n\n项目包与全局包\n\n######        **项目包**\n\n1. 那些被安装到项目的node_modules 目录中的包，都是项目包。\n    项目包又分为两类，分别是：\n2. ⚫ 开发依赖包（被记录到devDependencies 节点中的包，只在开发期间会用到）\n3. ⚫ 核心依赖包（被记录到dependencies 节点中的包，在开发期间和项目上线之后都会用到\n\n######     **全局包**\n\n​       npm i 包名 -g 全局包\n\n###### **注意：**\n\n① 只有工具性质的包，才有全局安装的必要性。因为它们提供了好用的终端命令。\n\n② 判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可。\n\n###### **规范的包结构：**\n\n① 包必须以单独的目录而存在\n\n② 包的顶级目录下要必须包含package.json 这个包管理配置文件\n\n③ package.json 中必须包含 name，version，main这三个属性，分别代表包的名字、版本号、包的入口。\n\n","tags":["npm"],"categories":["Web前端"]},{"title":"Node.js的加载方法","url":"/29567/","content":"\n####    **加载其它模块，使用require()方法：**\n\n```\n//加载内置的fs模块\nconst fs = require('fs')  //必须加单引号\n//加载用户自定义模块\nconst cistom = require('./cistom.js')\n//加载第三方模块（关于第三方模块的下载和使用，会在后面的课程中进行专门的讲解）\n```\n\n**<u>注：使用require()方法加载其它模块时，会执行被加载模块中的代码</u>**\n\n###  **向外共享模块作用域中的成员：**\n\n**module对象：** <!--more-->\n\n```\n在每个 .js 自定义模块中都有一个module 对象，它表示当前这个具体的.js 模块。module 对象上存储了和当前模块有关的信息\n```\n\n **module.exports 对象：**\n\n```\n在自定义模块中，可以使用module.exports 对象，将模块内的成员共享出去，供外界使用。\n外界用 require() 方法导入自定义模块时，得到的就是module.exports 所指向的对象。\nEg：\n    module.exporst{\n    ...\n       \n    }\n```\n\n **exports对象:**\n\n```\nexports 是对 module.exports 的引用，默认情况下，exports 和 module.exports 指向同一个对象。使用exports 向 外共享成员更加方便。\n```\n\n**exports 和 module.exports 的使用误区:**\n\n```\n时刻谨记，require() 模块时，得到的永远是module.exports 指向的对象：\n```\n\n**<u>注：为了防止混乱，建议大家不要在同一个模块中同时使用exports 和 module.exports</u>**\n\n杂：\n\n```\nNode.js 遵循了 CommonJS 模块化规范，CommonJS 规定了模块的特性和各模块之间如何相互依赖。\nCommonJS 规定：\n① 每个模块内部，module 变量代表当前模块。\n② module 变量是一个对象，它的exports 属性（即 module.exports）是对外的接口。\n③ 加载某个模块，其实是加载该模块的module.exports 属性。require() 方法用于加载模块。\n```\n\n","tags":["node"],"categories":["Web前端"]},{"title":"模块化基本概念","url":"/50578/","content":"\n###    **什么是模块化？**\n\n```\n -模块化是指解决一个复杂问题时，自顶向下逐层把系统划分分成若干模块的过程。对于整个系统来说，模块是可组合、分解和更换的单元。\n```\n\n```\n-编程领域中的模块化，就是遵守固定的规则，把一个大文件拆成独立并互相依赖的多个小模块。\n```\n\n#### **把代码进行模块化拆分的好处:**\n\n```\n1. 提高了代码的复用性\n2. 提高了代码的可维护性\n3. 可以实现按需加载\n4. etc....\n```\n\n### **模块化规范：**         \n\n```\n模块化规范就是对代码进行模块化的拆分与组合时，需要遵守的那些规则\n```\n\n**模块化规范的好处：**   <!--more-->\n\n```\n大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块之间的相互调用， 利人利己\n```\n\n### **Node.js 中模块的分类：**\n\n**Node.js 中根据模块来源的不同，将模块分为了3 大类，分别是：**\n\n⚫ 内置模块（内置模块是由Node.js 官方提供的，例如fs、path、http 等）\n\n⚫ 自定义模块（用户创建的每个.js 文件，都是自定义模块）\n\n⚫ 第三方模块（由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载）\n\n###  **Node.js 中的模块作用域：**\n\n```\n在 Node.js 中，用户创建的每个.js 文件都是自定义模块。\n在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域\n```\n\n#### **模块作用域的好处：**\n\n```txt\n防止了全局变量污染的问题\n```\n\n","tags":["模块"],"categories":["Web前端"]},{"title":"path路径模块","url":"/64163/","content":"\n   **●path.join()的方法可以把多个路径片段拼接为完整的路径字符串**\n\n**Eg: const fp = path.join(__dirname, '/成绩.txt')**\n\n```\npath.join([...paths])    注：__dirname\n参数解读：\n⚫ ...paths <string> 路径片段的序列\n⚫ 返回值: <string>\n```\n\n​     **●path.basename()的方法，可以从一个文件路径中，获取到文件的名称部分**\n\n```\nEg:\nconst fpath = '/a/b/c/index.html'\nvar fullName = path.basename(fpath)-->index.html\nvar fullName = path.basename(fpath,'.html')-->index\n```\n\n**●使用 path.extname() 方法，可以获取路径中的扩展名部分**  <!--more-->\n\n```\nEg:\nconst fpath = '/a/b/c/index.html'\nconst fext = path.extname(fpath)-->.html\n```\n\n\n\n```\npath.extname(path)\n参数解读：\n⚫ path <string>必选参数，表示一个路径的字符串\n⚫ 返回: <string> 返回得到的扩展名字符串\n```\n\n引入path路径模块\n\n```\ncosnt fpath = reuire('path')\n```\n\n   注：今后反涉及到fs模块操作指定路径的文件都要用__dirname进行路径的拼接，不要使用./或../","tags":["node"],"categories":["Web前端"]},{"title":"fs文件动态路径拼接问题(了解)","url":"/38801/","content":"\n在使用 fs 模块操作文件时，如果提供的操作路径是以./ 或 ../ 开头的相对路径时，很容易出现路径动态拼接错误的问题。\n\n**原因：**代码在运行的时候，会以执行node 命令时所处的目录，动态拼接出被操作文件的完整路径。\n\n<!--more-->\n\n**解决方案：**在使用fs 模块操作文件时，直接提供绝对路径，不要提供./ 或 ../ 开头的相对路径，从而防止路径动态拼接的问题。\n\n","tags":["node"],"categories":["Web前端"]},{"title":"fs文件系统模块","url":"/46962/","content":"\n#### **什么是fs文件系统模块？**\n\n<u>**fs模块是Node.js官方提供的、用来操作文件的模块**</u>\n\n​     **●fs.readFile()方法,用来读取指定文件中的内容**\n\n<!--more-->\n\n```\nfs.readFile(path[,options],callback)\n参数解读：\n⚫参数1：必选参数，指定文件路径的字符串，\n⚫参数2：可选参数，什么编码格式读取文件\n⚫参数3：必选参数，文件读取完成后，通过回调函数拿到读取结果\n注：箭头函数中(err,data)=>{}  err---失败之后的错误对象 data---读取之后的文本\n```\n\n​     **●fs.writeFile()方法,用来向指定的文件中写入内容**\n\n```\nfs.writeFile(file,data[,options],callback)\n参数解读：\n⚫ 参数1：必选参数，需要指定一个文件路径的字符串，表示要文件的存放路径。\n⚫ 参数2：必选参数，表示要写入的内容。\n⚫ 参数3：可选参数，表示以什么格式写入文件内容，默认值是utf8。\n⚫ 参数4：必选参数，文件写入完成后的回调函数。\n```\n\n   **导入js模块：**\n\n```\nconst fs = require('fs')  \n```\n\n注：const 是常量\n\n  **● fs.readdir()方法，可以读取指定目录下所有文件的名称**\n\n```\nfs.readdir(path[,options],callback)\n参数解读：\n⚫ 参数1：必选参数，表示要读取哪个目录下的文件名称列表。\n⚫ 参数2：可选参数，以什么格式读取目录下的文件名称，默认值是utf8。\n⚫ 参数3：必选参数，读取完成以后的回调函数。\n```\n\n","tags":["node"],"categories":["Web前端"]},{"title":"初始Node","url":"/44318/","content":"\n####  **什么是Node.js**\n\n    Node.js是一个基于chrome v8引擎的JavaScript运行环境\n\n注：1浏览器是JavaScript的前端运行环境\n\n​       2.Node.js是JavaScript的后端运行环境\n\n        3.Node.js中无法调用DOM和BOM等浏览器内置API\n\n#### **Node.js怎么学：**\n\n   **浏览器中JavaScript学习路径：** <!--more-->\n\n```\nJavaScript基础语法+浏览器内置API（DOM+BOM）+第三方库(JQuery、art-temloate等)\n```\n\n​    **Node.js的学习路径：**\n\n    JavaScript基础语法+Node.js内置API模块（fs、path、http等）+第三方API模块（express、mysql等）\n\n\n\n####  **在Node.js环境中执行JavaScript代码方式：**\n\n1.REPL中，输入JavaScript代码并执行（了解）\n\n<u>注：命令行不能在REPL环境中使用</u>\n\n2.通过命令行的形式，来执行指定JavaScript文件的代码\n\n#### **命令快捷键：**\n\n1.使用↑键，可以快速定位到上一次执行命令\n\n2.使用tab键，能够快速补全全路径\n\n3.使用esc键，能够快速清空当前已输入的命令\n\n4.输入cls命令，可以清空终端","tags":["node"],"categories":["Web前端"]},{"title":"错误合集","url":"/23261/","content":"\n### 1.Uncaught SyntaxError: Unexpected token '{'\n\n  我在引入css文件代码的时候，没注意把js引入当css引入来写了导致报错\n\n### 2.Failed to load resource: net::ERR_SSL_PROTOCOL_ERROR\n\n请求协议问题需将https换成http【注：插件】\n\n### 3.Uncaught TypeError: Cannot read property 'imports' of undefined\n\ndate写成data     dateFormat写成dataFormat  粗心导致 <!--more-->\n\n### 4.TypeError: Cannot read property 'data' of undefined\n\n> stack: \"TypeError: Cannot read property 'cancelToken' of undefined↵    at throwIfCancellationRequested (webpack-internal:///./node_modules/axios/lib/core/dispatchRequest.js:12:14)↵    at dispatchRequest (webpack-internal:///./node_modules/axios/lib/core/dispatchRequest.js:24:3)\"\n>\n> message: \"Cannot read property 'cancelToken' of undefined\"\n\n解决：判断如果当前有token就带token，如果没有反之\n\n我判断了但是还是报错，发现在axios拦截器并没有加返回值也就是`return config`\n\n#### 5.清理npm缓存\n\n npm cache clean -f","tags":["错误"],"categories":["笔记"]},{"title":"axios使用","url":"/41790/","content":"\n         引入axio文件\n         axios是一个用于进行ajax操作的js库\n    \n            -体积小，功能独立，除了ajax以外没有其他的额外功能\n\n\n​    <!--more-->  \n\n​     **下载地址：**\n\n​    *- https://unpkg.com/axios@0.19.2/dist/axios.min.js*\n\n```js\n发送get请求\naxios({\n    method:'get',\n    url:'接口',\n    params:{\n        name:'jack',\n        age:18,\n        gender:'男'\n    }\n}).then(function (res){\n    console.log(res);\n});\n发送post请求\naxios({\n    method:'post',\n    url:'接口',\n    data:{\n        name:'rose',\n        age:19,\n        gender:'女'\n    }\n}).then(function(res){\n    console.log(res);\n});\n\n```\n\n","tags":["HTML"],"categories":["Web前端"]},{"title":"ajax上传进度处理","url":"/15640/","content":"\n       \n\n```html\n<!-- 设置文件域和上传按钮 -->\n  <input type=\"file\" id=\"ipt\">\n  <button id=\"btn\">按钮</button>\n\n  <div class=\"progress\" style=\"width:500px; margin: 10px 0;\">\n    <div class=\"progress-bar progress-bar-info progress-bar-striped active\" id=\"percent\" style=\"width:0%\">\n      0%\n    </div>\n  </div>\n  <script src=\"lib/jquery.js\"></script>\n  <script>\n    // 按钮点击\n    $('#btn').on('click', function () {\n      // 获取文件内容\n      var files = $('#ipt')[0].files;\n      var fd = new FormData();\n      fd.append('file', files[0]);\n      // 设置原生ajax请求，进行上传进度设置（如果使用jQuery，直接取网上找插件即可）\n      // 1 基本的ajax步骤\n      var xhr = new XMLHttpRequest();\n      xhr.open('post', 'http://www.liulongbin.top:3006/api/upload/avatar');\n      // 2 上传进度检测\n      //  - 上传中，onprogress事件会自动触发多次（具体次数不固定，取决于网速和文件大小）\n      //    - 我自己测试的次数：  60k左右的图片，触发3次，   30M左右的视频，触发几十次\n      xhr.upload.onprogress = function (e) {\n        // - e.lengthComputable 表示是否具有可计算的文件大小\n        //   - 布尔值，true表示文件可以使用\n        if (e.lengthComputable) {\n          // - e.total 上传文件的总大小\n          // - e.loaded 已上传大小\n          //   - toFixed() 保留指定位小数\n          var bili = (e.loaded / e.total * 100).toFixed(2) + '%';\n          // 根据上传进度，设置具体功能\n          //  - 设置进度条宽度和内容为比例\n          $('#percent').css('width', bili).text(bili);\n        }\n      };\n      // 3 上传完毕，修改显示效果\n      // upload.onload 事件会在上传操作完毕后触发\n      xhr.upload.onload = function () {\n        $('#percent').removeClass().addClass('progress-bar progress-bar-success');\n      };\n      xhr.send(fd);\n    });\n  </script>\n```\n\n","tags":["ajax"],"categories":["Web前端"]},{"title":"非同源与http辅助演示","url":"/31874/","content":"\n  非同源地址进行跨域请求演示：\n\n```js\n var xhr = new XMLHttpRequest();\nxhr.open('get', '接口');\n    xhr.send();\n\n```\n### **http辅助演示文件：**\n\n#### **http的get请求的请求报文组成演示：**\n\n​      **第一行为请求行**\n\n GET /api/getbooksid=1&bookname=%E8%A5%BF%E6%B8%B8%E8%AE%B0 HTTP/1.1         <!--more-->\n\n**后面的部分为请求头**\n\n- 请求头是本次请求的相关信息\n\n- 这些信息大部分都是浏览器自动设置的\n\n   我们自己设置过一些： Content-Type\n\n-  Host: 接口\n\n   Connection: keep-alive\n\n   Accept: */*\n\n   User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko)\n\n   Chrome/79.0.3945.79Safari/537.36\n\n   Origin: null\n\n   Accept-Encoding: gzip, deflate\n\n   Accept-Language: zh-CN,zh;q=0.9,en;q=0.8\n\n   If-None-Match: W/\"91-hlrWKV2QmzU6DUa8qes2AyEeCbs\"\n\n  **<u>注：请求体是用来保存请求发送的数据使用的，get请求的请求参数都在url中发送，请求体为空</u>** \n\n#### **http的post请求的请求报文组成演示：**\n\n   **----请求行----**\n\n POST /api/addbook HTTP/1.1\n\n**----请求头----**\n\n Host: 接口\n\n Connection: keep-alive\n\n Content-Length: 112\n\n Accept: */*\n\n User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.79\n\n Safari/537.36\n\n Content-Type: application/x-www-form-urlencoded; charset=UTF-8\n\n Origin: null\n\n Accept-Encoding: gzip, deflate\n\n Accept-Language: zh-CN,zh;q=0.9,en;q=0.8\n\n <u>**注：*post的请求参数是在请求体中发送的***</u>\n\n<u>**之前在请求头中设置的Content-Type是用来指定请求体的内容类型的**</u>\n\n### **响应报文演示：**\n\n**----状态行-----**\n\nHTTP/1.1 200 OK\n\n**----响应头信息----**\n\n   响应头保存的是响应的相关信息\n\n X-Powered-By: Express\n\n Access-Control-Allow-Origin: \n\n Date: Mon, 24 Feb 2020 08:59:57 GMT\n\n**---响应报文中的Content-Type指的是响应的数据的内容类型---**\n\n Content-Type: application/json; charset=utf-8\n\n Content-Length: 145\n\n ETag: W/\"91-hlrWKV2QmzU6DUa8qes2AyEeCbs\"\n\n**<u>注：响应体指的是服务器响应给客户端的数据，其实就是我们一直使用的res</u>**","tags":["http"],"categories":["Web前端"]},{"title":"JSONP","url":"/49548/","content":"\n### **JSONP的跨域方式：**\n\n  同源策略限制了对非同源地址发送ajax请求\n\n  JSONP与ajax无关，而是借助script标签对非同源地址进行请求\n\n{% spoiler  步骤: %}\n1.设置script标签\n2.将接口地址设置在script标签的src属性中script接收的所有文字内容都会被自动当作js代码执行服务器中会响应某个名称的函数调用形式\n3.在src的接口地址后，以get请求参数形式，手动设置callback的参数callback的值为本次设置的处理函数名称\n4.在script之前，设置对应名称的处理函数并且设置形参，接收服务器真正响应的数据\n5.根据需求使用响应的数据即可\n{% endspoiler %}  <!--more-->\n\n****\n\n```js\n<script>\n    function success(res) {\n      console.log(res);    注：不能写在后面\n      console.log(res.data);\n    }\n  </script>\n  <script src=\"接口/?callback=success&name=jack&age=18\"></script>\n```\n\n### **JQuery发送jsonp请求方式：**\n\n   **<u>注：JSONP和ajax没有任何关联</u>**\n\nJQuery为了方便操作，将jsonp的设置方式直接放在$.ajax()中\n\n```js\n$.ajax({\n    type:'get',\n    url:'接口',\n    data:{\n        name:'jack',\n        age:18\n    },\n     // 设置dataType: 'jsonp'表示本次请求采用jsonp方式发送\n      // 通过调试工具看到，本次请求的type为script，确定是jsonp请求\n      // 页面中没有用于发送jsonp的script，是因为jQuery在使用完毕后进行了删除操作\n    dataType:'jsonp',\n    success:function(res){\n        console.log(res);\n    }\n});\n     \n```\n\n\n","tags":["json"],"categories":["Web前端"]},{"title":"封装函数ajax添加beforeSend和complete","url":"/52770/","content":"\n​      封装一个函数模拟$.ajax()的使用形式\n\n| --参数：配置对象形式 |\n| -------------------- |\n| --option             |\n\n| -type    | -url     | -data    | -success                 | -beforeSend          | -copmplete                             |\n| -------- | -------- | -------- | ------------------------ | -------------------- | -------------------------------------- |\n| 请求方式 | 请求地址 | 请求参数 | 请求成功时触发的回调函数 | 发送请求前触发的回调 | 响应完毕（不区分成功失败）时触发的回调 |\n\n​      <!--more-->\n\n```js\nfunction ajax(option) {\n    请求触发前操作\n    option.beforeSend();\n    请求发送功能\n    var xhr = new XMLHttpRequest();\n    var type = option.type.toLowerCase();\n    var data = urlencoded(option.data);\n     if (type === 'grt'){\n         \n     xhr.open('get', option.url + '?' + data);\n        xhr.send();\n      } else if (type === 'post') {\n        xhr.open('post', option.url);\n        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n        xhr.send(data);\n      }\n\n      // --- 响应处理功能\n      // 1 设置事件\n      xhr.onreadystatechange = function () {\n        // 2 检测响应下载完毕\n        if (xhr.readyState === 4) {\n          // 3 进行成功检测\n          if (xhr.status === 200) {\n            // 将JSON格式的数据转换为对象\n            var res = JSON.parse(xhr.responseText);\n            // 4 操作响应的数据，进行成功时的处理\n            option.success(res);\n          }\n          // --- 此位置确定响应下载完毕，而且不区分成功或失败，执行complete即可\n          option.complete();\n\n        }\n      };\n    }\n\n\n    // 功能测试：\n    /* ajax({\n      type: 'get',\n      url: 'http://www.liulongbin.top:3006/api/getbooks',\n      data: {\n        id: 1,\n        bookname: '西游记'\n      },\n      success: function (res) {\n        console.log('成功时接收的响应信息', res);\n      },\n      beforeSend: function () {\n        console.log('请求开始发送啦');\n      },\n\n      complete: function () {\n        console.log('请求处理完毕啦');\n      }\n    });\n */\n    ajax({\n      type: 'post',\n      url: 'http://www.liulongbin.top:3006/api/addbook',\n      data: {\n        bookname: '张三自传',\n        author: '张三',\n        publisher: '张三出版社'\n      },\n      success: function (res) {\n        console.log(res);\n      },\n      beforeSend: function () {\n        console.log('请求开始发送啦');\n      },\n\n      complete: function () {\n        console.log('请求处理完毕啦');\n      }\n    });\n\n\n    // 之前准备的用于将对象转换为urlencoded的函数\n    function urlencoded(obj) {\n      // 1 遍历对象\n      var arr = [];\n      for (var key in obj) {\n        // 2 将当前属性拼接为 '名=值' 的格式\n        arr.push(key + '=' + obj[key]);\n      }\n\n      // 3 使用数组方法join()用&连接每个元素即可\n      return arr.join('&');\n    }\n\n\n} \n```\n\n","tags":["ajax"],"categories":["Web前端"]},{"title":"Git出现的错误","url":"/44244/","content":"\n###  **可能出现的错误：**\n\n###  ①git push 出现Everything up-to-date 解决方法\n\n   1.可能你没有git.add 和git commit\n\n         - git add .\n         - git commit -m 'message'\n         - git push origin master\n\n<!--more-->\n\n### 2.无法推送远程仓库\n\n> ​      error:src refspec master does not match any    |||   error:failed to push some refs to '仓库地址'\n\n​        暂存区没有文件\n\n​       解决：\n\n```bash\ngit add .\ngit commit -m \"xxxx\"  // xxx随意\n```\n\n### 3.显示没有权限\n\n​      可以添加公钥：\n\n1. ssh-keygen -t rsa -C 'youremail'\n\n2. 然后一路Enter（回车）\n\n3. 系统盘--->用户--->你的文件--->.ssh文件夹里 --->id_rsa.pub(这是公共秘钥)\n\n  <u>**注：切记！！！切记！！！切记！！！里面的id_rsa是私人秘钥不能给其它人看**</u>\n\n   4. 打开github--->点击你的头像settings--->然后在点击SSH and GPG keys--->点击Add deploy key新建一个ssh--->Title随便写--->Key里把id_rsa.pub里面的信息复制进去【注：是公共秘钥不要复制错误】\n\n    在git bash中输入**ssh -T git@github.com**  显示你的用户名就成功了\n\n### 4.推送远程仓库出现的问题\n\nhint: Updates were rejected because the remote contains work that you do\nhint: not have locally. This is usually caused by another repository pushing\nhint: to the same ref. You may want to first integrate the remote changes\nhint: (e.g., 'git pull ...') before pushing again.\nhint: See the 'Note about fast-forwards' in 'git push --help' for details.\n\n**问题原因：**\n\n其他地方向同一远端库推送了代码，导致本地不是最新的\n\n**解决方案：**\n\n先从远端pull一下，执行：git pull\n\n### 5.git推送更新出现错误\n\n>  ! [rejected]        master -> master (fetch first)\n> error: failed to push some refs to 'https://github.com/xxx/xxx.git'\n> hint: Updates were rejected because the remote contains work that you do\n> hint: not have locally. This is usually caused by another repository pushing\n> hint: to the same ref. You may want to first integrate the remote changes\n> hint: (e.g., 'git pull ...') before pushing again.\n> hint: See the 'Note about fast-forwards' in 'git push --help' for details.\n\n解决办法：\n\n​    如果本地代码无误后进行推送进行强制推送：\n\n​          <font color=#1c896e>git push -f origin master</font> \n\n对了不要直接执行上面的命令，别忘了初始化以及add和commotion -m (～￣▽￣)～\n\n待更新中...\n","tags":["git"],"categories":["Web前端"]},{"title":"Git","url":"/25246/","content":"\n###                **如何使用Git：**\n\n​          第一步： 连接远程仓库：git remote add [name] [URL仓库地址]\n\n​           第二步： git init 初始化 【注：隐藏.git 不要动】  \n\n​          <!--more-->\n\n​           第三步： git add .将当前目录下所有文件添加\n\n​            第四步： git commit -m '描述信息'  【注：初次使用会git会进行身份验证】 \n\n> ​          git config --global user.email '邮箱'\n\n\n\n> ​        git config --global user.name '名字'\n\n          不要问然后呢？没然后了...没有 之后就是git add .  git commit -m ......无限循环直到循环到小盒子里||o(*°▽°*)o|Ю [有人吗?] \n\n### **git版本查看和版本穿梭：**\n\ngit log --oneline——查看版本\n\ngit reset  --hard 版本号 ——进行版本穿梭\n\n~~有的时候手会滑，把git给关闭了，正好穿梭在旧版本中，~~  想看更新的版本号，使用git reflog  注：前面的话不重要，重要的是git reflog。\n\n### **分支：**\n\n**<u>默认只有主分支 master</u>**\n\n​      一般来讲主分支需要保存的是没问题的，用于上线使用的代码\n\n       开发阶段的代码新建其它分支进行，不要在主分支上操作\n\ngit branch 查看分支\n\ngit branch 【名字】  创建分支\n\ngit checkout 【名字】 切换分支\n\ngit checkout -b 【名字】 创建并切换\n\ngit push origin xxx:xxx  本地分支xxx作为远程xxx分支\n\ngit checkout -d 【名字】 删除分支    【注：不要把-b 和-d 搞混....   切记！！！切记！！！切记！！！】    \n\ngit clone -b <指定分支名> <远程仓库地址>   克隆分支代码\n\n**<u>【杂：这这是删除本地的分支】</u>**\n\n> **如果要查看远程分支则git branch -a即可**\n>\n> **git push 库名 --delete  分支名**\n\ngit merge 【名字】 合并分支\n\n​    注：合并，是将指定分支合并到当前所处的分支下\n\n             Eg：当前在master，执行git merge dev，表示将dev合并到master中   \n\n~~应该是这样吧或许~~\n\n### **合并冲突：**\n\n**出现的原因：**多个分支修改同一个文件的同一块内容，然后进行了合并\n\n  根据需要进行删除工作\n\n### **推送到远程仓库：**\n\ngit push \n\n**将代码拉取更新到本地（本地有项目代码时使用）：**\n\ngit pull\n\n也可以用可视化工具（看个人情况）\n\ngithub desktop 软件\n\nvscode插件   Gitlens\n\n### **如何克隆远程仓库：**\n\n1. git clone http://仓库地址\n\n2. git push 推送（注:第一次推送会输入密码和账号）\n\n3. 如果出现Everything up-to-date 则看 ①解决办法\n\n4. git add.\n\n5. git commit -m 'message'\n\n6. git push origin master\n\n   ### **如何连接远程仓库：**\n\n   1. git remote add   [name] [URL仓库地址]\n\n   \n\n   ### **如何删除远程仓库链接**\n\n   git remote rm origin\n\n   ### **如何创建子模块：**\n\n   **添加：**git submodule add 仓库地址 路径\n\n   **删除：**要在“.gitmodules”文件中删除相应配置信息。然后，执行“git rm –cached ”命令将子模块所在的文件从git中删除\n\n   **更新？：**git submodule update\n\n   ### 如何学习Git：\n\n   推荐个网址：<a href=https://backlog.com/git-tutorial/cn/>猴子都能懂得GIT入门</a>\n\n   待更新中...\n\n","tags":["git"],"categories":["Web前端"]},{"title":"xhr与FormData对象的使用","url":"/63109/","content":"\n##   **xhr的timeout和ontimeout和onload：** \n\n**timeout和ontimeout：**\n\n注①：-send()方法用于发送http请求，如果是异步请求（默认）则此方法会在请求后立即返回；如果是同步请求，则此方法直到响应到达后才会返回\n\n -语法：XMLHttpRequest.send()              【xhr.send()】\n\n <!--more-->\n\n```js\n 发送一个get请求\n var xhr =new XMLHttpRequest();\n   xhr.open('get','接口')；\n   设置请求超时时间（毫秒单位）\n       -如果超过指定时间，请求会被取消，后续的操作不执行\nxhr.timeout = 30000;\nxhr.ontimeout = function () {\n    alert('超时了')\n};\n\n\nxhr.send();\nxhr.onreadystatechange = function () {\n    if(xhr.readyState === 4 & xhr.status === 200) {\n        console.log(xhr.responseText);\n    }\n};\n```\n\n**onload:**\n\n```js\n发送请求\nvar xhr = new XMLHttpRequest();\n xhr.open('get','接口')；\n xhr.send();\n 响应处理：\n    - xhr中提供了onload事件，直接用于表示xhr.readyState为4的情况，用于简化响应处理操作\n    - 但是还是需要进行xhr.status的判断处理\nxhr.onload = function () {\n    if (xhr.status === 200){\n        console.log(xhr.responseText);\n    }\n};\n```\n\n## **FormData对象的使用**\n\n使用FormData模拟表单进行自定义数据上传\n\n```js\n1创建一个空的FormData对象\n  var fd = new FormData();\n\n2给fd添加数据，使用fd的append()\nfd.append('name','jack');\nfd.append('age',18);\n\n注：无法直接输出fd查看数据，需要使用get方法操作\n Eg：\n  consol.log(fd.get('name'));\n\n3通过ajax发送给对应接口\n    -注：FormData数据必须使用post请求方式发送\n\n  var xhr = new XMLHttpRequest();\n  xhr.open('post','端口');\n    -直接将FormData对象放入到send()参数中即可，也不需要设置requestHeader\n  xhr.send(fd);\n```\n\n### **使用FormData对表单数据进行处理：**\n\n**html结构：**\n\n```js\n <form id=\"myForm\">\n    用户名: <input type=\"text\" name=\"username\">\n    <br>\n    密码: <input type=\"password\" name=\"psw\">\n    <br>\n    性别: <input type=\"password\" name=\"gender\">\n    <br>\n    学校: <input type=\"password\" name=\"school\">\n    <br>\n    <!-- 为了不产生表单提交效果，将按钮修改为普通按钮即可 -->\n    <button id=\"btn\" type=\"button\">提交</button>\n  </form>\n```\n\n**js部分：**\n\n```js\nvar myForm = document.qureySelector(\"#myForm\");\n1进行按钮操作\ndocument.getElementById('btn').onclick = function () {\n    2通过FormData对象获取表单所有数据\n      -给FormData传入参数，参数为form标签/DON对象\n    var fd = new FormData(mtForm);\n    注①\n    希望在表单元素的基础上，再格外上传一些数据，也可以使用append()\n    fd.append('girlFriend','rose');\n       -delete()删除某天数据\n       fd.delete('***')\n    \n    3通过ajax发送\n     var xhr = new XMLHttpRequest();\n      xhr.open('post', '接口');\n      xhr.send(fd);\n\n}\n```\n\n### **文件的上传1：【有form】**\n\n```html\n<form id=\"myForm\">\n    <input type=\"text\" name=\"username\">\n    <input type=\"password\" name=\"pws\">\n    <textarea name=\"txt\"></textarea>\n\n    <!-- 文件域：用于进行文件选取 -->\n    <input type=\"file\" name=\"avatar\">\n\n    <button type=\"button\" id=\"btn\">按钮</button>\n  </form>\n  <!-- 这个img用于显示上传后的线上图片 -->\n  <img src=\"\" alt=\"\" id=\"pic\">\n      \n<script>\n    // 1 按钮点击事件\n    var btn = document.getElementById('btn');\n    var myForm = document.getElementById('myForm');\n    var pic = document.getElementById('pic');\n\n\n    btn.onclick = function () {\n      // 2 使用fd管理表单数据\n      var fd = new FormData(myForm);\n\n      // 3 将表单提交给服务器（包含了要上传的文件）\n      var xhr = new XMLHttpRequest();\n      xhr.open('post', '接口');\n      xhr.send(fd);\n\n      // 响应内容中具有上传的图片文件的线上地址，可以进行访问\n      xhr.onload = function () {\n        if (xhr.status === 200) {\n          var res = JSON.parse(xhr.responseText);\n          pic.src = '接口' + res.url;\n        }\n      }\n    };\n  </script>\n\n```\n\n### **文件上传2：【无form】**\n\n```html\n<!-- 如果要上传的是一个单独的表单域，没有form结构，需要进行单独处理 -->\n  <input type=\"file\" id=\"ipt\">\n  <!-- 由于没有form，button就不存在提交的问题 -->\n  <button id=\"btn\">提交</button>\n\n  <img src=\"\" alt=\"\" id=\"pic\">\n\n  <script>\n    var btn = document.getElementById('btn');\n    var ipt = document.getElementById('ipt');\n    var pic = document.getElementById('pic');\n\n    // 1 设置点击按钮事件\n    btn.onclick = function () {\n      // 2 创建FormData对象\n      var fd = new FormData();\n      // 3 根据需求将数据添加到fd中\n      //   - 如何进行文件添加\n      //     - 1 找到文件域中选择的文件\n      //       - ipt.files[0] 代表了要上传的文件\n      //       - ipt.files.length 代表选择文件的个数，如果为0说明没选文件   \n      //     - 2 使用append将文件添加到fd中即可\n      fd.append('fileUpload', ipt.files[0]);\n\n      // 4 发送请求\n      var xhr = new XMLHttpRequest();\n      xhr.open('post', '接口');\n      xhr.send(fd);\n\n      // 5 接收响应，可以将线上图片地址进行展示\n      xhr.onload = function () {\n        if (xhr.status === 200) {\n          pic.src = '接口' + JSON.parse(xhr.responseText).url;\n        }\n      }\n    };\n```\n\n### **JQuery发送FormData的方式：**\n\n```html\n <!-- 如果要上传的是一个单独的表单域，没有form结构，需要进行单独处理 -->\n  <input type=\"file\" id=\"ipt\">\n  <!-- 操作按钮 -->\n  <button id=\"btn\">提交</button>\n  <!-- 用于展示线上的图片地址 -->\n  <img src=\"\" alt=\"\" id=\"pic\">\n\n\n  <script src=\"./lib/jquery.js\"></script>\n  <script>\n    // 1 设置按钮的点击事件\n    $('#btn').on('click', function () {\n      // 2 获取文件域的文件信息\n      var files = $('#ipt')[0].files;\n      console.log(files);\n\n      // 3 检测是否上传了文件\n      if (files.length === 0) {\n        return;\n      }\n      // 4 创建FormData对象\n      var fd = new FormData();\n      fd.append('uploads', files[0]);\n\n      // 5 通过jQuery的ajax发送这个FormData\n      $.ajax({\n        type: 'post',\n        url: '接口',\n        // 将fd直接设置给data\n        data: fd,\n        // 如果要发送FormData，必须设置以下属性\n        contentType: false, // 无需jQuery设置请求参数的内容类型\n        processData: false, // 无需jQuery进行数据处理\n        success: function (res) {\n          if (res.status === 200) {\n            $('#pic').prop('src', '接口' + res.url)\n          }\n        }\n      });\n    });\n  </script>\n```\n\n","tags":["xhr"],"categories":["Web前端"]},{"title":"JSON在js转换方法","url":"/34653/","content":"\n```js\nJSON.parse()将JSON转换为js对象\nJSON.stringify()将js对象转换为JSON\n```\n注：JSON的格式\n\n- 属性名必须使用双引号包裹\n- 字符串类型的值必须使用双引号包裹\n- JSON 中不允许使用单引号表示字符串\n- JSON 中不能写注释\n- JSON 的最外层必须是对象或数组格式\n- 不能使用 undefined 或函数作为 JSON 的值<!--more-->\n- JSON 的作用：在计算机与网络之间存储和传输数据。\n- JSON 的本质：用字符串来表示 Javascript 对象数据或数组数据","tags":["JSON"],"categories":["Web前端"]},{"title":"封装Ajax函数","url":"/51286/","content":"\n## **封装Ajax函数**\n\n### **<u>封装准备工作_封装将对象转换为urlencoded函数</u>**\n\n**方式1：**\n\n```js\n  function urlencoded(obj) {\n     1 遍历对象obj\n     var str = '';\n     for (var key in obj) {\n         2将当前属性拼接为 '名=值' 的格式\n         str += key + '=' + obj[key] + '&';\n     }\n     3将字符串最后多余的&去除\n     //str = str.slice(0,str.length - 1);\n     str = str.slice(9,-1);\n    4设置返回值即可\n return str;\n       }\n```\n**方式2：** <!--more-->\n\n```js\nfunction urlencoded(obj) {\n    1遍历对象\n    var arr = [];\n    for (var key in obj) {\n     2 将当前属性拼接为 '名=值' 的格式\n     arr.push(key + '=' + obj[key]);\n    }\n     3 使用数组方法join()用&连接每个元素即可\n    return arr.join('&');\n}\n```\n\n**多功能目标的演示：**\n\n```js\nvar result = urlencoded({\n      name: 'jack',\n      age: 18,\n      gender: '男'\n    });\n\n    console.log(result);\n```\n\n### **<u>封装Ajax函数</u>**\n\n```js\n封装一个函数模拟$.ajax()的使用形式\n     参数：配置对象形式\n       - option\n       - type 请求方式\n       - url 请求地址\n       - data 请求参数\n       - success 回调函数\n       function ajax(option) {\n           ---请求发送功能---\n               1初始化\n               var xhr = new XMLHttpRequest();\n               2 由于后续请求发送功能的get和post操作不同，根据请求方式进行分别设置\n                  - 因为请求方式名不区分大小写，可以进行统一转换\n                     - toLowerCase() 用于将字符串中的字母转换为小写\n               var type = option.type.toLowerCase();\n                  -将data统一转换为urlencoded\n               var data = urlencoded(option.data);\n           \n           if (type === 'get') {\n               2.1 设置get请求的open和send功能\n               xhr.open('get',option.url + '?' + data);\n               xhr.send();\n           } else if (type === 'post') {\n               2.2 设置post请求的open和send功能\n               xhr.open('post',option.url);\n               xhr.setRequestHeader('Content-Type','application/x-ww-form-uelencoded');\n               xhr.send(data);\n           }\n           ---响应处理功能---\n               1 设置事件\n               xhr.onreadystatechange = function () {\n                   2 检测状态\n                   if(xhr.readyState === 4 & xhr.status === 200) {\n                       3 将JSON格式的数据转换为对象\n                        varres = JSON.parse(xhr.responseText);\n                       4 操作响应的数据\n                       option.success(res)\n                   }\n               };\n       }\n```\n\n##### **准备用于将对象转换为urlencoded的函数：**\n\n```js\nfunction urlencoded(obj) {\n      1 遍历对象\n      var arr = [];\n      for (var key in obj) {\n       2 将当前属性拼接为 '名=值' 的格式\n        arr.push(key + '=' + obj[key]);\n      }\n\n      3 使用数组方法join()用&连接每个元素即可\n      return arr.join('&');\n    }\n```\n\n\n\n\n\n\n\n>  *// 代码纯属演示：*\n>\n>   *// - 用于说明jQuery的get请求本质与原生操作相同，因为就是基于原生封装的*\n>\n>   *// - 直接将get参数拼接在url后面一样可以正常发送*\n>\n>   $.get('网址+?id=1&bookname=西游记', function (*res*) {\n>\n>    console.log(res);\n>\n>   });\n\n","tags":["ajax"],"categories":["Web前端"]},{"title":"get请求与post请求的区别","url":"/34492/","content":"\n## **总结**\n\n### **get请求与post请求的区别：**\n\n**1.语义区别:**\n\n| -get             | -post            |\n| ---------------- | ---------------- |\n| 请求用于获取数据 | 请求用于发送数据 |\n\n<!--more-->\n\n**2.请求参数的发送位置有区别：**\n\n  -get请求的参数，在URL中传递\n\n  -post请求的请求参数，无法看到传递位置\n\n**3.可发送数据大小不同**\n\n   -get请求参数在URL中发送，浏览器限制了URL的长度，不同浏览器限制不同\n\n​        -可发送数据大小为2k\n\n​    -post请求，理论上没有大小限制（都是由服务器限制）\n\n​         -根据需求进行限制设置\n\n​         -根据服务器处理能力进行限制设置\n\n**4.可发送内容格式不同**\n\n​    -get只能发送文字数据\n\n     -post可以发送各种类型数据\n\n**get请求参数的形式：**\n\n格式为：接口地址？请求参数\n\n​          形式为：\n\n           请求参数：名=值&名=值&名=值......【注：某个值为中文，中文会自动进行编码处理】\n\n（network->点击某个get请求->headers->Query String Parameters->可以查看所参数）\n\n**post请求参数形式：**\n\n形式为：\n\n​    URL编码形式urlencoded，只是与get发送位置不同，数据的形式相同\n\n   （network->点击某个post请求->headers->Form Data->可以查看所有参数）\n\n### **原生的ajax发送get请求的使用：**\n\n浏览器提供XMLHttpRequest构造函数，用于创建可以发送ajax对象\n\n#### **-----请求发送功能-----**\n\n   ```js\n1创建xhr实例\nvar xhr = new XMLMLHttpRequest();\n2调用open()用于建立与服务器的链接\n    -设置请求方式和请求地址\n    -参数1：请求方式，get或者post\n    -请求地址\nxhr.open('get','地址')；\n3调用send()，用于将请求发送出去，这一句send()是异步代码\nxhr.send();\n   ```\n\n#### **-----响应处理功能-----**\n\n```js\n由于send()是异步操作，所有不能直接在send()之后直接写代码获取响应内容\n- xhr.readyState 用于表示ajax对象的操作状态\n     - 0 初始化阶段：创建了xhr实例\n     - 1 调用open：建立与服务器的连接\n     - 2 调用send：请求发送了\n     - 3 下载中\n     - 4 下载完毕：确定下载完毕，还能使用响应的数据 \n 1设置事件，监测响应的状态\n xhr.onreadystatechange = function () {\n     2检测响应下载完毕，还应当确保本次请求是成功的请求状态，这样响应才有意义\n       - xhr.status 本次请求的状态码\n         - 200 成功  404没有找到对应资源 \n         if (xhr.status === 4　&& xhr.status === 200) {\n            3 获取响应内容\n        // console.log(xhr.responseText);\n            var data = xhr.responseText;\n             \n             \n         4 将JSON格式的数据转换为js对象 \n         由于是原生写法，没有人帮我们进行数据类型处理，我们需要自己进行数据处理\n        data = JSON.parse(data);\n        console.log(data);\n         }\n };\n```\n\n### **发送带有参数的get请求：**\n\n#### **--- 请求发送功能---**\n\n```js\n    1 初始化xhr对象\n    var xhr = new XMLHttpRequest();\n    2 调用open\n       - get请求参数以?连接，拼接在url后面，形式为urlencoded\n    xhr.open('get', 'http://www.liulongbin.top:3006/api/getbooks?id=2&bookname=红楼梦');\n    3 调用send\n    xhr.send();\n```\n\n#### **---响应处理---**\n\n```js\n     1 设置事件\n    xhr.onreadystatechange = function () {\n     2 检测响应是否下载完毕/请求是否成功\n      if (xhr.readyState === 4 && xhr.status === 200) {\n     3 接收响应内容\n        var res = xhr.responseText;\n\n      4 将JSON转换为js对象\n        res = JSON.parse(res);\n        console.log(res);\n      }\n    };\n```\n\n### **发送post请求：**\n\n```js\n    1 初始化xhr对象\n    var xhr = new XMLHttpRequest();\n\n     2 调用open\n    xhr.open('POST', 'http://www.liulongbin.top:3006/api/addbook');\n\n     3 设置本次请求发送的内容类型（告诉服务器请求参数的类型）\n       - 设置内容类型为urlencoded即可\n       - setRequestHeader() 用于设置请求头的信息\n         - 请求头：是请求发送的一些额外信息，这些额外信息用于确保请求发送的数据可以正确被服务器接收使用\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n\n     4 发送请求\n       - post请求的请求参数为urlencoded形式，传入到send()中即可\n    xhr.send('bookname=老人与海&author=海明威&publisher=机械工业出版社');\n```\n\n","tags":["ajax"],"categories":["Web前端"]},{"title":"图书管理","url":"/16454/","content":"\n**html部分：**\n\n只是一段代码没注释也不是很多\n\nenter编码13  \n\n <!--more-->\n\n```html\n<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\t\t<meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n\t\t<title>Document</title>\n\t\t<link rel=\"stylesheet\" href=\"./lib/bootstrap.css\" />\n\t</head>\n\n\t<body style=\"padding: 15px;\">\n\t\t<!-- 添加图书的Panel面板 -->\n\t\t<div class=\"panel panel-primary\">\n\t\t\t<div class=\"panel-heading\">\n\t\t\t\t<h3 class=\"panel-title\">添加新图书</h3>\n\t\t\t</div>\n\t\t\t<div class=\"panel-body form-inline\">\n\t\t\t\t<!-- 顶部进行图书新增的结构部分 -->\n\t\t\t\t<div class=\"input-group\">\n\t\t\t\t\t<div class=\"input-group-addon\">书名</div>\n\t\t\t\t\t<input type=\"text\" class=\"form-control\" id=\"iptBookname\" placeholder=\"请输入书名\">\n\t\t\t\t</div>\n\n\t\t\t\t<div class=\"input-group\">\n\t\t\t\t\t<div class=\"input-group-addon\">作者</div>\n\t\t\t\t\t<input type=\"text\" class=\"form-control\" id=\"iptAuthor\" placeholder=\"请输入作者\">\n\t\t\t\t</div>\n\n\t\t\t\t<div class=\"input-group\">\n\t\t\t\t\t<div class=\"input-group-addon\">出版社</div>\n\t\t\t\t\t<input type=\"text\" class=\"form-control\" id=\"iptPublisher\" placeholder=\"请输入出版社\">\n\t\t\t\t</div>\n\t\t\t\t<!-- 点击添加新图书 -->\n\t\t\t\t<button id=\"btnAdd\" class=\"btn btn-primary\">添加</button>\n\t\t\t</div>\n\t\t</div>\n\t\t<!-- 图书的表格 -->\n\t\t<table class=\"table table-bordered table-hover\">\n\t\t\t<thead>\n\t\t\t\t<tr>\n\t\t\t\t\t<th>Id</th>\n\t\t\t\t\t<th>书名</th>\n\t\t\t\t\t<th>作者</th>\n\t\t\t\t\t<th>出版社</th>\n\t\t\t\t\t<th>操作</th>\n\t\t\t\t</tr>\n\t\t\t</thead>\n\t\t\t<tbody id=\"tb\">\n\t\t\t\t<!-- 用于放置图书信息的tbody标签 -->\n\t\t\t</tbody>\n\t\t</table>\n\t</body>\n\n```\n\n**js部分：**\n\n```js\n\n\t\t<script src=\"./lib/jquery.js\"></script>\n\t\t<script>\n\t\t\trenderBook();\n\t\t\t$('#btnAdd').on('click', function() {\n\t\t\t\tvar val1 = $('#iptBookname').val().trim();\n\t\t\t\tvar val2 = $('#iptAuthor').val().trim();\n\t\t\t\tvar val3 = $('#iptPublisher').val().trim();\n\n\t\t\t\tif (val1 === '' || val2 === '' || val3 === '') {\n\t\t\t\t\talert('请输入完整的数据');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar kids = '添加书的接口addbooks';\n\t\t\t\t$.post(kids, {\n\t\t\t\t\tbookname: val1,\n\t\t\t\t\tauthor: val2,\n\t\t\t\t\tpublisher: val3\n\t\t\t\t}, function(res) {\n\t\t\t\t\tif (res.status === 201) {\n\t\t\t\t\t\trenderBook();\n\t\t\t\t\t\t$('#bookname').val();\n\t\t\t\t\t\t$('#author').val();\n\t\t\t\t\t\t$('#publisher').val();\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t});\n\n\t\t\tfunction renderBook() {\n\t\t\t\tvar kid = '获取书的接口getbooks';\n\t\t\t\t$.get(kid, function(res) {\n\n\t\t\t\t\tif (res.status !== 200) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t};\n\t\t\t\t\tvar data = res.data;\n\t\t\t\t\tconsole.log(data)\n\t\t\t\t\tvar str = '';\n\t\t\t\t\t$.each(data, function(k, r) {\n\t\t\t\t\t\tstr +=\n\t\t\t\t\t\t\t' <tr>\\\n\t\t\t\t            <td>' + r.id + '</td>\\\n\t\t\t\t            <td>' + r.bookname +\n\t\t\t\t\t\t\t'</td>\\\n\t\t\t\t            <td>' + r.author + '</td>\\\n\t\t\t\t            <td>' + r.publisher +\n\t\t\t\t\t\t\t'</td>\\\n\t\t\t\t            <td><a href=\"javascript:;\">删除                                                           </a><td>\\\n\t\t\t\t        </tr>; '\n\t\t\t\t\t});\n\t\t\t\t\t$('#tb').html(str);\n\t\t\t\t});\n\t\t\t}\n\t\t</script>\n```\n\n","tags":["HTML"],"categories":["应用与插件"]},{"title":"Ajax（总结）","url":"/63516/","content":"\n#                             总结\n\nAjax是一种技术，这种技术通过执行一段js代码就可以实现【Asynchronous JavaScript And XML（也就是异步 JavaScript和XML）】\n\n前端、后端交互的技术也就是【发送请求】与【接受响应结果】\n\n<!--more-->\n\n![](C:\\MyBolg\\MyBolg\\source\\_posts\\post-name\\1.png)\n\n前端需要做的就是写JS代码发送请求、接受服务器返回的结果，并处理【<u>切记接口是后端的事</u>】\n\n### 关于Ajax代码有两种：\n\n**使用工具JQuery：**        【别人封装好的，按语法使用】\n\n| $.get()                                        | $.post()             |\n| ---------------------------------------------- | -------------------- |\n| 获取服务器中的资源                             | 用于向服务器发送资源 |\n| 方式：a标签的href、link/script:src/video...... | 发送post请求的方式   |\n\n| $.ajax()                                                 |\n| -------------------------------------------------------- |\n| 请求操作但不跳转功能；                                   |\n| network判断请求资源类型方式；                            |\n| type判断请求资源类型；                                   |\n| xhr代表请求ajax \\|  document:请求html页面 jpeg/img...... |\n\n**使用原生的js：**                   \n\n```js\nvar xhr = new XMLHttpRequest();\n xhr.onreadystatechange = function () {\n     //this.responseTwxt;服务器返回的结果\n }\nxhr.open();\n//post方式。注：加请求头\nxhr.send();\n```\n\n### **模版引擎：**\n\n**加载：**\n\n   引入template-web.js\n\n**设置模版**：\n\ntype = 'text/template'    id = 'xxx'\n\n**JS代码 ：**\n\n准备数据，实际多数都是服务器返回的数据\n\n调用template函数 ：参数1：模版id 参数2：需要展示的数据 返回值：拼接好一段HTML\n\n**模版语法：**          【｛｛｝｝英文的花括号】\n\n| **{{$data}}**                          | **{{$data.name}}**          | **{{$data.age}}**                                     |\n| -------------------------------------- | --------------------------- | ----------------------------------------------------- |\n| $data代表template()传入参数2，数据对象 | $data可以正常的进行属性访问 |                                                       |\n| {{name}}                               | {{age}}                     | {{@str}}                                              |\n| 如果访问￥data的属性,可以不写$data     |                             | 填充内容是结构字符串，并且进行结构生成，在内容前书写@ |\n\n重点：\n\n1.接口是后端写的，提供接口文档\n\n2.必须按照接口文档来发送请求【注：①接口规定是什么请求方式，必须用该请求方式，哪怕看着不顺眼②接口要什么请求参数，必须给对象的请求参数】\n\n### **细节：**\n\n**同步异步：**\n\n**同步：**大多数js功能都是同步任务，会按照代码书写顺序执行。\n\n**<u>注:某些任务较为耗时或执行时间不确定，如果采用同步任务，会导致后续的任务等待</u>**\n\n**异步：**异步任务总是在同步任务之后执行，不会导致其它任务进行等待。\n\n    --------常见的异步任务有：定时器 / AJAX\n\n**请求参数写法：**\n\nJQuery封装的三个方法 对象形式：{参数:值,参数:值,...}\n\n原生的JS-------参数=值&参数=值&.....\n\n**两种请求方式的区别：**\n\n意义不同\n\n传递数据大小不同\n\n参数位置不同\n\n接受到服务器返回的数据，如何渲染【模版引擎】","tags":["ajax"],"categories":["Web前端"]},{"title":"如何有效阅读一本书（六）","url":"/55745/","content":"\n读书笔记是一种升华工具，可以让读书活动完成从生搬硬套到独创思维的飞跃。\n\n固定场景中重读笔记【另一方面要养成重读笔记---量化重读漂频率】\n\n积极输出促进思想内化\n\n杂：我想了一下，好像什么都没记住，我感觉预习也很重要。不不不应该很重要。对没错，是这样。。。哦对了还有一点是切勿眼高手低  <!--more-->\n\n通过重读为思想增色\n\n1.想要简单回顾是----重读读书笔记\n\n2.想要回忆起更多时----参考书中的重点段落\n\n3.想从头开始看起时-----重读原书\n\n等待....","tags":["我的读书笔记"],"categories":["笔记"]},{"title":"js 基础（一）","url":"/18958/","content":"\n### **js的语法基础：（ECMASCRIPT）**\n\n| js的书写位置：                                    | 内嵌式写法：                               | 外联式写法：【大项目】                     |\n| ------------------------------------------------- | ------------------------------------------ | ------------------------------------------ |\n| eg：参照css的书写位置（1.行内式2.内嵌式3.外联式） | 1.最好写在body的后面外联式写法：【大项目】 | 1.新建js文件（后缀名就是.js）【直接写js 】 |\n\n```js\n通过<script src='js文件路径'></script>引用js文件\n```\n\n行内式写法：（了解）\n\n```\n1.点击事件onclick\n```\n\njs输出消息：<!--more-->\n\n●为什么学习js输出消息的方式？\n\n```\n   展示的结果给用户查看\n```\n\n在控制台中输出消息：\n\n| console．log（）                                             |\n| ------------------------------------------------------------ |\n| 注意：在程序中遇到的任何一个特殊符号，都必须是英文输入法下的符号。 |\n\n在浏览器弹出一个新窗口【alert();】\n\n### **js变量**\n\n字面意思：\n\n```js\n变量：变化的值\n```\n\n程序角度：\n\n```js\n保存数据的一个容器\n```\n\n变量的定义：\n\n```js\nvar 自定义变量名\n注意：定义变量必须写 var\n```\n\n变量的赋值：\n\n```js\n1.var 变量名 = 值;\n2.var 变量名;\n  变量名 = 值;\n注意：'='赋值运算符  将'='右侧的值赋给左侧的变量\n```\n\n备注：如果在程序中输出一个值，如果该值是一个变量，不需要加引号。\n\n备注：程序输出一个值，如果该值是一个变量，不需要加引导。如果不是则需要加。\n\n​             一个变量可以重复赋值，但是一个变量只能一个值，而且是最后一次赋值的结果。\n\n备注:  '='两边都需要加个空格\n\n### 变量名的命名规则\n\n1.变量名在合法的时候还要具有一定的语义\n\n2.不能用关键字命名【关键字不能作为变量名】-----关键字-----在js中有特殊含义\n\n3.不能数字开头命名【不能以特殊符号开头，‘_’ ,'$'除外】\n\n4.变量中不能出现空格\n\n5.不能使用汉字定义变量\n\n6.不建议直接使用‘name’作为变量名，容易和属性冲突\n\n7.不建议使用js中的**保留字**作为变量名------------在当前版本没有特殊含义，但是js其它版本或以后版本中具有关键字的作用\n\n### **练习1:**\n\n让用户输入任意的摄氏度,得到对应的华氏度.[华氏度=9/5*摄氏度+32]\n\n```js\nvar kid =  prompt('请输入摄氏度...');\nvar kids = 9/5*kid+32;\n  document.write(kids);\n```\n\n### **练习2:**\n\n交换两个变量的值\n\n```js\n水杯问题:\nvar a = 1;\nvar b = 2;\nvar c = a;\na=b;\nb=c;\ndocument.write(a,b);\n```\n\n### **练习3:**\n\n求和\n\n```js\nvar kid = 3;  //var kid = '3';\nvar kids = 2;\nvar kll = kid + kids;\nconsole.log(kll);\n```\n\n### **数据类型**\n\n**1.简单数据类型**【掌握】\n\n ●数字类型number\n\n●字符串类型string\n\n●布尔类型boolean\n\n●undefined类型\n\n**2.复杂类型【注】**\n\nobject","tags":["js"],"categories":["Web前端"]},{"title":"js高级（三）","url":"/53015/","content":"\n  this的使用：\n\n●this是特殊的标识符，代表某个对象值。取值根据函数的调用方式会发生变化\n\n●全局中直接访问this，默认window\n\n构造函数中this，默认为实例对象\n\n方法中的this，默认为调用者\n\n### **自调用函数与模块化**\n\n模块：块、部分意思。\n\n 模块化：指的是，将没进行\n\n依赖：就是使用的意思   【文件不能划分全局作用域】<!--more-->\n\n回调函数：作为函数参数使用的函数\n\nforEach():遍历到数组的每个元素\n\n注：return 不能结束\n\n注：qAll的结果为NList伪数组对象具有forEach\n\n数组其它回调函数到方法：\n\nmap（）every（）some（）reduce（）filter（）find（）findIndex（）\n\n查文档自学上述方法【寒假作业】\n\n# **mdn**\n\n局部变量（私有变量）确保数据安全性\n\n如果将变量设置为私有变量，就可以确保数据安全性，不会被外界操作修改。\n\n​      →  问题是：不仅不能修改，也无法访问\n\n作用域。。接受返回值（返回值是函数）\n\n确保数据安全性----闭包函数作用\n\n#### **函数只能返回一个返回值**\n\n递归函数：\n\n为什么   5：5？  【注：06|||||||||||||】","tags":["js"],"categories":["Web前端"]},{"title":"前言","url":"/53791/","content":"\n读书笔记是自己和书的对话，所以不需要别人的观点，但如果在做完读书笔记以后可以重读书评，就可以参考“第三方的观点”，换个角度审视自己的这次读书体验。于是你会发现，原来对自己来说有着某种意义的书，在这个人眼里是这样的。\n\n从某种意义上说，所有的艺术都带有一些自传体性质，你只能唱自己的歌画自己的画；只能做一个由自己的经验，环境和家庭所造成的你。无论好坏都的在生命的交响乐中演奏自己的小乐器。\n\n明白不代表理解，理解不代表会应用，会应用不代表做的对，对不代表省时省力，中间的每一个环节考的就是这两个东西。\n\n😸一个是练习      😸一个是不断总结\n\n  ","categories":["笔记"]},{"title":"如何有效阅读一本书（五）","url":"/37336/","content":"\n## 如何有效阅读一本书（五）\n\n### **剪报式读书笔记** \n\n| 复印粘贴以备重读                                      |\n| ----------------------------------------------------- |\n| ps：可能会用不到，因为我大部分都是在kindle里面看 ：） |\n\n### **贴什么？**\n\n 抄-------这一页，正是这本书里最具代表性的一页。\n\n①书腰\n\n②信息卡片\n\n③书签\n\n④其它\n\n> 引：“如果一个人总是把死亡的觉悟挂在嘴边，总让人感觉有些虚伪。”\n\n杂：一切都会好起来的。不要想太多。 <!--more-->\n\n### **重读书评以加深思考**\n\nps：不过有些书评简直是~~惨不忍睹~~。那也是书评，区分那些是好的那些是坏的。\n\n> 引：“实际上我们常常因为虚荣心过剩，过度表现自己而苦恼有时候连退一步只做到自爱都就觉得索然无味。”\n\n读书体验比书本身更重要，通过读重读笔记提高自我 【注：笔记---学以致用的读书体验】\n\n概念：吸收精华----原封不动地吸收书上的知识。\n\n读书体验---以此契机我想到某件事（或如何理解）\n\n杂：感觉有点心烦。","tags":["我的读书笔记"],"categories":["笔记"]},{"title":"阶段提问","url":"/29299/","content":"\n##                     **阶段提问**\n\n项目：html css js 动画    移动端   iPad【添加后面的代码】\n\n基础：每日反馈   学历：    webapi：   js高级：   动画：  矢量图标：  它们的语法格式：\n\ninnerTxet 和innerHTML的区别？  移动端的触摸事件：\n\ntranform和translate：\n\njs中注册事件：<!--more-->\n\n事件委托：\n\n冒泡的阻止发法：\n\ndom事件的三个阶段：\n\nbom？\n\n什么是视口？\n\n事件按键：\n\nflex布局：\n\n如何定义弹性盒子：\n\n栅格系统（12列）\n\n全局作用域（）；局部作用域\n\n不同事件this指向会发生改变吗?\n\n浏览器的关闭与存储：\n\n让盒子居中：\n\nrem适配： \n\n媒体查询：\n\n响应式布局：\n\njs事件三个阶段：\n\nless的用法：；变量\n\njs数组函数方法？\n\nbreak与区别？\n\njs中的形参和实参区别？\n\njs遍历方法？   【forEach】\n\nlet与var区别？\n\njs中如何操作元素属性？\n\n2d转换属性：；3d转化属性\n\n流式布局？\n\n设置获取本地存储？\n\n字符串的用法？\n\nless定义变量？\n\n控制台菜单问题？\n\n1.对于概念性问题是否深入？\n\n2.实例对象？构造函数\n\n【注：任何问题在上课先记下，不要研究，避免跟不上思路】","tags":["问题"],"categories":["Web前端"]},{"title":"防御机制（四）","url":"/12322/","content":"\n就算有一万个做错的理由也不能改变一件做错的事实否则在这个世上千千万万的可怜人是不是都有踏入歧途的正当理由\n\n事到如今，后悔有什么用，时间不会回头，过去也没办法改变，但你还有未来要面对\n\n人，总是要跨出那一步才会真的知道后续的路该怎么走下去\n\n <!--more-->\n\n### **我们的情绪地图**\n\n接纳自己的需求，忍受强烈的情感以及发展出自我价值。就意味着面对并接纳自己的各色情绪，拥有独立的自我与世界，强烈的自尊关乎着快乐与成就，相对的羞耻感，却是我们所知的一种最痛苦的感觉。我们生而为人，就要面对难以回避的诸多情绪。许多人难以承受他们的痛苦体验。承受：忍受特别是不可避免的感受。他们会赶快摆脱自己的感受（哈我想应该是酒与烟吧），分散注意力，甚至欺骗自己，怀疑他们的真实感受----诉诸各种各样的防御机制。通常致使我们穿上防御盔甲的，正是这些最痛苦的情绪。\n\n基本情感七对相对情绪：\n\n1.愤怒与冷静\n\n2.仇恨与爱\n\n3.恐惧与自信\n\n4.耻辱与无耻\n\n5.感恩与对其的缺失\n\n6.同情与愤慨\n\n7.嫉妒与效法\n\n一些最令我们感到痛苦，可能花一辈子时间都无法应对的情感，恰恰是那些我们初次感受到的情感。","tags":["心理学"],"categories":["爱好心理学"]},{"title":"防御机制（三）","url":"/24291/","content":"\n在阅读本书的过程中，随身携带一个笔记本，记录下自己的反应，并将之存放在一个安全的地方，确保除自己以外的任何人都查看不了。【注：尽你所能地对自己诚实，不批判自己，试着知、只将焦点放在事实本身，即你的实际感受，你未经大脑篡改的反应，而不是你认为自己应该采取的回应。不要逼迫自己改变什么。】\n\n练习：\n\n1.不能，并没有在意或并没有发现。人多的时候。\n\n2.有过，不是很好，的确令人不安。\n\n3.没人对我讲起过，但我无意中听到过，确实如此，确实事实。\n\n【注：每个人都在试图回避痛苦真相时用到的方式。】 <!--more-->\n\n要开始学会问自己，那些不愉快的事实是你也不愿面对的。ps：眼睛与心态吧。\n\n需要：\n\n1.将需求与依赖当作关系中必不可少的部分；\n\n2.学习管理自己强烈的情感；\n\n3.培养自尊感（而不是羞耻感或损伤自己的感受）\n\n【学会对自己养成一种如是的诚实————在评估自己的时候，即不要太严苛，也不要太随意——这是解除自己防御的必要步骤，学着尽可能客观地评价自己。】\n\n一下是问题：\n\n想把事情办好就得亲自动手 \n\n有时我太依赖他人了\n\n遇到问题时，我总是幻想着别人替我“解决”\n\n似乎我对别人的重视胜过他们对我的重视\n\n我很少生气，从不会发火；\n\n我超级会说话；\n\n我时常尝试新事物，但总是三分钟热度；\n\n我总是担心稍不留意就会有不花哦的事情发生\n\n我经常反应过度，随之又懊悔不已\n\n我希望自己没有情绪上的波动\n\n我容易对自己犯下的错误过分自责\n\n我害怕被人看低\n\n我接受不了批判并对此十分抗拒\n\n我希望自己是另一个人。\n\n<u>**【注：这里重点并不是为了把自己归类，而是为了了解你要面对的心理挑战是什么，并作为识别自身防御机制的前奏。这一点尤为重要。切记！！！】**</u>  ","tags":["心理学"],"categories":["爱好心理学"]},{"title":"JavaScript高级（二）","url":"/53908/","content":"\n### 三个对象：\n\n1.构造函数2.原型对象3.实例对象\n\n### 三者关系小结：\n\n1.构造函数：都是prototype属性，就是原型对象\n\n2.实例对象：都是有_ _ proto _ _属性，也是原型对象\n\n3.原型对象：具有constructor属性，也就是构造函数\n\n**注：两个对象同名不覆盖、不冲突**\n\n### 对象访问规则：\n\n对象进行属性访问，先查找自身，如果没有再找__opsiodfoa__,并一直重复此过程<!--more-->\n\n查找ob.pro中如果还没有结果为undefined\n\n这种由多个-型组成的结构，称为原型链\n\n原型链的终点为Object.prototype\n\n简单的说：就是 沿原型链查找【】\n\n### **构造函数的继承操作：**\n\n**创建子类、同时继承父类**\n\n  ●使用构造函数进行集成时，属性和原型方法需要分别处理\n\n**继承父类属性：**\n\n   xx.call（this）的部分是固定形式，后面的参数按需修改\n\n还可以进行新的属性设置，而且新的属性设置和继承操作没有顺序要求\n\n**2.继承父类原型的方法**\n\n   由于原型继承操作是通过覆盖方式实现的，导致xxx.prototype自身不具有constructor\n\n为了避免问题，自己添加个constructor；属性即可\n\n设置原型方法时，必须在继承操作之后设置，否则也会被覆盖，相对于没写\n\n### **多态设置：**\n\n构造函数进行多态设置，只能进行覆盖设置，无法像class一样对父类功能进行扩展 \n\n........\n\n### 观察class与构造函数的关系：\n\nclass操作的结果还是通过原型prototype进行处理的\n\n只不过语法更简单\n\n### 给内置对象添加功能的方式\n\n内置方法的使用方式：\n\n内置对象和我们之前的自定义对象设置方式相同，都是将方法设置在原型中\n\n如果希望给内置对象设置新方法，设置在原型中即可\n\n书写方式arr.xxx() 注：可读性更强\n\n### **函数进阶内容：**  【this可以复用】\n\n1.函数的属性和方法（属性了解，使用方法重点）\n\n2.函数的其它使用方式\n\n ●自调用函数（立即执行函数）\n\n●回调函数\n\n●闭包函数\n\n●递归函数\n\n2.函数方法   \n\n1.call（）【用于调用函数，并设置本次掉用中的this】\n\n   ●参数1：要设置的this值，对象结构\n\n   ●后续参数：表示传入的实参，个数不限  \n\n书写方式：xx.类名.（｛｝，x，x，x）\n\n2.apply（）\n\napply用于调用函数，可以设置函数中的this\n\n  ●参数1：用来设置函数中的this\n\n●参数2：数组，用来保存实参\n\n书写方式：xx.apply({},[]);\n\n3.bind（） \n\nbind含义为绑定。\n\ncall和apply可以设置this，但都是临时设置，只有本次调用有效\n\n如果 希望this长期被设置为某个对象，可以通过bind方法进行操作\n\n●参数1：需要绑定的this、值，对象\n\n●后续参数：需要绑定的实参值\n\n●返回值：绑定了this或实参的函数副本\n\n```js\nfunction fun（a,b,c){\nconsloe.log(this);\nconsloe.log(a,b,c);\n}\n//调用bind后，需要对返回的函数副本进行操作\nvar f1 = fun.bind({name:'啥啥啥'});\nf1（）；\nf1.call({})\n//绑定的实参如果与形参个数不同，进行调用时的传入方式也不一样\n```\n\n绑定this和实参用返回值（\n\n后续参数：需要绑定实参值\n\n返回值：绑定了this或实参的函数副本\n\n数组借用Math方法\n\n------\n\ncall 和apply区别：\n\ncall--传入实参是单个传入方式\n\napply--传入实参采用数组整体传入方式\n\n### **函数的声明方式：**\n\n1.函数声明语句\n\n2.函数表达式\n\n**两种声明方式的区别：**\n\n1.参与预解析时规则不同\n\n2.函数声明语句对使用位置有一些要求（特殊环境不推荐使用）\n\n   - 不推荐在if语句中进行函数声明语句的设置（不同浏览器对这个操作的域解析结果不同）\n\n     ### **自调用函数**   \n\n自调用函数、立即执行函数\n\n效果：在当前位置执行一次后结束\n\n作用：\n\n ●将大功能分成小部分，每部分代码包裹一个自调用函数，可以形成独立的作用域\n\n●可以避免多个功能的代码出现冲突（变量命名重复导致修改的问题）【多人开发时名称冲突的问题】\n\n**<u>书写注意点：每个自调用函数后的分号，必须加，否则，多个自调用函数连起来书写会报错</u>**\n\n```\nEg：;(function(){\n\n})();\n```\n\n","tags":["js"],"categories":["Web前端"]},{"title":"防御机制（二）","url":"/21146/","content":"\n​           当我们拒绝接纳自身大部分的情感经历时，我们会消耗自己，同时消弱自己面对这个世界的力量与能力。当你封闭了对自己需求的觉知，你就不肯能与TA人发展出真正的亲密关系。\n\n注：abwehr指译为“避开”或“抵挡”要比“防御”更准确。就其本质而言，一切防御机制都是我们逃避痛苦而向自己撒的谎。\n\n防御机制只顾眼下一刻，而不计后果，是一个人思虑不周的反射性行为，只是为了规避当下一刻的痛苦，却不考虑由此带来的长期损失。注：人类是受习惯约束的动物，这样一来，改变便显得尤其困难。一般来说我们极容易养成自己特有的或习惯性的防御模式，而这些规避痛苦的惯用方法则会对我们性格的塑造产生影响。一个人的个性或者’全部的性格特征都可以称为浓缩版的防御机制‘【人的应为举止，说话走路方式等】 <!--more-->\n\n当某一种人格障碍被大众所熟悉时，却也定义了一个人的性格，框定了他/她的人际关系。\n\n根据自身采取的防御机制，将会塑造我们的个性。也会影响人际关系。","tags":["心理学"],"categories":["爱好心理学"]},{"title":"JavaScript高级（一）","url":"/17134/","content":"\n注：浏览器展示的小问题：\n\n复杂类型在控制台输出是，进行展看操作后，会读取的最新值\n\n**浏览器重要组成部分：**\n\n内核（渲染引擎）： html /css---webAPI(DOM/BOM)\n\nW3C规范\n\njs解析器（Javascript引擎）： ECMScript   <!--more-->\n\nECMA规范\n\n执行过程：\n\n域解析：全局、函数 \n\n**基本类型：**\n\n字符串类型\n\n数值类型\n\n布尔类型\n\n未定义类型--------undefined默认的，用来表示存储区域未使用\n\n空类型 null---------主动设置，清除存储区域\n\n复杂类型：\n\n objrct对象\n\narray数组\n\ndate日期\n\nfunctiion函数---------代码重复使用【存储代码】\n\n循环----某个地方执行\n\nmath数学\n\n**基本和复杂区别：**\n\n存储个数不同\n\n**内存存储方式不同**\n\n​          ●基本---内存单元中存储是**具体值**\n\n​\t\t   ●复杂---内存单元中存储的**地址**\n\n**复制方式不同：**\n\n​          ●基本------赋值=方式复制\n\n​          ●复杂-------遍历拷贝（内置对象方法）\n\n**复杂类型进行比较：（== /===）**\n\n都是地址比较\n\n注：两个复杂类型长得一样不一定相等/全等\n\n包装对象：string  number  boolean   \n\n**狭义（单个）：**\n\n【任意对象都可以】\n\n构造函数（需要复用）：\n\n对象字面量：\n\n数据存储\n\n### 面向对象与面向过程\n\n面向对象【分装功能使用方法调用】\n\n注：面向对象和面向过程没有可比性\n\n**封装性:**\n\n  ●将面向过程的代码根据大功能划分后，封装多个函数，再将多个函数封装到对象中即可。\n\n   ●**将功能封装为对象。**\n\n**继承性：**\n\n ●**继承操作，进行功能复用**\n\n**多态性：**\n\n某个功能被不同对象使用是的功能性不同，称多态【增强功能的灵活】\n\n**面向对象操作：**\n\n**class（重点） ---------es6**       【】\n\n**首字母大写**\n\n```\nclass 类名 ｛\n\nconstructor（需要参数）｛\n\nthis.属性名 = 属性值；\n\n｝\n\n方法名（）｛\n\n｝\n\n｝\n\nvar 实名类 =  new  类（）\n\n\n\n```\n\n注：如果设置的子类方法与父类方法同名，会\n\n```htnl\nclass  子类 extends  person｛\nconstructor（）｛\n\n  super（）\n  this.\n\n｝\n方法（）；\n\n\n｝\nvar 变量 = new 。。。（）；\n```\n\n### class继承\n\n```mjs\nclass Person {\n  constructor() {\n    this. = ;\n    this. = ;\n  }\n  名字() {\n    console.log('' + this.)；\n  }\n}\nclass xxx extends Person{\n  constructor( xxx) {\n    super(xxx);\n    this.xxx = xxx;\n    this.xxx = xxx;\n  }\n  覆盖方法：\n  \n  super.名字（）；【1.多态方法做扩展2.调】\n```\n\n **构造函数**：-------函数名大写\n\n多个实例对象设置的方法值不是同一个函数，将匿名函数设置为命名函数\n\n统一对象的存储方式，可以减少在全局作用域名称数量\n\n原型：\n\nprototype原型对象----------**函数优化**\n\n constructor除了可以检测自定义实例对象的类型检测，也可以内置对象进行类型检测。【作用：类型确定功能】\n\ntypeof检测复杂类型只能得到object。。。。。。。。使用。。。。。。即可\n\n\n\n零落满玉尘，霜打清浮册，墨染成瀑，清飞寒酥雪。忽沥薄阳起白风，展书一卷，读不尽满目苍凉\n\n","tags":["js"],"categories":["Web前端"]},{"title":"前言","url":"/53790/","content":"\n​          **巴纳姆效应，巴纳姆效应是1948年由心理学家伯特伦·富勒通过试验证明的一种心理学现象，以杂技师巴纳姆的名字命名，认为每个人都会很容易相信一个笼统的、一般性的人格描述特别适合他。即使这种描述十分空洞，仍然认为反映了自己的人格面貌，哪怕自己根本不是这种人。**\n\n","tags":["心理学"],"categories":["爱好心理学"]},{"title":"防御机制（一）","url":"/49888/","content":"\n## **一切防御机制都是我们为逃避痛苦而向自己撒的谎**\n\n**<u>注：阅读前请花几分钟阅读一下前言</u>**\n\n我们的内外一致性越高，对自我判断也就会越准确，越能抵消落差感，心理也就越成熟、越健康，提升自尊，增强自己面对这个世界的能力。真正的成长发生在一言一行之间，通常要在很长一段时间后才有质的飞跃，虽然在感受到威胁时勇往直前很重要，但也不要太过逼迫自己，或过高要求自己。再微小的自我觉知，再小的进步，都有其价值所在。\n\n <!--more-->\n\n### 缺少自知之明：那个不认识的自己\n\n人类通常终其一生都会认为那个拥有意识体验的TA们就是真实的自己，事实上，我们依旧对重要的情感世界所知不多。讲话人出现的口误，其实泄露的是Ta自己潜意识里的真实意愿。“忘记”：事实上并不是那个人故意疏忽不去兑现说过的承诺，忘记这一行为本身泄露了Ta自始至终就不愿去做那件事。 当我们无法看清自己，而Ta人却看得清清楚楚时，这对多数人而言时一件非常不越快的体验。如果被朋友说中了，我们会坚持称自己的口误（有时候一时的口误也当真别无他意）为语言故障，没有任何意义。 疏忽和出错往往揭露了一些事实，也就就是我们未能意识到，甚至对自己都不愿坦诚的真相。\n\n心理防御机制都是一些无形的应对方式，通过它们，我们得以将那些无法接受的想法与感受排除在外。但它会以微妙的方式扭曲我们对现实的看法，这也包括人际关系和内心的情感领域","tags":["心理学"],"categories":["爱好心理学"]},{"title":"循环结构","url":"/5284/","content":"\n**for-in循环**----------知道循环几次用\n\n**while循环**------------构造不知道循环次数的循环结构 使用while循环\n\nwhile循环能产生或转出bool值来表达控制循环，即True循环继续False循环结束。\n\nrange（）【函数】\n\n","tags":["python"],"categories":["语言与Linux"]},{"title":"分支结构","url":"/10760/","content":"\n#   分支结构\n\n**if语句的使用【构造分支结构的关键字】**\n\n**①if** **②elif** **③else**\n\n注：和c/c++、Java等语言不同，Python中没有花括号构造代码而是使用了缩进的方式来设置的层次结构【连续的代码如果保持了相同的缩进那么它们属于同\n\n一个代码块，相当于是一个执行的整体】。\n\n构造跟多的分支则：【if...elif...else】结构。\n\n**练习1：英制单位英寸与公制单位厘米互换。** <!--more-->\n\n```python\nkid = float（input（'请输入长度：'））\n\nkids = input（‘请输入单位：’）\n\nif kids ==‘in’ or kid ==‘英寸’：\n\nprint（’%f英寸 =%f厘米‘ % （kid，kid*2.54））\n\nelse kids ==‘cm’ or kids ==‘厘米’：\n\nprint（‘%f厘米=%f英寸’%（kid，kid/2.54））\n\nelse：\n\n  print（‘请输入有效单位’）\n\n```\n\n**练习2：百分制成绩转换为等级制成绩。**\n\n> **要求**：如果输入的成绩在90分以上（含90分）输出A；80分-90分（不含90分）输出B；70分-80分（不含80分）输出C；60分-70分（不含70分）输出D；60分以下输出E。\n\n```python\nkid = input（'请输入成绩。。。'）；\nif  kid >= 90:\nkids = 'A'\nelif  kid >= 80 and kid < 90:\nkids='B'\nelif  kid >= 70 and kid < 80:\nkids='C'\nelif  kid >= 60 and kid < 70:\nkids='D'\nekse:\n   kids='E'\n   print('对应等级是：'，kids)\n \n```\n\n**练习3：输入三条边长，如果能构成三角形就计算周长和面积。**\n\n```python\na = float(input('a='))\nb = float(input('b='))\nc = float(input('c'))\nif a+b>c and a+c>b and b+c>a:\nprint('周长：%.2f' % (a+b+c))\np =(a+b+c)/2\narea =(p*(p-a)*(p-b)*(p-c))**0.5  //海伦公式\nprint('面积：%.2f' % (area))\nelse:\n    print('不能构成三角形')\n```\n\n","tags":["python"],"categories":["语言与Linux"]},{"title":"回顾和BOM模型最后一部分","url":"/21578/","content":"## 回顾\n\nxx元素.style.left  =   -   200 * i  +   'px'\n\nxx元素.style.left='translateX(  - '  +  24*i  + '  % )'\n\n定时器设置全局变量以防反复创建\n\nassign（url）\n\n     localStorage.setlten对象\n\nsessionStorage对象<!--more-->\n\n| **history对象：**     【了解：浏览器历史记录】 |      |      |\n| ---------------------------------------------- | ---- | ---- |\n| history.back:后退一步                          |      |      |\n| .forward():前进一步                            |      |      |\n| .go(n)：后退（n为负时）或前进（n为正时）n步    |      |      |\n\n| navigator对象：  【了解：浏览器的名字版本号。。。。。】 |\n| ------------------------------------------------------- |\n| 使用：navigator.userAgent：获取到浏览器的信息（字符串） |\n\n### **ocalStorage对象**\n\n| localStorage.setItem( 'key名称', '值' )以给定的键（key）存储一个数据【只能存字符串】 |\n| ------------------------------------------------------------ |\n| **localStorage.getItem( 'key名称' )获取指定键（key）对应的数据** |\n| **localStorage.removeItem( 'key名称' )删除（key）对应的数据** |\n\n\n\n### **client系列：**（不属于html属性？div？）\n\n除了：scrollTop 和scrollLeft------只读不可修改\n\nxx元素.clientWidth:  盒子padding范围（含padding）的宽度\n\nxx元素.clientHeight:盒子padding范围（含padding）的高度\n\nxx元素.clientLeft:\n\n### **offset系列：**（不可修改？）\n\n### **scroll系列：**\n\ntop（有用，定位用。滑块位置没有单位）\n\n\n\n### 移动端\n\n原生：\n\ntouchstart： 触摸开始事件\n\ntouchmove： 触摸移动事件\n\ntouchend： 触摸结束事件\n\n【不会用到】\n\n移动端事件绑定推荐用addEventListener（）方式\n\n’使用第三方封装‘\n\n触摸点信息的途径或方式：\n\n事件处理函数传入参数（event）event.触摸点[i]【是个伪数组】\n\n### **三个触摸集合：**\n\ne.touches:代表所有触摸点，是一个集合\n\ne.targetTouches:代表当前绑定事件的某个元素（对象）上的所有触摸点，是一个集合。\n\ne.changedTouches: 代表当前变换了的触摸点\n\n\n\n总结：\n\n关于移动端获取事件的信息的基本对象层级结构：\n\n event对象》》触摸点集合》》触摸点》》触摸点属性\n\n### 封装tap事件\n\n**tap事件的特征是：**x坐标和y坐标的差值，都足够小\n\n**左划事件:**  x    y 差值，< - 15;\n\n**右划事件：**x    y 差值    > 15;\n\n触摸开始\n\n触摸接触\n\n### transitionend（过渡完成）事件：\n\n过渡：表示过渡效果执行完成的那个时刻。\n\nxx元素.children.length图片个数长度\n\n### swiper轮播插件：\n\n https://www.swiper.com.cn","tags":["js"],"categories":["Web前端"]},{"title":"语言元素","url":"/32215/","content":"\n##              语言元素\n\n| 整数元素： | 浮点类型： | 字符串型： | 布尔型：    | 复数型：       |\n| ---------- | ---------- | ---------- | ----------- | -------------- |\n| int        | float      | str        | true /false | 3+4j（不常用） |\n\n**变量命名：**\n\n### 硬性规则：\n\n1.字母数字和下划线构成（数字不能开头）\n\n2.大小写的敏感\n\n3.关键字 <!--more-->\n\n### PEP 8要求：\n\n1.用小字母拼写\n\n命名书见名知意\n\n变量的使用：\n\n输出：type\n\nint():将一个数值或字符串转换成整数，可以制定进制\n\nfloat():将一个字符串转换成浮点数。\n\nstr()：将指定的对象转换成字符串形式，可以指定编码\n\nchr():将整数转换成该编码对应的字符串（一个字符）。\n\nord():将字符串（一个字符）转换成对应的编码（整数）。\n\n### 输出的字符串是占位符语法\n\n①%d--整数     ②  %f--浮点数     ③%%--表示百分比【注：字符串之后%的变量会替换掉占位符】\n\n运算符象html中一样除了【is ，is not（身份运算符）】【in，not in（成员运算符）】 【not，or，and（逻辑运算符）】\n\n**练习1：华氏温度装换为摄氏温度**\n\n```python\n   k = int(input(''));\n   n = (k-32)/1.8\n   print('%d=%d',(k,n))   //缩进问题\n```\n\n**练习2：输入圆的半径计算周长和面积**\n\n```python\nimport math\n  gh=flost(input(''));\n  io=math.pi*gh;\n  kl= math*gh*gh;\n   print('周长：%.2f % io‘)\n   print('面积：%.2f % kl')\n```\n\n**练习3：输入年份判断是不是闰年。**\n\n```\nyear=int(input(''));\nyu=(year % 4 == 0 and year % 100 !=0) or( year % 400 == 0 )\nprint(yu);\n```\n\n","tags":["python"],"categories":["语言与Linux"]},{"title":"回顾知识点","url":"/48702/","content":"\n## 回顾\n\n1.事件的三要素\n\n2.BOM核心【window对象】\n\nxx元素.onxx事件=function（）｛....｝\n\n###    增    删    查    改\n\nxx元素.addEventListener(’xx事件‘，function（）｛｝)\n\n1.可以多次绑定\n\n2.可以设定冒泡或捕获【基本用不到】两种形式的事件。<!--more-->\n\nthis绑定【形式】元素的本身\n\nevent是一个对象，存储了事件发生的那个时候的有些信息（属性）\n\ne.target  e.type  keyCode【按键代码】 e.clientX/Y  e.pageX/Y\n\ne.preventDefault()  a 表单\n\ne.stopPropagation() 阻止冒泡？\n\n事件的委托：\n\n作用：\n\n1.简化绑定行为，节省内存消耗\n\n2.可以对页面初始不存在的元素去设定事件绑定\n\n### 遗留的问题：\n\n1.排他思想\n\n2、window.alert() .confirm() .prompt()?\n\n3.如何解决定时器会反复创建的问题？","tags":["知识点"],"categories":["Web前端"]},{"title":"梦","url":"/60696/","content":"\n## 梦\n\n​        做梦就是在保护我们的生活模式不被现实和常识的要求所威胁。也就是说，如果一个人在现实生活中不想用公知的常理去解决某个问题，那么他就会在梦中表现出来，引起某个让他坚持自己想法的感觉。梦主要是由隐喻和象征构成的。梦的目的在于自欺欺人，让我们自己陶醉其中。一般人在梦中的目标和白天的目标是一致的，就像人在梦中也在努力追求白天追求的优越感一样，梦是我们生命意义的另一种表达方式，同时也有利于我们生命意义的塑造和达成。\n\n <!--more-->\n\n​    每一个梦我们都是在自我陶醉、自我催眠。它的目的就是引起我们某种感觉，这中感觉能为我们清醒状态时候想要解决问题的方法提供支持。\n\n隐喻是能让人充满想象的，但是必须注意：对于一个在生命意义方面已经偏差了的人来说，运用隐喻和符号来解决问题是一件很危险的事。对于梦的解释都是属于个人的，我们不可能用公式来解释符号和隐喻，因为梦是生活模式的产品。\n\n\n\n","tags":["心理学"],"categories":["爱好心理学"]},{"title":"如何有效阅读一本书（四）","url":"/21350/","content":"# 如何有效阅读一本书（四）\n\n### 利用书签边读边写\n\n**☞三枚书签**----------------①通读书签②重读书签③标记书签\n\n**☞巧用标记区分对象**\n\nEg：普通直线、波浪线、圆圈等。（注：笔记本上尽量少画线，避免重读的时候影响心情）ps：好像有点前后矛盾╮（╯＿╰）╭\n\nps：需要分清一开始写与后来补充的 \n\n| <u>三项</u>信息 = 写读书笔记的日期 + 书名 + 作者名     【ps：想起读什么书、理解成度】 |\n| ------------------------------------------------------------ |\n| ↑（摘抄 + 评论）                                             |\n\n> 引：“摘抄对自己来说很重要的文章” “写主观评论”\n\n摘抄：①促进、加深对书的记忆②加深理解【注：二次理解】<!--more-->\n\nR：抄写是要尽量减少视点的移动，避免在视线转移的过程中逐渐忘记自己要写的内容。~~人话：减少分神时间~~\n\n> 读过一本书以后，对书中内容感同身受固然让人心情愉悦，但这也代表这次读书没有给你带来新的东西。相反，如果一篇文章颠覆了你之前的想法，使你的认识发生动摇，在抄写和重读的过程中仍然会让人信服或感觉震撼，这中文章才是值得摘抄的。\n\n**☞最能代表这次读书体验的语句**---------中心句【ps：如何有效阅读一本书 **:-D**】\n\n杂：自己当下的想法最重要。\n\nps：读书时获得的感想正是原创<u>思考</u>的源泉。【深与浅】\n\n**⊙葱鲔火锅式**","tags":["我的读书笔记"],"categories":["笔记"]},{"title":"BOM模型","url":"/1436/","content":"## BOM模型\n\n### 全局变量   全局函数\n\n```html\nvar v1 = 10是全局变量,则v1 === window.v1为真\nfunction fn1 = function(){...}是全局函数,则fn1 === window.fn1为真\n注:可以不使用window.前缀\n```\n\n<!--more-->\n\n直接使用要删除这个元素的关系来删除该元素\n\ntoDeleteObj.parentNode.removeChild();\n\n### 使用一次性定时器\n\n**创建一次性定时器:**\n\nvar 名字=window.setTimeout(要调用的函数,等待的时间)\n\n等待时间单位是毫秒\n\n该时间后执行一次\n\n**清除一次性定时器:**\n\nwindow.clearTimeout(名字)\n\n### 使用重复性定时器\n\nvar 名字 = window.setlnterval(要调用的函数,间隔的时间);\n\n每间隔该时间,都会执行一次所指定的函数\n\nwindow.clearlnterval(名字)\n\nproperty  属性\n\n","tags":["js"],"categories":["Web前端"]},{"title":"event方法","url":"/47049/","content":"## 事件流\n\na标签的链接 【】   form标签的提交 【】 return false--------其它做法\n\n### event事件:\n\n属性:target,type,clientX/Y,pageX/Y,keyCode\n\n<!--more-->\n\n方法:preventDefault(),stopPropagation()\n\n### **事件绑定方式:**\n\n //只能绑定一次,而且只能是冒泡事件\n\n  元素.onxx事件 = function(){}\n\n//可以绑定多次,也可以绑定捕获或冒泡事件\n\n元素.addEventListener('xx事件',function(){}true/false) [true为捕获.false为冒泡]\n\n### 阻止事件默认行为:\n\n​    e.preventDefault()\n\n### 阻止事件传播:\n\n e.stopPropagation()\n\n某个节点.modeType\n\n1.代表元素\n\n2.代表书序\n\n节点属性:\n\nnode.nodeType\n\n​                  name[元素节点的nodename也就是元素的标签名,而且必然是大写]\n\nValue/\n\n###     事件委托:\n\nevent.target获取当前触发事件的对象\n\nkeyCode获取键盘码","tags":["js"],"categories":["Web前端"]},{"title":"事件处理","url":"/42758/","content":"\n##                                         事件处理\n\n事件源：事件类型：事件处理函数：\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t事件三要素其实就是设定某个元素上发生了某个时间后要做什么事\n\n事件绑定（事件注册）\n\n### 常用事件概览（on）\n\n**鼠标事件：**\n\nclick，dblclick\n\nmouseover：鼠标进入某个盒子范围的那个时刻\n\nmouseout：离开\n\nmousemove：鼠标移动事件，通常是一个持续时间。 <!--more-->\n\nmouseenter：(盒子范围)跟over几乎一样，但是更好用\n\n mouseleave： （离开盒子范围）out一样，\n\n**键盘事件：**\n\nkeydown：按钮按下去的时刻发生\n\nkeyup：抬起\n\nkeypress：按键一次\n\n**表单事件：**\n\nsubmit：表单提交事件\n\n change：表单项的数据被改变的时刻（光标离开后）\n\ninput：输入时刻\n\nfocus：获得焦点。。。\n\nblur：失去焦点。。。（空字符串）\n\n**其它事件：**\n\nload：加载成功事件（网页加载）\n\n###  事件绑定\n\n**标签属性绑定---------过时，不推荐**\n\n语法：<div on事件=\"xx函数();\">...</div.>（调用函数）\n\n**移除方式:**\n\n●xx元素.onxx事件=null\n\n●直接在html中删除该事件绑定代码(ps:不过这就不是js的工作)\n\n **对象属性绑定---------简洁、常用，满足绝大数使用**\n\n☞xx元素.onxx事件 = 函数名； //函数名后不带括号\n\n  **移除方式:**\n\n●xx元素.onxx事件=null\n\n☞xx元素.onxx事件=function(){...}; //这里是匿名函数\n\n（注：等号后面是一个函数名，;不是调用函数）\n\n**对象方法绑定---------更好的可控性**\n\n**语法：**xx元素.addEventListener('xx事件',xx事件处理函数);\n\n第2个参数是事件处理函数,可以是匿名函数,也可以是一个函数名\n\n**对应删除:**\n\n●xx元素.removeEventListenter('xx事件',xx事件处理函数);\n\n●==特别注意:绑定后如果=需要再移除,则使用同样的函数名,且第1参数也要求一样==\n\n### 函数中的this\n\n**提示：**在对象属性绑定和通过对象方法绑定的事件处理函数中，都**可以直接使用this关键词**。但通过元素标签属性的形式绑定的事件处理函数中不可以直接使用。\n\n### **排他思想（特例）：**\n\n排他思想的基本代码模式：\n\n1， 设定若干同类元素相同表现\n\n2， 设定当前某个特殊元素的特殊表现（通常都会需要用到 this )\n\n```html\n/*先设定所有一致（所有都同样）*/\n\n/*给当前设置特殊*/\n\n```\n\n","tags":["js"],"categories":["Web前端"]},{"title":"伸缩布局","url":"/11450/","content":"##                                                                **伸缩布局**\n\n**什么时候使用伸缩布局:**\n\n1.如果在在网页中希望让元素一行显示,并且元素随着父元素的宽度改变**布局方式不会受影响**\n\n2.使用了伸缩布局以后,还可以使用浮动,定位,margin,padding\n\n3.伸缩布局只是一个新的布局方式,不要把伸缩布局看的太重或者太难\n\n### 核心知识点\n\n1.伸缩盒子设置\n\n2.设置伸缩盒子主轴 <!--more-->\n\n3.设置伸缩盒子主轴对齐方式\n\n4.设置伸缩盒子侧轴对齐方式\n\n5.设置伸缩盒子伸缩比例\n\n6.less基本语法及使用\n\n###         **伸缩布局两个步骤:**\n\n​             **●给父元素设置的属性**  \n\n```css\ndisplay:flex;   /*设置为伸缩盒子(弹性盒子)*/ 注:一定给父级!!!一定给父级!!!一定给父级!!!\n```\n\n```css\njustify-content/*设置元素在主轴对齐*/\n\njustify-content:flex- start;  /*默认*/\njustify-content:flex-end;     /*结束*/\njustify-concent:center;  /*居中*/\njustify-content:space-between;/* 两端对齐中间自适应 */\njustify-content: space-around; /* 环绕 */\n```\n\n```css\nflex-direction: /*设置主轴的方向*/\nrow(默认,水平)  | column(竖显示) | row-reverse(横-右到左) |   column-reverse(纵-右到左)\n```\n\n```css\nalign-items; /*设置元素相对侧轴对齐方式*/\nstretch(默认,拉伸效果)  | flex-start(起点对齐)  | flex-end(终点对齐) | center(中心)   |  baseline(第一行文字的基线对齐)\n```\n\n```css\nflex-wrap:/*设置伸缩盒子中元素是否换行显示*/\nnowrap 默认不换行 |  wrap 换行\n```\n\n```css\nalign-content:/*当元素换行后的一种对齐方式*/\nstretch(默认)\n注:如果要设置align-content必须要保证元素是换行的\n```\n\n​                                                  **注:**  flex-flow复合属性 ===flex- direction和flex- wrap\n\n **●给子元素设置的属性**\n\n```css\nflex:/*设置元素占父元素剩余宽度的一个比例*/'也就是1份'\n注:\n    1.flex 属性是给子元素设置的\n    2.剩余宽度:如果父元素中固定宽度的盒子,那么flex所占的比例是父元素整个的宽度-固定宽度后的比例\n```\n\n​    **● 伸缩盒子中-子元素排序**\n\n```css \norder:值;  /*设置元素排序*/\n特点:\n     1.值越大元素越靠后显示\n     2.在排序时候,完全不用修改html结构\n```\n\n###  **伸缩盒子的特点:**\n\n​         1.伸缩盒子中的所有元素都是一行显示的\n\n​         2.解释为什么伸缩盒子中的元素默认会一行显示?\n\n​                      ✖在伸缩盒子中元素都是按照**主轴显示**的\n\n​                      ✖在伸缩盒子中有一条主轴,主轴的**默认水平显示**  \n\n​         3.在伸缩盒子中还有一条轴,叫侧轴.(侧轴始终要垂直于主轴,侧轴的方向是随着儿主轴的方向发生改变的)\n\n​          4.在伸缩盒子中,如果子元素的宽度超出父元素的宽度,那么元素也不会换行\n\n**注:**                                                                                                                                                                                                                                                                              在伸缩盒子中元素一行显示,与脱标没有任何关系","tags":["HTML"],"categories":["Web前端"]},{"title":"如何有效阅读一本书（三）","url":"/15783/","content":"##                                如何有效的阅读一本书(三)\n\n1.从一句话开始                                   ~~ps：凡事一句话搞定？~~     **(^ ^)v**\n\n2.对自己很重要的事情                       ~~ps：有很多先做哪一个~~       **:D**\n\n| 读书的目的是用自己的方式学习，而不是模仿评论家的做法，学习、吸收对自己真正有用的智慧和语句才是最重要的。 |\n| ------------------------------------------------------------ |\n| ~~杂：如果别人的学习方式比你的要好，是否还要坚持自己的学习方式？一味的模仿固然不对，但要怎么’避免‘【模仿与学习】？~~      **------------------------------**     **注：学会变通** |\n\n> “这不是语文考试，没必要去拼命思考笔者（作者）想要传达什么。只要关注相关注的内容就好了”**----------------------注：一般来说只要思想不滑坡，就不会想偏。**\n\n <!--more-->\n\n<u>**【杂：只留下应有的想法即可】**</u>\n\n千万不要为了坚持写读书笔记而走形式主义，不管采用什么方式，都要脚踏实地地写读书笔记，并真正理解书的内容。                                       ps：经历吗？对于不长出门的人来说，有些困难\n\n巩固印象的**<u>笔记</u>** **--------加深记忆**          注：反复理解内容与修改想法\n\n  R：读书是一项“对重要内容进行提炼的工序”      ps：大脑会反复加工这一重要的内容\n\n**筛选程序：**\n\n① 通过一边阅读一边把觉得有价值的呢一也折角\n\n② 重读（ps：反复阅读）\n\n③ 标记......","tags":["我的读书笔记"],"categories":["笔记"]},{"title":"练习案例","url":"/43922/","content":"\n### 节点关系获取元素\n\n**==演示==：**\n\n**使用元素的一些关系属性获取元素。**\n\n**准备的素材：一个有id的无序列表。通过children找出第2个li，然后据此演示使用其他一些关系以获取元素。**\n\n <!--more-->\n\n```html\n<ul id=\"list\">\n\t\t<li>项目1</li>\n\t\t<li>项目2</li>\n\t\t<li>项目3</li>\n\t\t<li>项目4</li>\n\t\t<li>项目5</li>\n\t</ul>\n<script>\n    var ul = document.getElementByid('list');\n    var li = document.getElementsByTagName('li');\n    var iu = li[0].parentNode;\n    var op = ul.children;\n    var ki = ul.firstElementChild;\n    var hi = ul.lastElementChild;\n    console.log(iu);\n    console.log(op); \n    console.log(ki);\n     console.log(hi);\n</script>\n\n\n\n```\n\n### 根据特征信息获取元素\n\n**==演示==：**\n\n​\t**使用get系列方法和query系列方法获取元素。**\n\n​\t**准备的素材：一个设定了id和class的div。**\n\n```html\n <div id=\"box1\" class=\"msg\">sha</div>\n    <script>\n        var box1 = document.getElementById('box1');\n        var msg = document.getElementsByClassName('.msg');\n        console.log('msg')\n    </script>\n```\n\n### 开关灯案例\n\n **==案例3（介绍开关思想）==：** \n\n**网页上有一按钮，点击按钮，使整个页面能够在“关灯/开灯”之间切换。**\n\n**所谓关灯/开灯，就是让网页的整体背景为黑色和白色。**\n\n```html\n <input type=\"button\" value=\"开关\" id=\"op\">\n    <script>\n        var body = document.body;\n        var yi = true;\n        var op = document.querySelector('#op');\n        op.onclick = function () {\n            if (yi == true) {\n                body.style.backgroundColor = 'black';\n                op.value = '关灯';\n                yi = false;\n            } else {\n\n                body.style.backgroundColor = 'white';\n                op.value = '开灯';\n                yi = true;\n            }\n\n        }\n\n    </script>\n```\n\n### 添加元素案例（一）\n\n```html\n <button id=\"ll\">点一下</button>\n\n    <ul id=\"po\"></ul>\n\n    <script>\n        var bon = document.querySelector('#ll');\n        var ul = document.querySelector('#po');\n\n        // var bon = document.getElementsByTagName('button');\n        // var ul = document.getElementsByTagName('ul');这个不显示\n        bon.onclick = function () {\n            var ki = document.createElement('li');\n            ul.appendChild(ki);\n        }\n    </script>\n```\n\n### 添加元素案例（二）\n\n**在一个无序列表中实现如下需求：**\n\n**1，点击按钮1，创建一个div放入第一个li中，**\n\n**2，点击按钮2，克隆第一个li，并放到该列表的倒数第2个的位置（即最后一个的前面），,**\n\n**3，点击按钮3，将最后一个li替换为一个新创建的li。**\n\n```html\n<body>\n    <button id=\"btn1\">添加一个div到第1个li</button>\n    <button id=\"btn2\">克隆第1个li并放入倒数第2个位置</button>\n    <button id=\"btn3\">替换最后1个li</button>\n    <button id=\"btn4\">删除最后一个li</button>\n    <ul>\n        <li>列表项1</li>\n        <li>列表项2</li>\n        <li>列表项3</li>\n        <li>列表项4</li>\n    </ul>\n    <script>\n        var btn1 = document.querySelector('#btn1');\n        var ul = document.querySelector('ul');\n        btn1.onclick = function () {\n            var div = document.createElement('div');\n            var fist = ul.children[0];\n            fist.appendChild(div);\n        }\n        var btn2 = document.querySelector('#btn2');\n        btn2.onclick = function () {\n            var li = ul.children[0].cloneNode(true);\n            var kj = ul.lastElementChild;\n            ul.insertBefore(li, kj)\n        }\n        var btn3 = document.querySelector('#btn3');\n        btn3.onclick = function () {\n            var li = document.createElement('li')\n            var kl = ul.lastElementChild;\n            ul.replaceChild(li, kl)\n        }\n        var btn4 = document.querySelector('#btn4')\n        btn4.onclick = function () {\n            // var yi =ul.children[3];\n            var li = ul.lastElementChild;\n            ul.removeChild(li);\n\n        }\n    </script>\n```\n\n### 修改原生的HTML属性案例（一）\n\n **==案例1==：**\n\n**页面上有两个按钮，一张图片。每点击一次按钮1，使图片变大20像素，每点击一次按钮2，使图片变小20像素。**\n\n```html\n<button id=\"btn1\">放大</button>\n    <button id=\"btn2\">缩小</button>\n    <br>\n    <img src=\"gl.jpg\" alt=\"\" width=\"100\">\n    <script>\n        var btn1 = document.querySelector('#btn1');\n        var img = document.querySelector('img');\n        var fn = img.width;\n        btn1.onclick = function () {\n            fn += 20;\n            img.width = fn;\n        }\n        var btn2 = document.querySelector('#btn2');\n        btn2.onclick = function () {\n            fn -= 20;\n            img.width = fn;\n\n        }\n\n\n    </script>\n```\n\n### 修改原生的HTML属性案例（二）\n\n**==案例2==：**\n\n**购买数量的增减操作**\n\n```html\n<body>\n    <style>\n        div {\n            width: 80px;\n        }\n\n        input[type=\"text\"] {\n            width: 50px;\n            height: 44px;\n            outline: none;\n            border: 1px solid #ccc;\n            text-align: center;\n        }\n\n        input[type=\"button\"] {\n            height: 24px;\n            width: 22px;\n        }\n\n        input {\n            float: left;\n        }\n    </style>\n    <div>\n        <input type=\"text\" id=\"total\" value=\"1\" readonly>\n        <input type=\"button\" value=\"+\" id=\"add\">\n        <input type=\"button\" value=\"-\" id=\"reduce\" disabled>\n    </div>\n    <script>\n        var ddf = document.querySelector('#total');\n        var add = document.querySelector('#add');\n        var naa = document.querySelector('#reduce');\n        add.onclick = function () {\n            var ui = ddf.value;\n            ui++;\n            ddf.value = ui;\n            naa.disabled = false;\n        }\n        naa.onclick = function () {\n            var ul = ddf.value;\n            ul--;\n            if (ul <= 0) {\n                ul = 1;\n                naa.disabled = true;\n            }\n            ddf.value = ul;\n\n        }\n    </script>\n```\n\n","tags":["HTML"],"categories":["Web前端"]},{"title":"知识点(二)","url":"/50744/","content":"\n##          知识点\n\n​          1.display:none *与visitibility:hidden  前者不保留位置,后者保留位置\n\n​          2.额外标签法 overflow  伪元素法\n\n​          3.css3盒子模型border-box中,盒子的width包含了conter+border+padding(实际宽高)\n\n​         4.vertical-align:middle            vertical-align:top       vertical-align:bottom  \n\n5. css三种引入方式:行内式,内嵌式外联时","tags":["知识点"],"categories":["Web前端"]},{"title":"如何有效阅读一本书（二）","url":"/12766/","content":"##               如何阅读一本有效的书(二)\n\n**1.熟读书评**                   **ps：书评两级分化严重该怎么解决？**\n\n**2.坚持做笔记**                   ~~ps:大多数时间，都在走神与胡思乱想  **:）**~~\n\n**作用:  图书都是有重点的,没有必要从头到尾详读.重要的是不管篇幅多少,都要下点功夫让自己对读过的书有印象.即使只记下这本书的作者、书名,阅读时的情景或是做些摘抄都好,要坚持写读书笔记,这是最有效的读书方法.**\n\n**ps:不管怎么说还是坚持、用心好点或正确的对待写读书笔记这件事. R:读书笔记改变读书方法可以理解为不要漫无目的的读书.**  <!--more-->\n\n> **引:\"为了写出精炼而深刻的读书笔记,你应该在读完一本书以后认真回想需要摘抄那一页哪一行,思考怎样撰写读书笔记,然后严格的筛选需要摘抄的内容,尽量提炼自己的感想,争取用最短的语句表达深刻的含义\"    (注:以思想输出为前提)**\n\n**ps:想法很重要,有什么一闪而过想法最好写下来.避免被忘掉,从而错过有趣(重要)的想法.**\n\n| **杂:对于书中所说'速度'与'跳读',我到是并不建议'跳读'**       |\n| ------------------------------------------------------------ |\n| 一是会错过有趣的故事、人物关系  二是会记忆混乱，看的一头雾水. |\n\n**K:要注意读书的重心,要放在你读书为了什么或者为什么要读书.而不是单单是读过就好或者为了应付什么**\n\n**杂:还是有必要说一下不要钻牛角尖,不要死读书,把握好时间与节奏.**\n\n","tags":["我的读书笔记"],"categories":["笔记"]},{"title":"HTML基础（一）","url":"/16841/","content":"\n##                                                                                                第一天\n\n1.**ctrl+s** 保存                         Lorem 乱数假文\n\n2.英文下的 **！+Tab**   \t**注**：（vs code）\n\n3.字符集-----避免乱码(**utf- 8**) **注**:不区分大小写\n\n4.语言的种类-----避免编译器乱码\t**eg: en 、zh-CN**\t\n\n5.关于h1  网页只有一个标题\n\n<!--more-->\n\n| 小图标图片\t------\t  b \t\t\t\t\ti \t\t\t\t                       u               \ts |\n| ------------------------------------------------------------ |\n| **段落与文字  -------\t strong  加粗   em\t倾斜    ins\t下划线   del 删除线** |\n\n~~文本格式化~~                     \n\n( 注:vs code 需要下载汉化插件与Open In Default Browser)\n\n| 相对路径: ./同一级  /下一级 ../上一级 |\n| ------------------------------------- |\n| **绝对路径: 盘符与网页图片**          |\n\n**a href:**链接可以下载文件  放入链接    图片等等   **[注:下载需要打包(压缩文件)]** \n\n加入空链接   **#** \n\n锚点定位 -------#\"类id\"     **eg:\"\\#ygsts\"**\n\n注释快捷键    ctrl + /\n\n","tags":["HTML"],"categories":["Web前端"]},{"title":"响应式布局","url":"/50332/","content":"###                                             **响应式布局**写对位置\n\n1.(同一个网页在不同设备中[布局]呈现的效果)\n\n**核心知识**\n\n◎媒体查询\n\n        媒体查询            liagn-height 可以不用加px    (一倍)\n\n```css\n@media only screen and (width:**/*不加分号*/) {   /* 加空格*/ \n    div {\n           宽\n           高\n         背景颜色\n    }\n}\n```\n\n1.媒体查询就是响应式布局实现的原理\n\n2.总结:可以让css代码在满足某些条件的情况下才去执行 <!--more-->\n\n◎boostrap框架\n\n◎栅格系统\n\n注:一旦涉及行内元素都需要转化为块元素","tags":["HTML"],"categories":["Web前端"]},{"title":"流式布局","url":"/1507/","content":"\n###  **流式布局**                     \n\n1.ppi 像素密度(越高画质越好,相反)-----没用[设备像素]\n\n2.dpr物理像素比(具体不能改变的比例关系--作用--适配)   [硬件]                  \n\n##  视口(viewport)\n\n1.禁止------水平滚动---页面缩放\n\n2.视口-----pc[浏览器的大小]----移动[移动设备的大小]\n\n### **视口的设置**\n\n```css\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">                      移动设备宽 ←↑         ↑→ 忘了\n```\n\n **注:** 左右固定---中自适应     **注:**精灵图----向上向左        <!--more-->\n\n**注:**转元素转块元素、行内元素\n\n​             ♦行内块元素是一个非标准的元素      \n\n​             ♦  行内块元素默认都会找基线对齐---(底部多3像素空白)\n\n​             ♦''图片是行内块元素转化为块元素  (加浮动=转化块=)----[清除浮动]' '\n\n                 ∮  盒子之间用padding值撑开,切记不要用margin值\n\n### **多行文字显示省略号**\n\n```css\n              /* 实现多行文字溢出显示省略号 */\n              overflow: hidden;\n             /* 文字溢出显示省略号：单行文字 */\n              text-overflow: ellipsis;\n             /* 辅助属性：兼容性 */\n             -webkit-line-clamp: 2;\n             /* 文字就要垂直显示 */\n             -webkit-box-orient: vertical;\n             /* 还需要设置一个弹性盒子 */\n             display: -webkit-box;\n```\n\n### **防止汉字自动换行**(默认)\n\n```css\n/*解决让文字不在特殊符号(空格,特殊符号)位置处换行*/\n  word-break:break-all;\n```\n\n​         \n\n### **网页的步骤**\n\n1. 页面样式初始化\n\n2. 任何的一个项目都要单独的在一个文件夹中\n\n3. 任何文件的命名都不能出现汉字\n\n   ### **html的步骤**\n\n   1.一般情况下,在网页中先设置一个大盒子\n\n   ​     ▶<u>如果是一个最外层的大盒子,设置宽度100%( 重要)</u>\n\n   ​      ▶如果盒子的高度可以直接测量出来,可以设置高度,反之让内容撑开\n\n   2.在最外层大盒子中划分其它盒子\n\n   ​       ▶搜索盒子(宽度与设备一宽,要设置高度,设置背景颜色,固定定位盒子,以及内[三个盒子])\n\n   ​         ▶搜索盒子中要实现     [两端固定大小,中间[设置padding值]自适应效果]\n\n   {为了防止padding撑大盒子设置! !初始化(最好用一个写一个,以防..以防..[~~ps：想不起来用什么词了...~~])'}\n\n   ### 注:                                                               [初始化]\n   \n   ```css\n   /*实际开发不写*/\n   *{\n      padding:0;\n      margin:0;\n   }\n   /*真确写法*/\n   body,p,h1,h2,h3,h4,h5,h6,ul,ol,dl,dd{\n       margin:0;\n       padding:0;\n       list-style:none;\n       font-size:14px;\n       font-familt:'宋体';\n   }\n   a{\n       /*清除下划线*/\n       text-decoration:none;\n   }\n   img,input{\n         vertical-align:middle;\n         /*去掉边框*/\n       border:0;\n       /*轮廓线*/\n       outline:none;\n       padding:0;\n   }\n   /*清除浮动*/\n   .clearfix::after{\n       content:\"\";\n       display:block;\n       height:0;\n       visibility:hidden;\n       clear:both;\n   }\n   .clearfix{\n       *zoom:1;\n}\n   ```\n\n    **例外 问题:**\n\n   ♣背景图片:当页面中的标签某个图标效果,或者图片只是一个衬托效果(给高宽)\n\n   ♣img图片:图片角色很重要[广告,商品]\n\n   **重要:**  \n\n   选择器层级不要太高,类选择器不要超过3个[权限会很高]\n\n   **扩展知识点:**\n\n   ♠定位 ------♪当一个元素加了定位有层级关系(后来居上原则)[z-index:*;]\n\n   ​        ♪定位脱标元素盒子居中\n\n   ```css\n   transform:translate(-50%);[后期会讲,先记住]\n   ```\n   \n   ♠盒子模型 ------\n   \n   ```css\n         ♪max-width---最大宽度    ♪min-width-----最小宽度\n   ```\n   \n   ♠其它内部属性\n   \n   ```css\n   div{\n       position:absolute;\n       left:0;\n       top:0;\n    \n       width:**px;\n       height:**px;\n       \n       font-size:**px;        /*字的大小颜色(背景)对齐方式*/\n       text-align:****;\n   }\n   ```\n   \n   底部的固定定位:需要加padding-bottom撑开\n   \n   名:没有固定的宽或高","tags":["HTML"],"categories":["Web前端"]},{"title":"移动回顾","url":"/58682/","content":"\n##      **移动回顾**\n\n 1.流式布局\n\n2.伸缩布局-----------[修改主轴的方向,设置元素在主轴方向的对齐,元素在侧轴的对齐方式]\n\n3.响应式布局-----------[解决了同一个网页在不同设备中布局显示效果不同]\n\n核心知识点----------媒体查询\n\n### 页面适配\n\n**rem适配**  -------相对html中的文字大小 <!--more-->\n\n1.要设置html中文字的大小 = 设备的宽度/缩放的倍数\n\n2.测量元素转化为  rem = 当前元素测量的大小rem / (UI图宽度/缩放的倍数)\n\n备注:\n\n640px UI图一般  缩放 20倍\n\n750px UI 图一般缩放 25倍\n\n","tags":["HTML"],"categories":["Web前端"]},{"title":"修改元素内容和属性","url":"/26957/","content":"##                       修改元素内容和属性\n\n### 原生html属性操作：\n\n取值：console.log（xx元素.src）\n\n赋值：xx元素.alt = 'abc';    js不带单位\n\n### 自定义属性\n\n**设置一个属性的值**\n\n​    xx元素.setAttribite('属性名'，'属性名')   <!--more-->\n\n**获取给定属性的值**\n\n​    xx元素.getAttribute('属性名')\n\n**移除一个属性**\n\n​    xx元素.removeAttribute('属性名')\n\n### **html特殊属性**\n\n**布尔值**\n\n1.checked属性  用于单选或多选    true（选中） false\n\n2.selected属性 下拉框\n\n3.disable属性 禁用    \n\n### 容器盒子的内容属性\n\n 1.innerHTML  2.innerText\n\n### style操作样式属性\n\n局限性：\n\n样式值都是字符串类型的值\n\n通过style读取和设置的都只能是行内样式。\n\n样式属性名的写法跟css有所出入，必须使用“小驼峰”命名法，类似这样：xxxYyyZzz\n\n### className操作属性\n\njs读取-----------var v1 = xx元素.className\n\njs中设置 ---------- xx元素.-----=‘类名’\n\n**注：**如果元素有多个类名，则用空格隔开进行赋值\n\n### classList 操作class属性\n\n1.添加一个类（class）：\n\nxx元素.classList.add（‘类名’）\n\n2.移除一个类（class）：\n\nxx元素.classList.remove( '类名' )\n\n3.切换一个类（class）：\n\nxx元素.classList.toggle( '类名' )\n\n注： 切换的意思是： 有就移除，没有就添加。\n\n#### 通过className来操作类，和通过classList来操作类，有什么区别？\n\n1.className设置的类，是会完整覆盖一个元素的calss属性的值\n\n2.classList.add（）设置的类，会保留原来的class，并且加上新的这个\n\n### 获取非行内样式的值\n\n1.使用xx元素.style.样式名 只能获取行内样式的值\n\n2.getcomputedstyle（xx元素）可以获取到一个元素的所有style样式，结果是一个对象 \n\n var style = getcomputedstyle（xx元素）【兼容性】","tags":["js"],"categories":["Web前端"]},{"title":"WebPAI案例(一)","url":"/35863/","content":"### 放大与缩小案例\n\n```html\n<button id='jkl'>放大</button>\n<button id='kjl'>缩小</button>\n<br>\n<img src=\"gl.jpg\" alt=\"\" width=\"100\">\n<script>\n    var img = document.querySelector('img');\n    var kids = img.width;\n    var jkl = document.querySelector('#jkl');\n    var kjl = document.querySekector('#kjl');\n    jkl.onclick = function(){\n        kids += 20；\n        img.width = kids；\n    }\n    kjl.onclick = function（）｛\n        kids -= 20；\n        img.width = kids；\n    ｝\n</script>\n```\n\n <!--more-->\n\n### 特殊属性的运用案例\n\n```html\n加与减\n<style>\n\t\tdiv {\n\t\t\twidth: 80px;\n\t\t}\n\t\tinput[type=\"text\"] {\n\t\t\twidth: 50px;\n\t\t\theight: 44px;\n\t\t\toutline: none;\n\t\t\tborder:1px solid #ccc;\n\t\t\ttext-align: center;\n\t\t}\n\t\tinput[type=\"button\"] {\n\t\t\theight: 24px;\n\t\t\twidth: 22px;\n\t\t}\n\t\tinput {\n\t\t\tfloat: left;\n\t\t}\n\t</style>\n</head>\n<body>\n\n\t<div>\n\t\t<input type=\"text\" id=\"total\" value=\"1\" readonly>\n\t\t<input type=\"button\" value=\"+\" id=\"add\">\n\t\t<input type=\"button\" value=\"-\" id=\"reduce\" >\n\t\t<script>\n\t\t\tvar total = document.querySelector('#total')\n\t\t\tvar add = document.querySelector('#add')\n\t\t\tvar reduce = document.querySelector('#reduce')\n\t\t\tadd.onclick = function(){\n\t\t\t\t// 获取到输入框中现有的值\n\t\t\t\tvar v1 = total.value;\n\t\t\t\tv1++;\n\t\t\t\t// 在将该变化了值赋值回输入框\n\t\t\t\ttotal.value = v1;\n\t\t\t\t// 加上去之后，值至少已经是2 了，所以，“-”按钮要重新设置为可用状态：\n\t\t\t\treduce.disabled = false;\n\t\t\t}\n\t\t\treduce.onclick = function(){\n\t\t\t\t// 获取到输入框中现有的值\n\t\t\t\tvar v1 = total.value;\n\t\t\t\tv1--;\n\t\t\t\tif( v1 <= 0) {\n\t\t\t\t\tv1 = 1;\n\t\t\t\t\t// 此时，还需要去禁用“-”这个按钮\n\t\t\t\t\t// reduce.disable = \"disabled\";// 发现这种写法无效！！！\n\t\t\t\t\treduce.disabled = true;\n\t\t\t\t}\n\t\t\t\t// 在将该变化了值赋值回输入框\n\t\t\t\ttotal.value = v1;\n\t\t\t}\n\t\t</script>\n\t</div>\n```\n\n### 开关灯案例（开关思想）\n\n```html\n 注：如何获取body元素（标签）？|document.body|\n <input type=\"button\" value=\"关灯\" id=\"kids\">\n<script>  \n        var kids = document.quertSelector('#kids');\n         var kid = true;\n    kids.onlick = function () {\n        if(kid == true){\n              kids.value = '开灯'；\n               kid = true；\n            var body = document.body;\n          body.style.backgroundColor = 'black';\n       \n        }else{\n             kids.value = '关灯'；\n               kid = false；\n             var body = document.body;\n          body.style.backgroundColor = 'while';\n        }\n          \n    }\n\n\n\n</script>\n```\n\n### 批量删除案例\n\n```html\n <input type=\"button\" id=\"btn1\" disabled value=\"批量删除\">\n    <table border=\"1\" cellspacing=\"0\" id=\"table1\" width=\"200\">\n        <thead>\n            <tr>\n                <th align=\"left\">\n                    <input type=\"checkbox\" id=\"selectAllBtn\">全选\n                </th>\n                <th>标题</th>\n            </tr>\n        </thead>\n        <tbody>\n            <tr>\n                <td><input type=\"checkbox\"></td>\n                <td>标题啦啦啦1</td>\n            </tr>\n            <tr>\n                <td><input type=\"checkbox\"></td>\n                <td>标题啦啦啦2</td>\n            </tr>\n            <tr>\n                <td><input type=\"checkbox\"></td>\n                <td>标题啦啦啦3</td>\n            </tr>\n        </tbody>\n        <script>\n            var kids = document.querySelector('#btn1');\n            var kid = document.querySelector('#selectAllBtn');\n            var lii = document.querySelectorAll('#table1 tbody input');\n            kid.onclick = function () {\n                var mnu = kid.checked;\n                for (var i = 0; i < lii.lenkgth; i++) {\n                    lii[i].checked = mnu;\n                }\n                btn1.disabled = !mnu;\n            }\n\n\n        </script>\n```\n\n###   innerHtml和 innerText复制的区别【经典案例】\n\n```html\n<button id=\"btn1\">复制html</button>\n\t<button id=\"btn2\">复制text</button>\n\t<div id=\"box1\">\n\t\t<ul >\n\t\t\t<li>项目1</li>\n\t\t\t<li>项目2</li>\n\t\t\t<li>项目3</li>\n\t\t</ul>\n\t</div>\n\t<div id=\"box2\"></div>\n        <script>\n\t\tvar btn1 = document.querySelector('#btn1');\n\t\tvar btn2 = document.querySelector('#btn2');\n\t\tvar box1 = document.querySelector('#box1');\n\t\tvar box2 = document.querySelector('#box2');\n\t\tbtn1.onclick = function(){\n\t\t\tvar str = box1.innerHTML;\n\t\t\tconsole.log(str);\n\t\t\tbox2.innerHTML = str;\n\t\t}\n\t\tbtn2.onclick = function(){\n\t\t\tvar str = box1.innerText;\n\t\t\tconsole.log(str);\n\t\t\tbox2.innerText = str;\n\t\t}\n\t</script>\n\n\n```\n\n**对比innerHTML和createElement()创建元素的效率:**\n\n```html\n<button id=\"btn1\">使用innerHTML</button>\n\t<button id=\"btn2\">使用createElement</button>\n\t<ul id=\"list\"></ul>\n\t<script>\n\t\tvar btn1 = document.querySelector('#btn1')\n\t\tvar btn2 = document.querySelector('#btn2')\n\t\tvar list = document.querySelector('#list')\n\t\tbtn1.onclick = function(){\n\t\t\t// 先将ul中的所有内容（元素）清掉\n\t\t\tlist.innerHTML = '';\n\t\t\tvar str = ''; // 这个变量用于存储 html 代码\n\t\t\tvar start = new Date();\t// 开始时间\n\t\t\t// 意图放入1000个li标签到ul中\n\t\t\tfor(var i = 0; i < 1000; i++) {\n\t\t\t\tstr += \"<li>\" + Math.random() + \"</li>\";\n\t\t\t\tlist.innerHTML = str;\n\t\t\t}\n\t\t\tvar end = new Date();\t// 结束事件\n\t\t\tconsole.log('耗时：' + (end - start));\n\n\t\t}\n\t\tbtn2.onclick = function(){\n\t\t\t// 先将ul中的所有内容（元素）清掉\n\t\t\tlist.innerHTML = '';\n\t\t\tvar start = new Date();\t// 开始时间\n\t\t\t// 意图放入1000个li标签到ul中\n\t\t\tfor(var i = 0; i < 1000; i++) {\n\t\t\t\tvar li = document.createElement('li');\n\t\t\t\tli.innerText = Math.random();\n\t\t\t\tlist.appendChild( li );\n\t\t\t}\n\t\t\tvar end = new Date();\t// 结束事件\n\t\t\tconsole.log('耗时：' + (end - start));\n\t\t}\n\t</script>\n\n```\n\n### 打折案例\n\n```html\n<button id=\"btn1\">打8折！</button>\n\t<ul id=\"list1\">\n\t\t<li oldPrice=\"222\"><span>产品1</span><span></span><span></span></li>\n\t\t<li oldPrice=\"414\"><span>产品2</span><span></span><span></span></li>\n\t\t<li oldPrice=\"244\"><span>产品3</span><span></span><span></span></li>\n\t\t<li oldPrice=\"513\"><span>产品4</span><span></span><span></span></li>\n\t\t<li oldPrice=\"144\"><span>产品5</span><span></span><span></span></li>\n\t</ul>\n<script>   \n    var btn1 = document.querySelector('#btn1');\n    var ul= document.querySelector('#list1');\n      var lii = ul.children;   //获取ul里面的li\n       //1.初始显示原价\n    for(var i = 0;i < lii.length;i++){\n         \t\tvar oldPrice = list[i].getAttribute('oldPrice');\n\t\t\t// 当前 li 中的第2个span\n\t\t\tvar span2 = list[i].children[1];\n\t\t\tspan2.innerHTML = \"，原价 <del>¥\" + oldPrice + \"</del>\";\n\t\t}\n    btn1.onclick = function(){\n\t\t\tfor(var i = 0; i < list.length; i++){\n\t\t\t\t// 先取出当前li的oldPrice这个自定义属性的值（原价）\n\t\t\t\tvar oldPrice = list[i].getAttribute('oldPrice');\n\t\t\t\t// 当前 li 中的第3个span\n\t\t\t\tvar span3 = list[i].children[2];\n\t\t\t\tspan3.innerHTML = \"，折后价 <del>¥\" + (oldPrice*0.8).toFixed(2) + \"</del>\";\n\t\t\t}\n\t\t}\n    }\n</script>\n```\n\n","tags":["HTML"],"categories":["Web前端"]},{"title":"js基础(argment)","url":"/38486/","content":"**1.argment:**在函数中获取参数的信息----------[个数、值]  \n\n(注:无法确定用argment,明确用形参(ps:缩写)      ps: 本质上是个函数  \n\n| **全局变量: **       | **局部变量:**                | **作用域链**     |\n| -------------------- | ---------------------------- | ---------------- |\n| 可以在任何作用域使用 | 可以用return返回值(达到全局) | 连接两个作用域链 |\n\n**获取对象中的值:** \n\n1.对象名.属性名 \n\n2.对象名['属性名']     <!--more-->\n\n**执行对象方法:**\n\n 1.对象名.方法名 \n\n2.对相名 [' '] ()\n\n**new关键字:**\n\nnew就是调用构造函数,创建对象.\n\n**代码的预读:**\n\n 变量提升 和 函数提升(不包含调用函数). \n\n  [注:预解析后:先提升函数在提升变量]\n\n### 4种创造对象的方式\n\nObject:对象 --------操作对象(取值、赋值)对象是个容器.                                           \n\n **组成:**\n\n 1.属性 2.方法                                             \n\n **☞ 字面量**---创造单个 \n\n```js\n var 对象名 = { \n 属性 : 值 , (最后一个值不加逗号.) \n 方法 : 自定义 : function()\n {\n ('_')\n } \n    }   \n```\n\n  **☞ js内置的构造函数**--- 创造单个    \n\n```js\n var 对象名 = new Object();           \n[注:Object():js中内置好的函数]     \n```\n\n**☞ 工厂方式**--- 适用于批量创建 \n\n```js\nfunction fn(name) {  \n    var 对象名 = new Object(); \n    对象名.属性;  return  对象名\n} \n```\n\n​             \n\n**☞ 自定义构造函数创造**----批量创建 \n\n```js\n    function fn () {\n        this.属性名= 值\n    }   \n[注:首字母大写]\n```","tags":["js"],"categories":["Web前端"]},{"title":"CSS高级用法","url":"/21835/","content":"\n###                              **CSS高级用法**\n\n   **核心知识点**\n\n###  **2D转化及相关属性[重要]**\n\n<!--more-->\n\n1.  ```css\n   基本语法:                 transition:all .5;[过度动画]\n   旋转:\n   transform:rotate(deg/*度*/)  正顺负逆默中心\n   tranform-origin/*改变旋转中心点*/   绕点旋转\n   具体坐标 | \n   缩放:\n   tranform:scale(x (w), y (h));  倍数 \n   scale()中设置的值表示的是一个倍数,没单位\n   scale()中设置的值如果大于0且小于1, 缩小\n   scale()中设置的值大于1, 放大\n   scale()中设置的值等于1, 不变 \n   scale()中设置的值等于0,该宽高等于0\n   scale()中设置的值可以设置一个,宽和高的倍数\n   scale()中不能设置负数\n   注:如果页面中元素要同时设置多个tranform属性的时候,tranform属性要合写[防层叠]\n   位移:\n   x轴:水平,左向右为正\n   y轴:垂直,上向下为正\n   tranform:tranlate(x,y);\n   中第一个值代表水平方向位移,第二个值代表垂直方向位移\n   \n   补充:线性渐变\nbackground-image: linear-gradient( /* 渐变的方向 */ to right, #34c2aa, #6cd557 /* 使用角度的方式渐变 */ /* 135deg, red, blue */ );\n   \n   ```\n\n###  **3D转换**\n\n```css\n\n语法:\n   tranform:tranlateX(值) /*x必须大写*/可以设置百分比\n   tranlateX只能让元素沿着水平方向位移\n           可以设置负数,沿水平相反的方向位移(从右往左)\n           可以设置百分比,百分比是相对于当前元素的宽度\n   Y\n   \n   Z\n   prespective: 透视在浏览器中出现近大远小的效果  (透视:推荐值-->600--1000)\n   prespective属性设置:给tranform属性的父元素添加\n   总结:\n   \n   \n   旋转:\n       加个坐标轴\n       x  正往我这边  \n      Y 正往右  开门\n      z 于2d转换效果一样\n   总结:如果元素沿着x轴旋转,x轴默认中间位置\n\n   3d改旋转轴 tranSform-origin\n             tranSform-origin:left;轴\n   缩放:\n   tranSporfm: scale()\n   \n   转化样式平面转立体\n   transform-style:preserve-3d;\n   \n```\n\n\n\n### **animation属性**\n\nanimation--动画自动播放 ,动画次数可以无限次执行\n\ntransition---    动画需用户动作,动画随着用户动作的取消\n\n```css\n@keyframes name {\n       /*设置动画在开始时候的样式*/\n       from {\n               \n            }\n            /* 动画开始后的一个效果 */\n            to {\n               \n            }\n}\nanimation-name:调用动画名称\nanimation-dyration:设置动画时间\nanimation-iteraton-count:设置动画次数 infinite;无限次执行\nanimation-direction:alternate; 逆播\nanimation-timing-function:;速度默认值ease | linear匀速\nease-in 加速 | ease-out 减速 |ease-in-out\nanimation-fill-mode:forwards;让动画在结束位置停止[条件不能设置无限次数]\nanimation-delay:设置动画延迟时间\n\nanimation复合属性:\n1.设置  animation -name\n2 设置 animation-duration\n```\n\n\n\n","tags":["CSS"],"categories":["Web前端"]},{"title":"HTML基础（二）","url":"/53683/","content":"##                                    **第二天**\njson  更改          \n\n表格:跨行(rowspan)是竖着[从上往下夸]   跨列(colspan)横着\n\nctrl  f  查找\nctrl   s   保存\nauto rename tag 插件\n按住滚轮往下b\n\n<!--more-->\n\ndl 自定义列表  \n\ndt  文字类标签\n\ndd   并列","tags":["HTML"],"categories":["Web前端"]},{"title":"bootstrap框架","url":"/5390/","content":"\n### bootstrap框架\n\n1.为了快速实现响应式布局和移动端页面为主.\n\n2.全局样式[网页中常见标签的基本样式设置]\n\n栅格系统[为实现响应式布局的]-------媒体查询\n\n<!--more-->\n\n**☞下载**(css文件)\n\n **生产环境**:压缩,快速开发,并不适合学习\n\n**源码**:手写,没压缩\n\n**使用**---引用\n\n语义标签-----(忘了)\n\n### **全局标签**(最好刚刚不要使用...)\n\n```css\n标题标签(可以直接写标签名字 | 对应类名)\n表示超小文字(可以使用small标签 | 对应的类名)\ntext-capitallizr //*首个字母大小\n.text-capitalize\n\n```\n\n### **栅格系统**             odd奇数   even偶数\n\n```css\n作用:用来实现响应式布局,通过将设备(视口)分为12列\n```\n\n```css\n使用:\n1.引用bootstrap.css文件  [用一个就行]\n2.给父元素容器设置container[固定居中]或者container-fluid[满屏]\n3.只要给盒子设置了****或者***类名后就会分为12列\n4.通过栅格参数实现响应式布\n```\n\n```\n.col-md ---->适配电脑屏幕\n.col-sm ---->适配平板设备\n.col-xs ---->适配手机设备\n.col-lg ---->适配大屏幕设备  2000px(或者1200px)?忘了\n```\n\n可以给 *加边框,也可以加padding值","tags":["HTML"],"categories":["Web前端"]},{"title":"DOM模型","url":"/42423/","content":"\n\n#                    DOM模型\n\n### JavaScript由以下三部分构成\n\n1.ECMAScript  2.Bom（浏览器对象） 3.Dom（文档对象）\n\n```js\n注：<script>放在body的最后面\n```\n\n<!--more-->\n\n##### 术语\n\n1.文档（document）\n\n```文字\n注：1.语法 2.注意大小写3.样式不加-4.多加或少加单引号''\n```\n\n 2.节点（了解）\n\n```CN\n构成网页的所有组成部分，在js中都被成为节点。\n节点类型：①标签节点②属性节点③文本节点\n节点属性：①nodeType节点类型②nodeName节点类型③nodeValue节点值\n```\n\n注：节点本身就是对象。\n\n元素节 == 标签名    属性节 == 属性名  文本节 == #text    value == null(空)\n\n3.元素\n\n```cn\n就是html中的标签，在js中称为元素或对象，是节点的一种，也称为元素节点\n```\n\n##### Dom编程的基本理解\n\n```cn\n在js代码中获取到网页中的有关标签（元素），并对其进行某种操作。\n```\n\n### DOM模型\n\n##### 如何获取元素\n\n```js\n根据ID名获取元素 ------document.getElementByid（'id名'）【结果是该id所对应的元素（对象/节点）】\n\n根据标签获取元素 ------document.getElementsByTagName（'标签名'）【结果是一个'集合'（伪数组）】\n|注意：标签获取即使只获取一个元素，也是一个伪数组，也是集合，也要用下标去获取|\n    \n根据类名获取元素 ------document.getElementsByClassName（'类名'）【结果是一个'集合'（伪数组）】\n\n               ------document.querySelector('选择器')【结果是该选择器所对应的第一个元素（对象/节点）】\n根据选择器获取元素\n               ------document.querySelectorAll('选择器')【结果是一个'集合'（伪数组）】\n```\n\n#####  元素（节点）关系获取元素\n\n```js\nxx元素.parentNode--------【获取到某元素的父元素】\nxx元素.children---------【获取到某元素的所有子元素，是一个集合】\nxx元素.firstElementChild--------【获取到某个元素的第一个子元素】\nxx元素.lastElementChild--------【获取到某个元素的最后一个子元素】\nxx元素.nextElementSibing-------【获取到某个元素的后一个兄弟元素】\nxx元素.previousElementSibing------【获取到某个元素的前一个兄弟元素】\n```\n\n#####   添加元素\n\n```js\n创建元素-----var 变量 = document.createElement（'标签名'）\n|注：创建的元素以内存变量的形式，未放入页面中|\n\n克隆元素-----var 变量 = xx元素.cloneNode（true/false）【true表示同时克隆该元素的所有内部内容。false表示不克隆该元素的内部内容】\n\n添加元素到父元素中的最后位置------xx父元素.appendChild（xx要添加的元素）【结果该新添加的元素成为了父元素的最后一个子元素】\n\n添加元素到父元素中的某个元素之前-----xx父元素.insertBefore（xx要添加的元素，xx现有的元素）【结果该新添加的元素成为了父元素的一个子元素，并在指定的子元素前】\n\n替换某个现有元素------xx父元素.replaceChild（xx新，xx旧）【结果就是新的元素替换了所给定的现有子元素】\n```\n\n#####     删除元素\n\n```\n父元素.removeChild（子元素）\n```\n\n","tags":["js"],"categories":["Web前端"]},{"title":"less补充","url":"/56427/","content":"\n###                               **less补充**\n\n**引入less**:\n\n```css\n1.通过link引入less文件\nEg: <link rel=\"stylesheet/less\"  href=\"css/less\" >\n2.需要在网页中引入less.js文件\nEg:<script src=\"less.js\"> <script>\n3.需要在服务器环境下执行\n```\n\n","tags":["less"],"categories":["Web前端"]},{"title":"rem适配","url":"/11594/","content":"\n###                               **rem适配** [vw]\n\n### **移动端方式**          补:opacity: 透明颜色;\n\n 1.**流式布局(百分比布局)**2.**伸缩布局(弹性布局)**3.**响应式布局(媒体查询)**\n\n4.**rem适配:**让元素(内容)随着设备的宽度改变,自己发生大小的改变\n\n```css\n计算移动端中根标签[html]文字大小=当前设备宽度(动态获取)/缩放的倍数 \n媒体查询----定义一个变量\n```\n\n```css\n计算ui图片中测量元素的rem值=测量大小/(ui图大小/缩放倍数)\nrem值是根据根(html)标签的文字大小来设置的\n```\n\n​      **注:** UI 图中缩放的倍数必须和设备中缩放的倍数统一\n\n@size是什么? <!--more-->\n\n#### **补充:** **为什么页面适配要使用rem而不是em?**\n\n  1.rem在适配的时候是相对html中的文字大小\n\n   2.html中的文字大小不会影响某个具体标签中的文字大小(继承的权重为0)\n\n   3.rem适配最重要的一步就是要保证html中设置文字的大小\n\n~~**注:**保证当前标签中文字大小是30px 又要保证当前标签的宽度是400px~~\n\n UI 640px ----20倍   750px----25倍\n\n**em:**相对单位,em是相对当前标签中文字大小\n\n**rem:**相对单位,r(root),rem单位是相对html根标签中文字的大小\n\n","tags":["HTML"],"categories":["Web前端"]},{"title":"事件对象event属性","url":"/11960/","content":"##     事件对象event属性                                                                                                  \n\n###  事件对象的使用方法\n\n处理函数定义是作为函数的第一个形参,就代表event对象:\n\nenter编码13  \n\n```html\nxx元素.onxx事件 = function(e){\n //在此函数中,e就代表event对象\n}\n```\n\n或\n\n```html\nxx元素.addEventListener('xx事件',function(e)){\n//在此函数中,e就代表event对象\n}\n```\n\n或 <!--more-->\n\n```\nxx元素.onxx事件= func1;\nxx元素.addEventListener('xx事件',func1);//特别注意:这里只要写也只能写函数名称\nfunction funcl1(e){\n// 在此函数中， e 就代表 event对象\n}\n```\n\n### 事件对象event的属性\n\nevent.target\n\n  ++- 代表当前直接触发事件的元素本身\n\nthis对比：\n\n代表事件发生时绑定了当前事件的元素\n\n●event.type\n\n代表当前事件类型,其实就是事件的名称,\n\n●event.clientX,event.clientY\n\n代表事件发生时鼠标在当前窗口可视范围的位置\n\n仅仅只对鼠标事件有效\n\n●event.pageX,ebent.pageY\n\n代表事件发生时鼠标在页面文档范围的位置\n\n仅仅对鼠标事件有效\n\n●event.keyCode()\n\n代表键盘事件ain发生是所按下的按键的按键码,是一个数字\n\n仅仅对键盘事件有效\n\n### 事件对象event的方法\n\n●even.preventDefault()\n\n取消事件的默认行为,\n\n所谓默认行为，是指一个元素发生某个事件时，默认会产生的结果（行为）。","tags":["js"],"categories":["Web前端"]},{"title":"如何有效阅读一本书（一）","url":"/41380/","content":"## 如何有效阅读一本书（一）\n\n**1.随想笔记:记录平时的感悟,这与日后的选书息息相关.**\n\n      【注:a.可以书写任何内容 b.按时间顺序书写  c.附上日期 d.灵活运用速记或略记 e.可以粘贴 】\n\n**2.购书清单:找到真正想读的书.**\n\n  **[注:选书.购书.读书和活用才是读书的完整流程] (归档.....)**     \n\n> ​         **|书名、作者与出版社名.|       标注:所谓读书的动机或目的性,就好比照片的'焦点'.即使拍摄同样的场景,聚焦于面前的花朵和聚焦于远处的建筑,得到的效果完全不同.读书也一样,抱着不同的目的阅读同一本书,也会产生截然不同的效果.**\n\n**3.各种报道的剪报:尽情的收录感兴趣的内容.**\n\n**4.读书笔记:将读后感转变成文字保存下来.**<!--more-->\n\n**5.养成习惯**\n\n**6.放大读书笔记的作用.**\n\n**7.创造别具一格的记录方式**\n\n**8.信息一元化(读书一元化)**      \n\n```文字\n 【注:①简单易懂.人人都能做到       ②更容易坚持.       ③自由度高,可自行设置      ④信息'存在'于同一个地方       ⑤直接记录.参考.不易混肴.        ⑥因为'杂乱无章',所以便于活用】\n```\n\n**杂:绫辻行人的钟表馆事件.远宁的八声甘州以及岛田庄司系列和江户川乱步系列.     --新星出版社--**     **~~ps:听说他们家的纸不是很好 :）~~**   ","tags":["我的读书笔记"],"categories":["笔记"]},{"title":"less","url":"/39529/","content":"\n###                       **less**        **less.bootcss.com/#**\n\n**less去写css代码优势:**\n\n1.less中可以进行数字运算\n\n2.less中可以支持选择器中嵌套选择器\n\n   **less使用步骤:**\n\n1.新建less文件\n\n​     ☂ 文件名以less结尾\n\n2.less按照css语法编写\n\n​       ☂ less文件中完全可以使用css原生的语法去写\n\n <!--more-->\n\n3.less语法\n\n​      ☂  **less嵌套语法**(只适用嵌套结构的标签)\n\n```less\n.nav{\n    li{\n        \n    }\n}\n```\n\n​       ☞**支持数学运算**\n\n​       ☞**支持变量的设置**(如果某个值是一个变化的值,那么就可以将改制保存到变量中)\n\n```less\n@div_width: ***;\n```\n\n​        ☞less混合写法\n\n```less\n//less中的函数 [类似于css中的公共样式]\n#abc(){\n    color:red;\n    font-size:20px;\n}\n例如:\n.public(){\n    width:300px;\n    height:300px;\n    background-color:skyblue;\n}\n.one{\n    color:red;\n    .public()\n}\n.two{\n    color:black;\n    .public()\n}\n\n```\n\n","tags":["less"],"categories":["Web前端"]},{"title":"js（一）","url":"/19640/","content":"##   **js**  \n\n```JavaScript\n行内式:  学习阶段\n1.先准备一个html\n2.在html页面中任何一个位置,添加一个<script></script>标签 \n3.对应代码\n```\n\n```JavaScript\n外联式:   大项目\n1.单独一个js文件 .js\n2.在js文件直接写对应的js代码\n3.通过<script src=\"js文件路径\"> </script>----引用js文件\n```\n\n> ```js\n> 当前一个值是变量不需要加单引号....\n> console.log('要展示的信息');控制台\n> 注意:\n> 1.在程序中遇到的任何一个特殊符号,都必须是英文输入法的符号\n> 2.\n> 9.alert('新窗口'); 弹出窗口\n> \n> \n> \n> 3.document.write('展示信息');网页\n> \n> 4. 获取用户输入信息\n> prompt('提示用户要输入的信息');  \n> \n> \n> ```\n\n### 变量:  \n\n<!--more-->\n\n```js\n作用:在程序中保存数据的一个容器\n\nvar 自定义变量名 \n\n注:\n1.定义必须写var\n\n写法:\nvar 变量名 = 值;\n注意: '=' 叫赋值运算 '=' 右侧的结果 赋值给 左侧变量 \nvar kid = prompt ('请输入摄氏度')\nalert ()\n```\n\n变量的命名规范:\n\n .变量名在合法的时候一定的语义\n\n1. **字符必须是字母、 数字或下划线**  \n\n.不能用的(var变量名---关键字不能作为变量名)    (数字不能作为变量名)  (变量中间不能出现空格) (汉字不能作为变量名)     (不建议直接使用name) (不建议使用js的**保留字**)\n\n Number---->数字\n\n​    1.arseInt--->整数类型\n\n2,parseFloat --->浮点类型\n\nboonlen类型\n\nstring 类型\n\n如果布尔类型的false转化为数字类型后数字是0\n\n​                           true 转化为1\n\nundefined类型\n\n\n\n","tags":["js"],"categories":["Web前端"]},{"title":"HTML+CSS+JS代码规范","url":"/22143/","content":"## HTML+CSS+JS代码格式规范\n\n## 1.为什么要按照规范写代码\n\n> #### ☞代码规则\n>\n> ```html\n> 编译器在编译时就会报错，这个规定叫作规则\n> ```\n>\n> #### ☞代码规范\n>\n> ```html\n> 有一种规定，它是一种人为的、约定成俗的，即使不按照那种规定也不会出错，这种规定就叫作规范\n> ```\n>\n> #### ☞代码规范化的好处\n>\n> ```\n> 规范的代码可以减少bug处理，规范的代码可以降低维护成本，规范的代码有助于代码审查。\n> ```\n\n <!--more-->\n\n## 2. HTML代码规范介绍\n\n#### 1.嵌套元素应当缩进一次（即两个空格）\n\n```html\n<div>\n\t<p></p>\n</div>\n```\n\n#### 2.对于属性的定义，确保全部使用双引号，不要使用单引号。\n\n```html\n<div class=\"username\"></div>\n```\n\n#### 3.单标签中不要添加‘/’结束\n\n```html\n<br> \n备注： html5中提示可以加可以不加\n```\n\n#### 4.不能省略双标签的结束的标签\n\n```html\n<div></div>\n```\n\n#### 5.在引入CSS文件和JS文件时候，不需要指定type属性\n\n```html\n<style></style>\n\n<script></script>\n\n备注：type属性属于以上标签的默认值\n```\n\n#### 6.标签使用过程中，要遵循标签的语义化\n\n#### 7.标签设置属性的时候，要按照顺序依次设置，保证代码易读性\n\n```html\n<div class=\"\"  id=\"\"  name=\"\"></div>\n```\n\n## 3.CSS代码规范介绍\n\n#### 1. 为了代码的易读性，在每个声明块的左花括号前添加一个空格，且单独成行\n\n```CSS\n选择器 {\n    \n}\n```\n\n#### 2.每条声明语句的：后应该插入一个空格,且以封号结束\n\n```css\n选择器 {\n    color: red;\n}\n```\n\n#### 3.避免为 0 值指定单位\n\n```css\n选择器 {\n    margin: 0;\n}\n```\n\n#### 4. 声明顺序\n\n```css\n1. 定位\n2. 盒子模型\n3. 其他内部属性\n\n例如：\ndiv {\n    position: absolute;\n    left: 0;\n    top: 0;\n    \n    width: 200px;\n    height: 200px;\n    \n    font-size: 12px;\n    text-align: center;\n}\n```\n\n#### 5. 选择器\n\n```\n1.优先选择类选择器，有利于渲染性能优化\n2.选择器层级不能太高，最多不要超过3个\n```\n\n## 4.js语法规范\n\n> ##### ☞定义变量后要空行,在定义变量的同时初始化该变量\n>\n> ```javascript\n> var num = 123;\n> ```\n>\n> ##### ☞函数名之后不要留空格\n>\n> ```javascript\n> function fn() { }\n> ```\n>\n> ##### ☞单目运算符 !、~、++、－－、－、*、& 等前后不加空格\n>\n> ##### ☞声明数组使用[]\n>\n> ```js\n> var ary = [];\n> ```\n>\n> ##### ☞通常能用CSS实现的效果要避免使用JS来实现\n>\n> ##### ☞变量要使用驼峰命名法，使用名词结构\n>\n> ```javascript\n> var userName = 'zs'\n> \n> 备注：\n> \t1. 首字母小写，后面单词首字母大写\n> ```\n>\n> ##### ☞构造函数使用帕斯卡命名法\n>\n> ```javascript\n> function Person() {}\n> 备注：\n> \t1. 所有单词都以大写字母开始\n> ```\n>\n> ##### ☞对象属性命名必须唯一\n>\n> ```javascript\n> var obj {\n>     age: 12,\n>     height: 170\n> }\n> ```\n>\n> ##### ☞在同一个作用域下，变量名和方法名不要重复\n>\n> ```javascript\n> var fn = 12;\n> function fn() {}\n> ```\n>\n> ##### ☞每一个方法之间空一行\n>\n> ```javascript\n> function fn() {}\n> \n> function fn1() {}\n> ```\n>\n> ##### ☞运算符前后需要添加空格\n>\n> ```javascript\n> var a;\n> var b = a;\n> ```\n>\n> ##### ☞紧挨着圆括号内不需要加空格\n>\n> ```javascript\n> for(var i = 1; i <= 10; i++) {}\n> ```\n>\n> ##### ☞三目运算符用来进行条件性的赋值，不要用来当做简写的 if 语句使用。\n>\n> ```javascript\n>  var a =  a >= 10? a : 10;\n> ```","tags":["代码规范"],"categories":["Web前端"]},{"title":"1.1","url":"/48013/","content":"\n##              1.1\n\n1. 左侧边栏出来的话需要在同级别下\n\n2. common.css(公共样式{模块化}                                               )   \n\n3. 注:先引入初始化后引入公共样式\n\n4. 关于三大标签的SEO的优化:\n\n    titile标题      description网站说明(meta name=\"\"content=\"\")     keywoeds(关键字)\n\n5. 字体不一样不要给li设置宽高（关于竖线的需要单独的小li）\n\n6. 关于字体图标的用法\n\n7. logo SEO :  logo盒子 然后是h1 然后是a链接\n","tags":["1.1"],"categories":["Web前端"]},{"title":"知识点(一)","url":"/22082/","content":"\n##                    知识点\n\n​          1.display:none *与visitibility:hidden  前者不保留位置,后者保留位置\n\n​          2.额外标签法 overflow  伪元素法\n\n​          3.css3盒子模型border-box中,盒子的width包含了conter+border+padding(实际宽高)\n\n​         4.vertical-align:middle            vertical-align:top       vertical-align:bottom  \n\n​         5.绝对定位元素可以配合除静态定位之外的所有定位属性使用。\n\n","tags":["知识点"],"categories":["Web前端"]}]