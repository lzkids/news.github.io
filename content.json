{"meta":{"title":"My Life","subtitle":"","description":"","author":"唯獨少了個字","url":"http://kisskisso.com","root":"/"},"pages":[{"title":"Web前端","date":"2021-01-26T08:28:13.000Z","updated":"2021-01-26T08:30:10.000Z","comments":true,"path":"Web前端/index.html","permalink":"http://kisskisso.com/Web%E5%89%8D%E7%AB%AF/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2021-01-25T12:38:55.000Z","updated":"2021-01-25T12:43:06.000Z","comments":true,"path":"categories/index.html","permalink":"http://kisskisso.com/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2021-01-25T13:38:13.000Z","updated":"2021-01-25T13:41:32.000Z","comments":true,"path":"tags/index.html","permalink":"http://kisskisso.com/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"应用与插件","date":"2021-01-26T08:42:20.000Z","updated":"2021-01-26T08:42:46.000Z","comments":true,"path":"应用与插件/index.html","permalink":"http://kisskisso.com/%E5%BA%94%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"爱好心理学","date":"2021-01-26T08:43:19.000Z","updated":"2021-01-26T08:43:42.000Z","comments":true,"path":"爱好心理学/index.html","permalink":"http://kisskisso.com/%E7%88%B1%E5%A5%BD%E5%BF%83%E7%90%86%E5%AD%A6/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"生活与话","date":"2021-01-26T08:40:11.000Z","updated":"2021-01-26T08:40:40.000Z","comments":true,"path":"生活与话/index.html","permalink":"http://kisskisso.com/%E7%94%9F%E6%B4%BB%E4%B8%8E%E8%AF%9D/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"笔记","date":"2021-01-26T08:44:42.000Z","updated":"2021-01-26T08:45:04.000Z","comments":true,"path":"笔记/index.html","permalink":"http://kisskisso.com/%E7%AC%94%E8%AE%B0/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"算法与面试题","date":"2021-01-26T08:41:14.000Z","updated":"2021-01-26T08:41:54.000Z","comments":true,"path":"算法与面试题/index.html","permalink":"http://kisskisso.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"语言与Linux","date":"2021-01-26T08:38:14.000Z","updated":"2021-01-26T08:39:36.000Z","comments":true,"path":"语言与Linux/index.html","permalink":"http://kisskisso.com/%E8%AF%AD%E8%A8%80%E4%B8%8ELinux/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"如何更新hexo和插件版本","slug":"如何更新hexo和插件版本","date":"2021-01-31T12:15:32.000Z","updated":"2021-01-31T12:33:42.963Z","comments":true,"path":"2021/01/31/如何更新hexo和插件版本/","link":"","permalink":"http://kisskisso.com/2021/01/31/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0hexo%E5%92%8C%E6%8F%92%E4%BB%B6%E7%89%88%E6%9C%AC/","excerpt":"","text":"自动更新—-进入博客根目录运行npm update 手动更新—-进入博客根目录运行npm outdated 运行后查看Hexo和插件的最新版本然后修改根目录下的package.json将对应的插件名和Hexo对应的版本号更新为要更新的版本号 开始更新—-npm install --save 查看版本号—-hexo version","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"vim下方向键无法移动光标","slug":"vim下方向键无法移动光标","date":"2021-01-31T09:54:08.000Z","updated":"2021-01-31T10:00:23.740Z","comments":true,"path":"2021/01/31/vim下方向键无法移动光标/","link":"","permalink":"http://kisskisso.com/2021/01/31/vim%E4%B8%8B%E6%96%B9%E5%90%91%E9%94%AE%E6%97%A0%E6%B3%95%E7%A7%BB%E5%8A%A8%E5%85%89%E6%A0%87/","excerpt":"","text":"方式一：可以使用【H左】【K上】【J下】【L右】移动光标修改 方式二：下载vim自动的vim是精简版sudo apt-get install vim","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Windows创建还原点","slug":"Windows创建还原点","date":"2021-01-31T09:26:34.000Z","updated":"2021-01-31T10:00:23.759Z","comments":true,"path":"2021/01/31/Windows创建还原点/","link":"","permalink":"http://kisskisso.com/2021/01/31/Windows%E5%88%9B%E5%BB%BA%E8%BF%98%E5%8E%9F%E7%82%B9/","excerpt":"","text":"创建系统还原点 Windows 10 在任务栏上的搜索框中，键入“创建还原点”，然后从结果列表中选择它。 在“系统属性”的“系统保护”选项卡上，选择“创建”。 键入有关还原点的描述，然后依次选择“创建”&gt;“确定”。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"hexo上传报错","slug":"hexo g报错","date":"2021-01-30T07:06:26.000Z","updated":"2021-01-30T10:14:47.793Z","comments":true,"path":"2021/01/30/hexo g报错/","link":"","permalink":"http://kisskisso.com/2021/01/30/hexo%20g%E6%8A%A5%E9%94%99/","excerpt":"","text":"​ 电脑死循环自启重置电脑后，安装node出错 (node:11276) Warning: Accessing non-existent property 'lineno' of module exports inside circular dependency (Use `node --trace-warnings ...` to show where the warning was created) (node:11276) Warning: Accessing non-existent property 'column' of module exports inside circular dependency (node:11276) Warning: Accessing non-existent property 'filename' of module exports inside circular dependency (node:11276) Warning: Accessing non-existent property 'lineno' of module exports inside circular dependency (node:11276) Warning: Accessing non-existent property 'column' of module exports inside circular dependency (node:11276) Warning: Accessing non-existent property 'filename' of module exports inside circular dependency node版本过高 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"GoodSync同步备份","slug":"GoodSync同步备份","date":"2021-01-30T01:00:43.000Z","updated":"2021-01-30T01:09:38.375Z","comments":true,"path":"2021/01/30/GoodSync同步备份/","link":"","permalink":"http://kisskisso.com/2021/01/30/GoodSync%E5%90%8C%E6%AD%A5%E5%A4%87%E4%BB%BD/","excerpt":"","text":"GoodSync是一款备份和文件同步程序。它用于在一台计算机上的两个目录之间，或计算机与另一个存储设备（如另一台计算机、可移动磁盘、闪存驱动器或智能手机）之间，或计算机与远程计算机或服务器之间同步文件。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"应用与插件","slug":"应用与插件","permalink":"http://kisskisso.com/categories/%E5%BA%94%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6/"}],"tags":[]},{"title":"Linux下如何切换root","slug":"Linux下如何切换root","date":"2021-01-29T12:16:13.000Z","updated":"2021-01-29T23:56:14.004Z","comments":true,"path":"2021/01/29/Linux下如何切换root/","link":"","permalink":"http://kisskisso.com/2021/01/29/Linux%E4%B8%8B%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2root/","excerpt":"","text":"如果想临时使用一下root权限，只需要在命令前面加上sudo如果想一直使用root权限，需要通过su切换到root用户：（不推荐一直使用） 重设root用户密码 sudo passwd root 根据提示，输入新root密码（不要和非root用户密码一样） 切换root用户 su 输入root用户密码 回到非root用户权限 使用su “yc”或者exit命令，回到用户权限 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"语言与Linux","slug":"语言与Linux","permalink":"http://kisskisso.com/categories/%E8%AF%AD%E8%A8%80%E4%B8%8ELinux/"}],"tags":[]},{"title":"Cmder配置WSL","slug":"Cmder配置WSL","date":"2021-01-29T11:17:58.000Z","updated":"2021-01-29T23:45:30.712Z","comments":true,"path":"2021/01/29/Cmder配置WSL/","link":"","permalink":"http://kisskisso.com/2021/01/29/Cmder%E9%85%8D%E7%BD%AEWSL/","excerpt":"在Windows下安装Linux子系统 使用Windows搜索打开控制面板–&gt;程序和功能–&gt;启用或关闭Windows功能–&gt;找到适用于Linux的Windows子系统打上√（等系统下载重新启动）如图 ps:如果找不到程序和功能，把右上角的查看方式换成大图标","text":"在Windows下安装Linux子系统 使用Windows搜索打开控制面板–&gt;程序和功能–&gt;启用或关闭Windows功能–&gt;找到适用于Linux的Windows子系统打上√（等系统下载重新启动）如图 ps:如果找不到程序和功能，把右上角的查看方式换成大图标 在Windows的应用商店下载你喜欢的Linux （LTS表示长期支持版本）我选的是Ubuntu 20.04 LTS如图 安装完之后，打开Ubuntu会让你输入name（必须英文）然后是密码（在输入密码的时候并不显示）和核对密码。输入完之后就成功了 在Cmder关联WSL（关联子系统） 需要下载并安装好Cmder ps：下载完整版Download Full 打开Cmder–&gt;右下角的三（或者win+Alt+p）–&gt;settings(第一次安装是英文版)–&gt;Interface language(切换中文)–&gt;启动–&gt;选择命令行（找到Ubuntu）如图 如果手动找不到，在文件管理搜索Ubuntu2004.exe（WindowsApp文件夹下的） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"WSL","slug":"WSL","permalink":"http://kisskisso.com/tags/WSL/"}]},{"title":"DeepLTranslate翻译","slug":"DeepLTranslate翻译","date":"2021-01-29T09:45:25.000Z","updated":"2021-01-29T10:55:36.564Z","comments":true,"path":"2021/01/29/DeepLTranslate翻译/","link":"","permalink":"http://kisskisso.com/2021/01/29/DeepLTranslate%E7%BF%BB%E8%AF%91/","excerpt":"","text":"DeepL是人工智能语言辅助，训练人工智能来理解和翻译文本。系统能快速、自动地识别语言，将单词转化为你想要的语言，并尝试添加特殊的语言细微差别和表达方式。拥有神经性网络。官网支持中文。支持网页翻译和客户端翻译下载地址 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"应用与插件","slug":"应用与插件","permalink":"http://kisskisso.com/categories/%E5%BA%94%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6/"}],"tags":[]},{"title":"推荐RSS网站","slug":"推荐RSS网站","date":"2021-01-29T08:02:09.000Z","updated":"2021-01-29T09:34:08.130Z","comments":true,"path":"2021/01/29/推荐RSS网站/","link":"","permalink":"http://kisskisso.com/2021/01/29/%E6%8E%A8%E8%8D%90RSS%E7%BD%91%E7%AB%99/","excerpt":"","text":"游戏时光头条：https://www.vgtime.com/rss.jhtml 青柠学术：https://iseex.github.io/feed.xml 少数派：https://sspai.com/feed 森林集：https://senlinjimore.com/archives/category/%25e8%25bd%25af%25e4%25bb%25b6/%25e7%2594%25b5%25e8%2584%2591/feed 数码荔枝：https://www.lizhi.io/feed/ 小众软件：https://www.appinn.com/feed/ 知乎日报：http://feedmaker.kindle4rss.com/feeds/zhihu-daily.xml 178动漫频道：http://acg.178.com/s/rss.xml 反斗软件：http://www.apprcn.com/feed 更新中…… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"应用与插件","slug":"应用与插件","permalink":"http://kisskisso.com/categories/%E5%BA%94%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"RSS","slug":"RSS","permalink":"http://kisskisso.com/tags/RSS/"}]},{"title":"如何删除鼠标右键的cmder","slug":"如何删除鼠标右键的cmder","date":"2021-01-29T03:39:43.000Z","updated":"2021-01-29T07:13:22.000Z","comments":true,"path":"2021/01/29/如何删除鼠标右键的cmder/","link":"","permalink":"http://kisskisso.com/2021/01/29/%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE%E7%9A%84cmder/","excerpt":"如何删除鼠标右键选项的cmder（或其他添加到文件目录中的应用） 1.打开注册表设置（打开方式：直接搜索“注册表”或者win + r → regedit）","text":"如何删除鼠标右键选项的cmder（或其他添加到文件目录中的应用） 1.打开注册表设置（打开方式：直接搜索“注册表”或者win + r → regedit） 2.找到HKEY_CLASSES_ROOT → Directory → Background → cmder（删除选项） 或者打开注册表之后，编辑 –&gt;查找 –&gt;输入cmder进行查找 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"入门oh-my-zsh","slug":"入门oh-my-zsh","date":"2021-01-28T12:05:34.000Z","updated":"2021-01-29T03:17:48.000Z","comments":true,"path":"2021/01/28/入门oh-my-zsh/","link":"","permalink":"http://kisskisso.com/2021/01/28/%E5%85%A5%E9%97%A8oh-my-zsh/","excerpt":"Oh-my-zsh是一个开源的、社区驱动的管理zsh的框架，它是免费的。它有超过180个可选的插件（rails、git……），超过120个主题和一个自动更新工具来保持oh-my-zsh的最新状态。 在本教程中，我将指导你在你的PC/笔记本电脑上安装它。最大的好处是你可以自定义你的Shell和添加插件。不像老式的Bash shell，它看起来并不吸引人，当你大量使用命令行工作时，会让你很难使用。 前提条件 Linux 和 macOS，因为 oh-my-zsh 在基于 Unix 的操作系统上工作得最好。 WSL(Windows Subsystem for Linux)也可以和oh-my-zsh一起工作。","text":"Oh-my-zsh是一个开源的、社区驱动的管理zsh的框架，它是免费的。它有超过180个可选的插件（rails、git……），超过120个主题和一个自动更新工具来保持oh-my-zsh的最新状态。 在本教程中，我将指导你在你的PC/笔记本电脑上安装它。最大的好处是你可以自定义你的Shell和添加插件。不像老式的Bash shell，它看起来并不吸引人，当你大量使用命令行工作时，会让你很难使用。 前提条件 Linux 和 macOS，因为 oh-my-zsh 在基于 Unix 的操作系统上工作得最好。 WSL(Windows Subsystem for Linux)也可以和oh-my-zsh一起工作。 zsh必须是预装的，在OSX中，它已经被预装了。在OSX中，它已经被预装了。在 Linux 中，你需要在终端中输入命令来安装。 curl或wget必须安装. 对于Debian/Ubuntu，你需要在终端输入命令：必须安装curl或wget。 sudo apt-get installl zsh 对于Fedora： sudo yum install zsh 下载oh-my-zsh 通过curl curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh 通过wget wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O - | sh 更改默认shell chsh -s /bin/zsh 对于某些操作系统，可能需要重新启动计算机才能生效。 更换终端主题 现在你已经成功安装了 oh-my-zsh。你需要改变适合你的主题，而不是使用默认的。要改变它，你需要修改.zshrc文件: vim ~/.zshrc 在本教程中，我使用的是vim文本编辑器，如果你喜欢可以使用其他的文本编辑器。接下来，在文件中找到这一行: ZSH_THEME=\"robbyrussell\" 把名字 “robbyrussell “改为另一个主题的名字。你可以看看这个网站上的所有可用的主题。 最后，只要重启终端，你就会看到不同的效果。 添加插件 在.zshrc文件中，你需要编辑以 “plugins “字样开头的一行: plugins=(git bundler osx rake ruby) 如果你喜欢，你可以添加更多或删除插件。要使用这些插件，大多数插件都有README文件，其中记录了如何使用它们。 自动补全与⬆ 在Bash shell中，你可以使用Ctrl + R和⬆来自动填写最近的和匹配的命令。 使用 oh-my-zsh，还有另一种方法：你可以输入你想要的命令的起始词，然后按 ⬆来循环浏览历史记录。 用Tab键自动完成 在Bash shell中，你可以输入关键字，然后按Tab键显示匹配命令列表，但是你需要在列表中循环并记住你想要的名称，并手动进一步输入以完成。 有了oh-my-zsh，事情就好办了，第一次按Tab键后，可以按第二次，允许在列表中循环，选择你想要的命令，然后它会自动填入剩下的单词，最后只要按Enter键就可以了。比如说： 第一次输入并按Tab键doc 2.第二次按Tab键，然后按Tab键进行上、下、左、右循环。 更新 oh-my-zsh 它会自动更新，但如果你想手动更新，只需在终端机上输入以下命令即可。 omz update document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"omz","slug":"omz","permalink":"http://kisskisso.com/tags/omz/"}]},{"title":"Linux入门指南-一","slug":"Linux入门指南-一","date":"2021-01-28T07:56:29.000Z","updated":"2021-01-28T08:53:40.000Z","comments":true,"path":"2021/01/28/Linux入门指南-一/","link":"","permalink":"http://kisskisso.com/2021/01/28/Linux%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E4%B8%80/","excerpt":"Linux 是什么？ Linux 是一个开源操作系统和 IT 基础架构平台。它由 Linus Torvalds 于 1991 年构思设计而成， Linux 的优点 跨平台的硬件支持 低资源占用下良好的稳定性 高效的文件系统 可靠的安全性","text":"Linux 是什么？ Linux 是一个开源操作系统和 IT 基础架构平台。它由 Linus Torvalds 于 1991 年构思设计而成， Linux 的优点 跨平台的硬件支持 低资源占用下良好的稳定性 高效的文件系统 可靠的安全性 完善纯净的软件包管理机制 随心所欲定制 UI 社区的支持 开源 哪些大众用户比较适合 Linux 桌面版？ 学习和探索 业余个人内容创作 极度重视安全和隐私 机器已经跑不动 Windows / macOS Linux 上软件有多少？ 网页版应用 支持同类网络传输协议的客户端 任务自动化服务 即时通讯软件内置的聊天机器人 Wine 兼容运行 Windows 应用 模拟器兼容运行 Android 应用 虚拟机软件模拟运行 macOS 或 Windows 系统 总结 Linux 因为其完全模块化的基理，干净得像水一样。水本身无固定的形态，它可以随环境而作出适应，让自己变成外物的形态。 所以，朋友，像水一样吧！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"语言与Linux","slug":"语言与Linux","permalink":"http://kisskisso.com/categories/%E8%AF%AD%E8%A8%80%E4%B8%8ELinux/"}],"tags":[]},{"title":"Hyper终端简单配置","slug":"Hyper终端简单配置","date":"2021-01-28T05:31:28.000Z","updated":"2021-01-28T11:53:44.000Z","comments":true,"path":"2021/01/28/Hyper终端简单配置/","link":"","permalink":"http://kisskisso.com/2021/01/28/Hyper%E7%BB%88%E7%AB%AF%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/","excerpt":"Hyper 是一个开源的、全平台适用的、有着丰富主题和插件的现代化终端。 打开之后是默认的cmd，更改顺序是左上角Edit—&gt;Preferences如图 打开之后是一个.hyper.js的文件找到shell，在引号内写入C:\\\\Windows\\\\System32\\\\bash.exe 如图","text":"Hyper 是一个开源的、全平台适用的、有着丰富主题和插件的现代化终端。 打开之后是默认的cmd，更改顺序是左上角Edit—&gt;Preferences如图 打开之后是一个.hyper.js的文件找到shell，在引号内写入C:\\\\Windows\\\\System32\\\\bash.exe 如图 当然前提是有子系统，更改主题找到plugins(在.hyper.js里) 填入你喜欢的主题 （hyperterm-monokai） 如果要切换zsh则需要在Preferences的shell在引号内写入C:\\\\Windows\\\\System32\\\\wsl.exe 和shellArgs: ['~']如图 下载插件 推荐这两个插件，其它插件 # hyper-opacity,解决windows下hyper原生不支持的窗口透明化 hyper i hyper-opacity # Hyper的扩展，可以打开电源模式，并有额外的哇模式。 hyper i hyperpower # 在 Hyper 终端启动之前和之后初始化命令的终极和最完整的扩展 hyper i hyper-init 在Hyper安装会报错，需要在管理员Windows PowerShell中下载或者管理员cmd中下载 安装成功如下图 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"应用与插件","slug":"应用与插件","permalink":"http://kisskisso.com/categories/%E5%BA%94%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"终端","slug":"终端","permalink":"http://kisskisso.com/tags/%E7%BB%88%E7%AB%AF/"}]},{"title":"子系统下不识别u盘","slug":"子系统下不识别u盘","date":"2021-01-28T05:03:53.000Z","updated":"2021-01-28T05:28:58.000Z","comments":true,"path":"2021/01/28/子系统下不识别u盘/","link":"","permalink":"http://kisskisso.com/2021/01/28/%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%B8%8B%E4%B8%8D%E8%AF%86%E5%88%ABu%E7%9B%98/","excerpt":"","text":"Windows下Linux不识别U盘的解决办法 在终端进入/mnt/ 在终端输入sudo mkdir /mnt/d然后紧接输入sudo mount -t drvfs D: /mnt/d 现在，能够访问D：驱动器的文件。如果卸载驱动器以便安全地将其卸载下时，运行以下命令：sudo umount /mnt/d 具体的内容请访问微软文档 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"windows10中的剪切版","slug":"windows10中的剪切版","date":"2021-01-27T12:31:49.000Z","updated":"2021-01-28T01:06:28.000Z","comments":true,"path":"2021/01/27/windows10中的剪切版/","link":"","permalink":"http://kisskisso.com/2021/01/27/windows10%E4%B8%AD%E7%9A%84%E5%89%AA%E5%88%87%E7%89%88/","excerpt":"","text":"Windows中的剪切板使用基于云的剪贴板从一台电脑上复制图像和文本并粘贴到另一台电脑上。你不仅可以重剪贴板历史记录中粘贴，还可以固定发现自己经常使用的项目。 若要随时访问剪贴板历史记录，请按 Windows 徽标键 + V。你还可以从剪贴板菜单中选择单个项来“粘贴”和“固定”常用的项。 若要在你的 Windows 10 设备之间共享剪贴板项目，请依次选择“开始”菜单 &gt;“设置” &gt;“系统”&gt;“剪贴板”。选择“跨设备同步”下的“自动同步我复制的文本”。同步功能与你的 Microsoft 帐户或工作帐户绑定，因此请记得在所有设备上使用相同的登录信息。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活与话","slug":"生活与话","permalink":"http://kisskisso.com/categories/%E7%94%9F%E6%B4%BB%E4%B8%8E%E8%AF%9D/"}],"tags":[]},{"title":"DirectoryOpus文件管理","slug":"DirectoryOpus文件管理","date":"2021-01-27T07:06:07.000Z","updated":"2021-01-27T07:28:50.000Z","comments":true,"path":"2021/01/27/DirectoryOpus文件管理/","link":"","permalink":"http://kisskisso.com/2021/01/27/DirectoryOpus%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/","excerpt":"","text":"DirectoryOpus DirectoryOpus 是 Win 平台上de1资源管理器，功能最完全、可定制化程度高。可以通过 DO 完成几乎所有操作，包括查看图片元信息、预览图片、阅读文本文件内容、批量重命名、操作压缩文件以及 FTP 同步请求等 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"应用与插件","slug":"应用与插件","permalink":"http://kisskisso.com/categories/%E5%BA%94%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"软件","slug":"软件","permalink":"http://kisskisso.com/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"小技巧","slug":"小技巧","date":"2021-01-27T06:50:41.000Z","updated":"2021-01-27T06:59:34.000Z","comments":true,"path":"2021/01/27/小技巧/","link":"","permalink":"http://kisskisso.com/2021/01/27/%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"","text":"小技巧 ☺笑容会给你带来一整天的灿烂。 别犹豫别放弃，保持速度，不要慢下来。 没有必要为了别人而改变，别人总有离开的时候。改变应该是自发而主动的。 改变你的思考模式。 变是为了让自己快乐，为了别人而改变，不会长久的。 改变外在是改变内心的途径之一。 别人的想法不重要，要尊重你自己的想法。 有意识的去改变，要知道自己在做什么。 可以改变很多次，一切都处于运动变化中。 坚持。养成一个新习惯至少需要21天。第一天非常难，后来就会越来越简单。 一个人都有缺点，请做独一无二的你。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活与话","slug":"生活与话","permalink":"http://kisskisso.com/categories/%E7%94%9F%E6%B4%BB%E4%B8%8E%E8%AF%9D/"}],"tags":[]},{"title":"如何改变自己(一)","slug":"如何改变自己-一","date":"2021-01-27T06:45:00.000Z","updated":"2021-01-28T00:19:12.000Z","comments":true,"path":"2021/01/27/如何改变自己-一/","link":"","permalink":"http://kisskisso.com/2021/01/27/%E5%A6%82%E4%BD%95%E6%94%B9%E5%8F%98%E8%87%AA%E5%B7%B1-%E4%B8%80/","excerpt":"如何改变自己 前言 大多数人会在某些时刻对自己的人生或者自我感到不满足。如果你意识到自己需要做出很大改变，那么你是幸运的。因为你有了这样的意识，就能够改变。重大的改变虽然令人望而生畏，但只要你目标明确、计划清晰就可以做到。行为上的改变，最终会带来对自身整体看法的改变。 一**.评估你的需求**。 1.发现问题。你决定要改变，原因和具体措施是什么？看清引起你改变的那个问题，分析问题是解决问题的必要前提。你要知道改变会带来哪些好处。 态度积极。列出你身上能被自我欣赏的优点，如果你觉得这很难，那就想想别人对你的评价，在改正坏习惯的过程中，你可以拿你的优点作为参照。","text":"如何改变自己 前言 大多数人会在某些时刻对自己的人生或者自我感到不满足。如果你意识到自己需要做出很大改变，那么你是幸运的。因为你有了这样的意识，就能够改变。重大的改变虽然令人望而生畏，但只要你目标明确、计划清晰就可以做到。行为上的改变，最终会带来对自身整体看法的改变。 一**.评估你的需求**。 1.发现问题。你决定要改变，原因和具体措施是什么？看清引起你改变的那个问题，分析问题是解决问题的必要前提。你要知道改变会带来哪些好处。 态度积极。列出你身上能被自我欣赏的优点，如果你觉得这很难，那就想想别人对你的评价，在改正坏习惯的过程中，你可以拿你的优点作为参照。 简单来说，就是得明确你想要什么，别人对你的期待不等同于你自己的追求，假如你本身不渴望改变，那改变自然也不会发生。 然后，列出你之所以想改变的原因，把原因写在纸上，当你看见时就会有动力，这能够让你坚持下去。 2.自我肯定。认可自己的积极面，以此强化你的核心价值观，你就可以不断靠近理想中的自己，当然盲目的自我肯定并没有用，因为这种盲目无法激发你的潜能，而切合实际的肯定，可以让你保持积极心态，进而促使你更好的解决问题，有效的自我肯定。有效的自我肯定示例： 用“我是”句式 用“我能”句式 用“我会”句式 3.将改变后的未来可视化。可视化是一种心理预演，帮助你设想一个不同的情景。抽象的可视化在脑海中进行，具体的可视化即收集一些和你的目标相关的图片。有效的可视化，帮你细化目标和调整目标。可视化还能培养你对环境和人生的控制力。操作步骤： 闭上眼睛。 想象理想中未来的自己，你在哪？在做什么？环境发生了什么变化？那时的你什么样？哪些变化让你感到快乐？ 试着探索理想中未来的细节。动用视觉，听觉，嗅觉，味觉去想象。细节具体化能够让可视化，更为真实。 运用积极的可视化帮你设立切实可行的阶段性目标。 4.好遇到障碍的准备。人生有很多事情无法预料，每一条改变之路都充斥着困难和别人的阻挠，那些困难和最终的成功相比都是小事，而且也终将被克服，你要坚信这一点，才能够成功。 切合实际是应对任何困难的最佳途径，遇到障碍时不要责怪别人或他人，因为阻碍是正常的，而且必然会发生。 5.表面的失败中学习。很多时候你会觉得自己失败了，你没有达成目标，你遭遇坎坷，你不得不改变目标，但请你记住，失败只是表面的，实际上失败意义的新机遇，从失败中学得宝贵的经验，学会灵活的调整目标，这样你会更快乐。 6.耐心。要是改变是轻而易举就能做到的，那就没有什么价值了，成果比你预想中来的慢，有时候旁人能够一眼看到你的改变和成果，只是你自己还不知道而已，你每天都有细微的改变，所以自己无法察觉，但改变的确发生了。 大目标分成小目标有益于对自己进行阶段性评估，每当达成一个小目标适当的奖励自己，这样你就可以保持前进的动力。 二.设立合理的目标。 1.在SMART法则指导下设立目标。定目标也是门艺术。目标定得好，才能够确保实现。SMART是5个英文单词首字母的集合，该法则是一个用于衡量目标的合理程度的有效工具。 具体（Specific）／重要（Significant） 可衡量（Measurable）／有意义（Meaningful） 可达成（Achievable）／基于行动（Action-oriented） 相关（Relevant）／基于成果（Results-oriented） 有时限（Time-bound）／可追踪（Trackable） 2.制定具体的目标。 也就是说目标要有针对性。假如目标过于宽泛，就难以据此制定实现目标的行动方案。 3.确保目标是可衡量的。 你得知道怎样算达成目标。要是无法判断目标实现与否，离现实还有多少距离，那样的目标是不可衡量的。 4.确保目标可达成。根据每个人的能力不同，因人而异。判断一个目标是否可达成，要考虑很多因素。有些因素是人为不可控的。需要考虑的是自己是否有足够的知识与技能去实现目标。判断该目标实现的可能性。 5.评估目标的相关性。这个标准对于阶段性目标来说，尤为重要。你的阶段性目标必须和总目标相关，并且逐步促进最终目标达成。不相关的目标对成功没有帮助。 6.设定达成目标的时间。 有效的目标应当有时限，否则努力就没有意义。 三.付诸行动。 1.从现在开始。 别总想着明天再说，而明天又拖到后天。停止拖延是改变的第一步。如果你战胜不了拖延，那就不会有所成。 2.把大目标分解为小目标。 总目标分解成阶段性目标，因为阶段性目标容易实现，带来的成就感使你继续努力的动力。 永远的目标让人望而怯步，你先不要想的太过遥远，专注于第1个阶段性目标。 尝试定制倒推式日程。从总目标的实现日期往前推算各阶段目标的达成日期，直到推及现在，在总时间既定的情况下，你可能需要调整几次日程安排或者必要时调整总时间。 用倒推的办法安排日程，能够帮你推算出第1步该做什么，万事开头难知道第1步做什么，以后就会越来越顺利。 3.奖励自己。 积极的看待自己的进步给予合理的奖励，这对于实现长远目标也很有帮助，放松一下。 但是奖励不该和目标相违背。 4.恰当运用情绪。 实现目标的过程中，你会有各种各样的情绪，这很正常，你需要学会借助这些情绪来促进目标的实现。 当你实现一个阶段性目标，你应该开心开心，会让你更有动力继续努力。 当你遇到困难你会感到沮丧，沮丧会让你更专注目标。 当你接近目标时突然遇到阻碍，你会愤怒，把愤怒转化为最后一搏的动力。 5.走出自己的舒适区。 多数人喜欢做自己喜欢的事，然而如果你想做出一个重大改变，你必须走出自身的舒适区，但是不要担心，不适感会给你带来新视角，助你成长。 我们要再次提及分解目标的好处。你觉得目标让人望而怯步时，你就先专注于实现第1个阶段性目标，这样能够减少畏惧。 向目标努力的过程中，试着走出自己的舒适区，这会让你开拓视野、增长经验、变得更积极。 四.回顾成绩 1.保持动力。在改变自我的过程中，你会遇到意料之外的阻碍，这些时刻要尤为小心恰当的应对，让自己保持正确的方向。 言出必行。 别让自己过于疲惫。 留意心理暗示。 找到志同道合的朋友。 2.记录并追踪感受。 记录自己的行为从中发现规律，以找到最有效的途径。 你发现自己总是退回老习惯，无法改变时，写下时间、原因和细节。分析可能的因素。 记录你的进步。如果这天你表现不错，写下来回顾自己的进步，会让你保持前进的动力。 3.保持健康。身体健康什么事都变得更容易，身体健康，不仅提高生活质量，而且有助于保持积极的心态。 合理饮食保证充足的睡眠，这是最基本的要求，毕竟改变自己和实现目标是很难的事情，你得用最佳的心理和身体状态来迎接挑战。 身体不好的时候先调整好自身的状态。健康快乐是第1位，其次才是想法和目标。 4.调整目标。 当你不断进步，在接近目标的过程中要不断调试，记录你的进步，据此调整计划，使它更适合你。 当你进步飞速时，可以制定更有挑战性的新目标。 如果你没有达到预期的成绩，不要自责，把目标调整的更为合理，别因挫败而放弃。 5.坚持。 当你实现了预期的结果，不要停止努力，新的习惯需要花时间来保持，让自己慢慢适应新状态。 让改变持续一生。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活与话","slug":"生活与话","permalink":"http://kisskisso.com/categories/%E7%94%9F%E6%B4%BB%E4%B8%8E%E8%AF%9D/"}],"tags":[]},{"title":"第三方评论Gittalk","slug":"第三方评论","date":"2021-01-26T07:58:24.000Z","updated":"2021-01-26T14:24:44.000Z","comments":true,"path":"2021/01/26/第三方评论/","link":"","permalink":"http://kisskisso.com/2021/01/26/%E7%AC%AC%E4%B8%89%E6%96%B9%E8%AF%84%E8%AE%BA/","excerpt":"前言 如何给博客集成Gittalk。Gittalk是基于GitHub Issue开发的评论插件，它是把GitHub 的issue集成在hexo博客中。 首先你的hexo主题支持Gittalk。然后就是有个GitHub账号。 配置Gittalk Register Application 在GitHub注册新应用登录GitHub-&gt;点击头像-&gt;Setting-&gt;Developer settings-&gt;OAuth Apps-&gt;New OAuth App顺序如图","text":"前言 如何给博客集成Gittalk。Gittalk是基于GitHub Issue开发的评论插件，它是把GitHub 的issue集成在hexo博客中。 首先你的hexo主题支持Gittalk。然后就是有个GitHub账号。 配置Gittalk Register Application 在GitHub注册新应用登录GitHub-&gt;点击头像-&gt;Setting-&gt;Developer settings-&gt;OAuth Apps-&gt;New OAuth App顺序如图 1. _config.yml 在主题配置文件xxx/_config.yml中按需添加内容： gitalk: enable: true githubID: github帐号 # 例：xxx repo: 仓库名称 # 例：xxxx.github.io ClientID: Client ID ClientSecret: Client Secret adminUser: github帐号 #指定可初始化评论账户 labels: 'gitalk' #GitHub issues的标签 distractionFreeMode: true 以上就是添加gitalk评论的配置，博客上传到GitHub上后，打开页面进入某一博客内容下，就可看到评论处。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Gittalk","slug":"Gittalk","permalink":"http://kisskisso.com/tags/Gittalk/"}]},{"title":"简悦插件","slug":"简悦插件","date":"2021-01-25T07:31:37.000Z","updated":"2021-01-26T10:06:46.000Z","comments":true,"path":"2021/01/25/简悦插件/","link":"","permalink":"http://kisskisso.com/2021/01/25/%E7%AE%80%E6%82%A6%E6%8F%92%E4%BB%B6/","excerpt":"","text":"简于型 · 悦于心 简悦 - 为你提供「如杂志般沉浸式阅读体验」的扩展,免费使用，但是有些功能需要高级会员才能使用 阅读模式 独有功能，通过提取 标题 · 描述 ·正文 · 媒体 图片 / 视频 等资源生成符合中文阅读习惯的页面，具有零干扰 · 沉浸式特点，适合深入阅读 聚焦模式 不改变当前页面的结构，仅仅高亮需要阅读的部分适合临时阅读或者未适配阅读模式的网站 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"应用与插件","slug":"应用与插件","permalink":"http://kisskisso.com/categories/%E5%BA%94%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"插件","slug":"插件","permalink":"http://kisskisso.com/tags/%E6%8F%92%E4%BB%B6/"}]},{"title":"Notion笔记软件","slug":"Notion笔记软件","date":"2021-01-23T06:22:46.000Z","updated":"2021-01-26T09:26:20.000Z","comments":true,"path":"2021/01/23/Notion笔记软件/","link":"","permalink":"http://kisskisso.com/2021/01/23/Notion%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/","excerpt":"Notion Notion是一款提供笔记、任务、数据库、看板、维基、日历和提醒等组件的应用程序。用户可以将这些组件连接起来，来创建自己的系统，用于知识管理、笔记记录、数据管理、项目管理等。这些组件和系统可以单独使用，也可以与他人进行跨平台协作。支持英语和韩语。官方消息说马上支持中文（还在本地化翻译）","text":"Notion Notion是一款提供笔记、任务、数据库、看板、维基、日历和提醒等组件的应用程序。用户可以将这些组件连接起来，来创建自己的系统，用于知识管理、笔记记录、数据管理、项目管理等。这些组件和系统可以单独使用，也可以与他人进行跨平台协作。支持英语和韩语。官方消息说马上支持中文（还在本地化翻译） 支持 谷歌插件 IOS &amp; Android谷歌插件 Mac &amp; Windows Web Clipper document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"应用与插件","slug":"应用与插件","permalink":"http://kisskisso.com/categories/%E5%BA%94%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"软件","slug":"软件","permalink":"http://kisskisso.com/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"SSH的建立","slug":"SSH的建立","date":"2020-09-22T13:43:42.000Z","updated":"2021-01-26T09:38:32.000Z","comments":true,"path":"2020/09/22/SSH的建立/","link":"","permalink":"http://kisskisso.com/2020/09/22/SSH%E7%9A%84%E5%BB%BA%E7%AB%8B/","excerpt":"","text":"ssh-keygen -t rsa -C \"youremail\" 然后一路回车，生成了.ssh的文件夹。在你的电脑中找到这个文件夹。 ~/.ssh/id_rsa.pub 打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便取一个都可以，把你的id_rsa.pub里面的信息复制进去。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"SSH","slug":"SSH","permalink":"http://kisskisso.com/tags/SSH/"}]},{"title":"CSS通用初始化","slug":"CSS通用初始化","date":"2020-09-12T14:30:15.000Z","updated":"2021-01-26T08:53:02.000Z","comments":true,"path":"2020/09/12/CSS通用初始化/","link":"","permalink":"http://kisskisso.com/2020/09/12/CSS%E9%80%9A%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96/","excerpt":"通用的CSS初始化（也许有用） 什么是css初始化？ CSS初始化是指重设浏览器的样式。不同的浏览器默认的样式可能不尽相同，所以开发时的第一件事可能就是如何把它们统一。如果没对CSS初始化往往会出现浏览器之间的页面差异。 为什么要初始化css？ 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。","text":"通用的CSS初始化（也许有用） 什么是css初始化？ CSS初始化是指重设浏览器的样式。不同的浏览器默认的样式可能不尽相同，所以开发时的第一件事可能就是如何把它们统一。如果没对CSS初始化往往会出现浏览器之间的页面差异。 为什么要初始化css？ 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。 /*css reset*/ /*清除内外边距*/ body, h1, h2, h3, h4, h5, h6, p, hr, /*结构元素*/ ul, ol, li, dl, dt, dd, /*列表元素*/ form, fieldset, legend, input, button, select, textarea, /*表单元素*/ th, td, /*表格元素*/ pre { padding: 0; margin: 0; } /*重置默认样式*/ body, button, input, select, textarea { /*font: 12px/1 微软雅黑, Tahoma, Helvetica, Arial, 宋体, sans-serif;*/ color: #333; font: 12px/1 \"Microsoft YaHei\", Tahoma, Helvetica, Arial, SimSun, sans-serif; } h1, h2, h3, h4, h5, h6 { font-size: 100%; font-weight: normal; } em, i { font-style: normal; } a { text-decoration: none; } li { list-style-type: none; vertical-align: top; } img { border: none; /*display: block;*/ vertical-align: top; } textarea { overflow: auto; resize: none; } table { border-spacing: 0; border-collapse: collapse; } /*常用公共样式*/ .fl { float: left; display: inline; } .fr { float: right; display: inline; } .cf:before, .cf:after { content: \" \"; display: table; } .cf:after { clear: both; } .cf { *zoom: 1; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://kisskisso.com/tags/CSS/"}]},{"title":"vue完整框架大建","slug":"vue完整框架大建","date":"2020-09-08T13:00:11.000Z","updated":"2021-01-26T09:45:32.000Z","comments":true,"path":"2020/09/08/vue完整框架大建/","link":"","permalink":"http://kisskisso.com/2020/09/08/vue%E5%AE%8C%E6%95%B4%E6%A1%86%E6%9E%B6%E5%A4%A7%E5%BB%BA/","excerpt":"1.用vue-cli生成项目 ​ 1.1 使用 vue create 创建一个项目 ​ 1.1.1在终端/cmd输入 vue create 项目名 ​ 1.1.2按下下方向键选择自定义配置 回车（Enter） 按 空格键 选择 Router、Vuex、CSS Pre-processors、Linter / Formatter 其它按照默认即可 。选好后 回车","text":"1.用vue-cli生成项目 ​ 1.1 使用 vue create 创建一个项目 ​ 1.1.1在终端/cmd输入 vue create 项目名 ​ 1.1.2按下下方向键选择自定义配置 回车（Enter） 按 空格键 选择 Router、Vuex、CSS Pre-processors、Linter / Formatter 其它按照默认即可 。选好后 回车 ​ 选择2.x版本（或按需选择）回车 输入y 回车 选择 Less 作为css预处理器 选择 Standard 代码风格 检查代码风格的时机：保存代码，提交代码 去做检查。 依赖的工具，每一个工具对应生成一个配置文件。而不是统一写在package.json中。 是否记录以上选择操作，方便下次快速创建。不记录，因为每次都不一样。 创建成功 2.了解结构目录 3.调整目录结构 需要调整src的目录结构，分工明确，代码可维护性更好。 src ├─api # 接口相关代码，axios相关代码 ├─assets # 静态资源，css images ... ├─components # 公用级别组件 ├─router # 路由相关代码 ├─styles # less相关代码 ├─utils # 全局工具模块相关代码 ├─views # 路由级别组件 └─App.vue # 根组件 └─main.js # 入口文件 4.安装常用的npm包 npm i axios # 一款基于Promise API 的HTTP客户端 https://github.com/axios/axios npm install mockjs # 生成随机数据，拦截 Ajax 请求 http://mockjs.com/ npm install moment --save # 一个轻量级的JS日期库，用于分析、校验、操作和格式化日期 http://momentjs.cn/ npm i --save lodash # 一款JS库，封装了很多有用的JS API https://lodash.com/ 带更新中….. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://kisskisso.com/tags/vue/"}]},{"title":"HTTP重定向","slug":"HTTP重定向","date":"2020-08-30T14:14:56.000Z","updated":"2021-01-26T09:05:48.000Z","comments":true,"path":"2020/08/30/HTTP重定向/","link":"","permalink":"http://kisskisso.com/2020/08/30/HTTP%E9%87%8D%E5%AE%9A%E5%90%91/","excerpt":"HTTP的重定向 One of the most common and largely overlooked vulnerabilities by web developers is Open Redirect (also known as “Unvalidated Redirects and Forwards”). 其中一个最常见的，也是大部分被网站开发者忽视的漏洞是开放重定向（也称为 “无效重定向和转发”）。 A website is vulnerable to Open Redirect when parameter values (the portion of URL after “?”) in an HTTP GET request allow for information that will redirect a user to a new website without any validation of the target of redirect.","text":"HTTP的重定向 One of the most common and largely overlooked vulnerabilities by web developers is Open Redirect (also known as “Unvalidated Redirects and Forwards”). 其中一个最常见的，也是大部分被网站开发者忽视的漏洞是开放重定向（也称为 “无效重定向和转发”）。 A website is vulnerable to Open Redirect when parameter values (the portion of URL after “?”) in an HTTP GET request allow for information that will redirect a user to a new website without any validation of the target of redirect. 当HTTP GET请求中的参数值（”? “后的部分URL）允许提供信息，将用户重定向到一个新的网站，而不对重定向的目标进行任何验证时，网站就会受到Open Redirect的攻击。 Depending on the architecture of a vulnerable website, redirection could happen after certain action, such as login, and sometimes it could happen instantaneously upon loading of a page. 根据易受攻击网站的架构，重定向可能会在某些操作后发生，如登录，有时也可能在页面加载时瞬间发生。 An example of a vulnerable website link could look something like this: https://www.example.com/login.html?RelayState=http%3A%2F%2Fexample.com%2Fnext 一个脆弱的网站链接的例子可能是这样的：: https://www.example.com/login.html?RelayState=http%3A%2F%2Fexample.com%2Fnext In this example, “RelayState” parameter indicates where to send user upon successful login (In our example it is “http://example.com/next\").If website doesn’t validate the “RelayState” parameter value to make sure that target web page is legitimate and intended, attacker could manipulate that parameter to send a victim to a fake page crafted by attacker: https://www.example.com/login.html?RelayState=http%3A%2F%2FEvilWebsite.com 在这个例子中，”RelayState “参数表示在用户成功登录后将用户发送到哪里（在我们的例子中是 “http://example.com/next\"）。如果网站没有验证 “RelayState “参数的值，以确保目标网页是合法的，攻击者可以操纵该参数，将受害者发送到一个由攻击者制作的虚假页面：https://www.example.com/login.html?RelayState=http%3A%2F%2FEvilWebsite.com。 Open Redirect vulnerabilities don’t get enough attention from developers because they don’t directly damage website and do not allow an attacker to directly steal data that belong to the company. However, that doesn’t mean that Open Redirect attacks are not a threat. One of the main uses for this vulnerability is to make phishing attacks more credible and effective. 开放式重定向漏洞没有引起开发者的足够重视，因为它们不会直接破坏网站，也不允许攻击者直接窃取数据，而这些数据是属于该公司。然而，这并不意味着Open Redirect攻击不构成威胁。这个漏洞的主要用途之一是使钓鱼攻击更加可信和有效。 When an Open Redirect is used in a phishing attack, the victim receives an email that looks legitimate with a link that points to a correct and expected domain. What the victim may not notice, is that in a middle of a long URL there are parameters that manipulate and change where the link will take them. 当开放重定向被用于网络钓鱼攻击时，受害者会收到一封看似合法的电子邮件，其中的链接指向一个正确的、预期的域名。受害者可能没有注意到的是，在长长的URL中间，有一些参数可以操纵和改变链接的位置。 To make identification of the Open Redirect even more difficult, redirection could take place after victim provides login on a legitimate website first. Attackers have found that an effective way to trick a victim is to redirect him to a fake website after they enter their credentials on a legitimate page. The fake website would look identical to a legitimate website, and it would ask the victim to re-enter their password. After the victim re-enters their password it would be recorded by the attacker and victim would be redirected back to a valid website. If done correctly, victim would think that he mistyped password once and would not notice that his username and password were stolen. 为了使识别开放重定向更加困难，重定向可能发生在受害者先提供登录合法网站之后。攻击者发现，欺骗受害者的有效方法是在受害者在合法网页上输入凭证后将其重定向到一个假网站。这个假网站看起来和合法网站一样，它会要求受害者重新输入密码。当受害者重新输入密码后，攻击者会记录下来，受害者会被重定向到一个有效的网站。如果操作得当，受害者会认为自己打错了一次密码，不会注意到自己的用户名和密码被盗。 Phishing is used in most successful targeted hacks and also regularly in opportunistic attacks. Considering how prominent phishing is in our daily lives, Open Redirect vulnerabilities should not be dismissed. 网络钓鱼被用于大多数成功的目标黑客，也经常用于机会主义攻击。考虑到网络钓鱼在我们的日常生活中是多么的突出，Open Redirect漏洞不应该被忽视。 It would have been unfair to single out any specific website or company as being vulnerable to Open Redirect because so many companies have it. Instead, it’s more useful to demonstrate how common those websites are and how easy it is to find them. 如果单独指出任何特定的网站或公司容易受到开放重定向的影响，这是不公平的，因为有这么多公司都有这种情况。相反，更有用的是展示这些网站有多普遍，以及找到它们有多容易。 Doing a web search is one of the best tools to find Open Redirect on your own website and across a wider Internet. 进行网络搜索是在自己的网站和更广泛的互联网上找到Open Redirect(开放重定向)的最佳工具之一。 Google Search allows for a great flexibility in writing search queries, including queries that specifically search through URLs of pages. Google搜索可以非常灵活地编写搜索查询，包括专门通过网页的URL进行搜索的查询。 The following operators and special symbols allow anyone to craft very targeted Google Searches for finding Open Redirects: 以下操作符和特殊符号使任何人都可以针对特定的Google搜索，以查找开放重定向： allinurl - operator that tells Google to search within URL for all provided keywords Example: allinurl:ReturnUrl which searches for web pages that have “ReturnUrl” as part of their URL allinurl - 操作符，告诉谷歌在URL中搜索所有提供的关键字。 例如：allinurl:ReturnUrl，它可以搜索URL中含有 “ReturnUrl “的网页。 site - operator that tells to only return results that are on specific domain or a web siteExample: site:example.com which searches for web pages from example.com site - 操作符，指示只返回特定域名或网站上的结果。例如：site:example.com可以搜索example.com的网页。 “” - double quotes are a special symbols that used to indicate to search for exact combination of words and symbols within quotes “”–双引号是一种特殊的符号，用来表示搜索引号内的单词和符号的精确组合。 *- The asterisk is a wildcard that represents one or more words *- 星号是通配符，代表一个或多个词。 Using these allows us to search for certain tell tale signs of potential Open Redirect: We can look for the general presence of “http” or “https” within parameter area of GET request. For instance: 使用这些可以让我们搜索某些潜在的开放重定向的迹象： 我们可以在GET请求的参数区域中寻找 “http “或 “https “的一般存在。例如，我们可以在GET请求的参数区寻找 “http “或 “https “的存在: allinurl:%3Dhttps* allinurl:%253Dhttps* allinurl:%3Dhttp* allinurl:%253Dhttp* We can also search for specific, common words related to forwarding within parameter area of GET request. For instance: 我们还可以在GET请求的参数区中搜索与转发相关的特定的、常用的词。比如说: allinurl:”&lt;keyword&gt;=https” allinurl:”&lt;keyword&gt;=http” allinurl:&lt;keyword&gt;=https allinurl:&lt;keyword&gt;=http allinurl:&lt;keyword&gt;%3Dhttps allinurl:”&lt;keyword&gt;%3Dhttps* “ allinurl:&lt;keyword&gt;%253Dhttps allinurl:”&lt;keyword&gt;%253Dhttps* “ … Instead of &lt;keyword&gt;, we would use one of the following words typical of redirects:RelayState, ReturnUrl, RedirectUri, Return, Return_url, Redirect, Redirect_uri, Redirect_url,RedirectUrl, Forward, ForwardUrl, Forward_URL, SuccessUrl, Redir, Exit_url, Destination. This is by no means a comprehensive list of keywords. You can find more by analyzing results from the more general queries looking for a URL in the parameter section of the GET request. 我们将使用以下典型的重定向词来代替\\keyword&gt;：RelayState，ReturnUrl，RedirectUri，Return，Return_url，Redirect，Redirect_uri，Redirect_url，RedirectUrl，Forward，ForwardUrl，Forward_URL，SuccessUrl，Redir，Exit_url，Destination。这绝不是一个全面的关键词列表。你可以通过分析GET请求的参数部分中寻找URL的更一般查询的结果来找到更多。 For targeted searches, you can add “site:“ to the end of your Google Queries. This can help you identify Open Redirect vulnerabilities on your own website. 对于有针对性的搜索，你可以在Google查询的结尾添加 “site:“。这可以帮助你找出自己网站上的Open Redirect漏洞。 Using this simple search technique you can find dozens of Open Redirect vulnerabilities within minutes. List of vulnerable websites includes banking websites, websites of international corporations, trusted companies, beloved projects and numerous websites of smaller organizations. As an additional bonus, each time Google’s web crawler comes across new website that has Open Redirect, we will get updated results through our queries. 使用这种简单的搜索技术，你可以在几分钟内找到几十个Open Redirect漏洞。易受攻击的网站列表包括银行网站、国际公司网站、值得信赖的公司、心爱的项目和众多小型组织的网站。作为额外的奖励，每次Google的网络爬虫遇到有Open Redirect的新网站，我们都会通过查询得到更新的结果。 The best way to avoid Open Redirect vulnerability is to avoid redirecting based on parameter controlled by users or supplied through GET method. If redirecting is unavoidable,it can be dealt with by validating a redirect target and sanitizing it using whitelist of approved URLs. 避免Open Redirect漏洞的最好方法是避免基于用户控制的参数或通过GET方法提供的重定向。如果重定向是不可避免的，可以通过验证重定向目标，并使用批准的URL白名单对其进行消毒处理。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"http重定向","slug":"http重定向","permalink":"http://kisskisso.com/tags/http%E9%87%8D%E5%AE%9A%E5%90%91/"}]},{"title":"如何正确删除linux分区","slug":"如何正确删除linux分区","date":"2020-08-19T06:25:17.000Z","updated":"2021-01-26T10:26:32.000Z","comments":true,"path":"2020/08/19/如何正确删除linux分区/","link":"","permalink":"http://kisskisso.com/2020/08/19/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%88%A0%E9%99%A4linux%E5%88%86%E5%8C%BA/","excerpt":"原因： ​ 当初装双系统低估了win10的占量，高估了linux的占量。导致win10空间急速下降，之后找到了cmd终端替代品。就打算删除linux分区，（win10并不识别linux分区）就直接在win10自带的磁盘管理系统，直接删除了分区。结果导致开机无法正常启动系统 解决办法： 1、启动进入Windows系统 2、下载Mbrfix 3、解压到C盘根目录下 4、打开Windows命令行，也就是开始－运行－打入cmd","text":"原因： ​ 当初装双系统低估了win10的占量，高估了linux的占量。导致win10空间急速下降，之后找到了cmd终端替代品。就打算删除linux分区，（win10并不识别linux分区）就直接在win10自带的磁盘管理系统，直接删除了分区。结果导致开机无法正常启动系统 解决办法： 1、启动进入Windows系统 2、下载Mbrfix 3、解压到C盘根目录下 4、打开Windows命令行，也就是开始－运行－打入cmd 5、在命令行下，键入：cd，然后回车 在键入：mbrfix /drive 0 fixmbr /yes回车 6、进入磁盘管理器，把将要删除的Ubuntu分区删除，这里说明一下，其实大家都知道哈，就是Windows里边有ntfs和fat格式，所以非Windows格式的分区即是Ubuntu的分区。 7、右键新的分区，点击创建新的逻辑分区。 8、重启，ok！ 如果说你像我一样已经删除了linux，无法进入，而我的做法是在安装一遍linux系统，然后在像上面操作一样 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"vuepress上手","slug":"vuepress上手","date":"2020-08-18T10:27:58.000Z","updated":"2021-01-26T09:42:08.000Z","comments":true,"path":"2020/08/18/vuepress上手/","link":"","permalink":"http://kisskisso.com/2020/08/18/vuepress%E4%B8%8A%E6%89%8B/","excerpt":"1.创建并进入一个新目录 mkdir xxx &amp;&amp; cd xxx 2.选择喜欢的包管理器进行初始化 yarn init &amp; # npm init 3.将Vuepress安装为本地依赖(不推荐全局安装) yarn add -D vuepress &amp; # npm i -D vuepress 4.创建第一篇文档","text":"1.创建并进入一个新目录 mkdir xxx &amp;&amp; cd xxx 2.选择喜欢的包管理器进行初始化 yarn init &amp; # npm init 3.将Vuepress安装为本地依赖(不推荐全局安装) yarn add -D vuepress &amp; # npm i -D vuepress 4.创建第一篇文档 mkdir docs &amp;&amp; echo '# Hello worde' &gt; docs/README.md 5.在packgae.json中添加scripts { \"scripts\": { \"docs:dev\": \"vuepress dev docs\", \"docs:build\": \"vuepress build docs\" } } 5.在本地启动服务器 yarn docs:dev &amp; # npm run docs:dev 6.在docs中新建.vuepress文件夹及config.js文件 mkdir .vuepress &amp;&amp; cd .vuepress/ &amp;&amp; touch config.js 7.在.vuepress文件夹新建public mkdir public // 用来放网页标签的图标 8.在config.js中写入 module.exports = { title: '名字', // 网页标题 description: 'xxx', // 随便起 // 注入到当前页面的 HTML &lt;head&gt; 中的标签 head: [ ['link', { rel: 'icon', href: '/favicon.ico' }], // 增加一个自定义的 favicon(网页标签的图标) ], base: '/xxx/', // github仓库地址 markdown: { lineNumbers: true // 代码块显示行号 }, themeConfig: { sidebarDepth: 2, // e'b将同时提取markdown中h3 和 h3 标题，显示在侧边栏上。 lastUpdated: 'Last Updated',// 文档更新时间：每个文件git最后提交的时间 // 主页导航栏 nav:[ { text: 'xxx', link: 'xxx' }, // link处添外部链接（仓库地址码云或者github） // 下拉列表 { text: 'xxx', items: [ { text: 'xxx', link: 'xxx' }, { text: 'xxx', link: 'xxxx' } ] } ], // 侧边栏 sidebar: [ ['/', 'xxx'], // README.md { title: 'xxx', collapsable: false, children:[ ['/help/one.md', '标题名'], ] }, ] } } 9.在你的项目(根目录)中创建一个deploy.sh文件（请自行判断去掉高亮行的注释） #!/usr/bin/env sh # 确保脚本抛出遇到的错误 set -e # 生成静态文件 npm run docs:build # 进入生成的文件夹 cd docs/.vuepress/dist # 如果是发布到自定义域名 # echo 'www.example.com' &gt; CNAME git init git add -A git commit -m 'deploy' # 如果发布到 https://&lt;USERNAME&gt;.github.io # git push -f git@github.com:&lt;USERNAME&gt;/&lt;USERNAME&gt;.github.io.git master # 如果发布到 https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt; # git push -f git@github.com:&lt;USERNAME&gt;/&lt;REPO&gt;.git master cd - 10.写完之后运行sh打包上传 sh deploy.sh document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vuepress","slug":"vuepress","permalink":"http://kisskisso.com/tags/vuepress/"}]},{"title":"Cygwin安装配置","slug":"Cygwin安装配置","date":"2020-08-09T09:35:50.000Z","updated":"2021-01-26T08:53:50.000Z","comments":true,"path":"2020/08/09/Cygwin安装配置/","link":"","permalink":"http://kisskisso.com/2020/08/09/Cygwin%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/","excerpt":"Cygwin是： GNU和开放源代码工具的大量集合，它们提供的功能类似于 Windows上的 Linux发行版。 提供实质性POSIX API功能的DLL（cygwin1.dll）。","text":"Cygwin是： GNU和开放源代码工具的大量集合，它们提供的功能类似于 Windows上的 Linux发行版。 提供实质性POSIX API功能的DLL（cygwin1.dll）。 安装 1.下载Cygwin 2.打开安装包 3.按需选择 4.选择安装目录 5.选择本地目录（里面文件可以删除） 6.设置代理 7.选择镜像源 8.下一步 9.下一步 10.完成 配置 需要安装（dos2unix、wget、lynx） 还是打开安装程序按照安装过程到第8步(先不要关闭！！！先不要关闭！！！先不要关闭！！！) 先从github克隆apt-cyg [git clone https://github.com/transcode-open/apt-cyg] PS：在Cygwin上克隆 cd apt-cyg 【进入apt-cyg目录】 install apt-cyg /bin 【将apt-cyg安装到/bin目录下】 下载东西【例如：apt-cyg install vim】，如果不出意外会出报错 /usr/bin/apt-cyg:行25: $’\\r’: 未找到命令 /usr/bin/apt-cyg:行121: 未预期的符号 $'{\\r'' 附近有语法错误 'usr/bin/apt-cyg:行121:function wget { 需要下载dos2unix 1.在终端输入cd ../.. &amp;&amp; ls cd usr/bin/ 在终端输入 dos2unix apt-cyg会显示dos2unix: 正在转换文件 apt-cyg为Unix格式…，然后在运行apt-cyg install vim 就不会报上面的错误 但是下载的时候会显示 或者 lynx: 未找到命令 需要安装lynx和安装wget 和下载doswunix一样 之后下一步下一步 QAQ: 1.如何切换zsh？ vim .bash_profile 在最后一行加入exec zsh 保存退出 【ps： 按i 最后一行输入exec zsh 按Esc 按:输入wq 按enter】 重新打开 2.切换zsh重新打开乱码？ 需要安装oh-my-zsh 官网或者 链接：https://pan.baidu.com/s/1pKsMhbz1ahx1F9fWj57k_g提取码：obva 注：百度盘不一定是最新的(但可以更新到最新) 3.如何更新oh-my-zsh？ omz update 4.如何查看oh-my-zsh安装成功？ 如下图显示就安装成功了 失败请安装git 【apt-cyg install git】 5.主题如何获取？ 主题地址 6.如何更改zsh主题？ 终端输入vim .zshrc 箭头处更改主题名称 7.为什么不能输入/如何保存退出？ 按 i 进入编辑 更改完成后 按 ESC 然后按 : 输入wq 按Enter 重新启动 ps：别忘了按ESC 8.如何更改Cygwin语言设置？ 终端任意位置点击鼠标右键 点击Options （看图UI language选择语言） 选择（zh_CN）完之后点击Apply 9.如何调整窗口大小（不是关闭恢复原状）？ 设置 -窗口（调整窗口到合适大小）-点击当前大小—然后应用 10.如何打开Windows中的文件/文件夹？ cygstart xxx document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"应用与插件","slug":"应用与插件","permalink":"http://kisskisso.com/categories/%E5%BA%94%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"Cygwin","slug":"Cygwin","permalink":"http://kisskisso.com/tags/Cygwin/"}]},{"title":"如何部署vuepress","slug":"如何部署vuepress","date":"2020-08-08T10:45:59.000Z","updated":"2021-01-26T10:22:38.000Z","comments":true,"path":"2020/08/08/如何部署vuepress/","link":"","permalink":"http://kisskisso.com/2020/08/08/%E5%A6%82%E4%BD%95%E9%83%A8%E7%BD%B2vuepress/","excerpt":"","text":"在项目中，创建一个deploy.sh文件（请自行判断，去掉高亮行的注释） #!/usr/bin/env sh # 确保脚本抛出遇到的错误 set -e # 生成静态文件 npm run docs:build # 进入生成的文件夹 cd docs/.vuepress/dist # 如果是发布到自定义域名 # echo 'www.example.com' &gt; CNAME git init git add -A git commit -m 'deploy' # 如果发布到 https://&lt;USERNAME&gt;.github.io # git push -f git@github.com:&lt;USERNAME&gt;/&lt;USERNAME&gt;.github.io.git master # 如果发布到 https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt; # git push -f git@github.com:&lt;USERNAME&gt;/&lt;REPO&gt;.git master cd - 如何在windows下运行sh？ 如果有Git则直接打开终端输入sh&nbsp;xxx.sh(ps:xxx为你起得名字) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"vuepress","slug":"vuepress","permalink":"http://kisskisso.com/tags/vuepress/"}]},{"title":"Sandboxie沙盒","slug":"Sandboxie沙盒","date":"2020-08-03T08:49:29.000Z","updated":"2021-01-26T09:37:54.000Z","comments":true,"path":"2020/08/03/Sandboxie沙盒/","link":"","permalink":"http://kisskisso.com/2020/08/03/Sandboxie%E6%B2%99%E7%9B%92/","excerpt":"","text":"Sandboxie ，是一款从底层操作系统层面，将真实系统环境与虚拟系统隔离，以防止个人数据、程序等不受未知程序或有风险操作影响的Windows端沙盘/沙箱软件。 GitHub下载 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"应用与插件","slug":"应用与插件","permalink":"http://kisskisso.com/categories/%E5%BA%94%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"沙盒","slug":"沙盒","permalink":"http://kisskisso.com/tags/%E6%B2%99%E7%9B%92/"}]},{"title":"EndNote软件","slug":"EndNote软件","date":"2020-08-02T10:58:39.000Z","updated":"2021-01-26T08:56:14.000Z","comments":true,"path":"2020/08/02/EndNote软件/","link":"","permalink":"http://kisskisso.com/2020/08/02/EndNote%E8%BD%AF%E4%BB%B6/","excerpt":"","text":"借助 EndNote X9 更智能地研究，告别设置文献格式、全文查找、搜索和整理参考书目之类的繁琐工作 整理pdf以及word或者文献EndNote&nbsp;X9 [官网需要购买PS：贵。淘宝：不能升级（废且51元）]都不建议购买,除非你确定买来不吃灰 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"应用与插件","slug":"应用与插件","permalink":"http://kisskisso.com/categories/%E5%BA%94%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"EndNote","slug":"EndNote","permalink":"http://kisskisso.com/tags/EndNote/"}]},{"title":"当代心理学观点","slug":"当代心理学观点","date":"2020-08-02T10:54:13.000Z","updated":"2021-01-26T09:55:12.000Z","comments":true,"path":"2020/08/02/当代心理学观点/","link":"","permalink":"http://kisskisso.com/2020/08/02/%E5%BD%93%E4%BB%A3%E5%BF%83%E7%90%86%E5%AD%A6%E8%A7%82%E7%82%B9/","excerpt":"","text":"​ 当代心理学观点是一种观察心理学议题的方式或者取向，并在五个观点的基础上进行折中取向。生物观点以生物取向来区辨出行为和心理现象下的生物神经过程，探究行为与心理历程的神经生物过程的研究取向。行为观点则是以条件作用与强化作用观点来探究可观察行为的研究取向如：S-R（刺激-反应）。认知观点回归认知基础但并非以内省法为基础，而是以两种假设为前提（1.心智历程的研究可着完全了解有机体的所作所为2.心智历程的研究可着眼于对特殊行为的客观观察，并以内在心智历程观点解释。）来探索诸如知觉、记忆、决策于问题解决等心理过程，以及它们与行为关系。心理分析则是以认知概念与生物基本本能的想法结合，以源自性与攻击冲动的无意识观点，来探索，并提出大多数行为的产生来自无意识过程，即人们不自知但却可影响其行为的思想、恐惧和欲望等。 ​ 主观论者以人们主动建构的主观现实，来探究行为与心理历程，并主张人类行为是他所知觉的世界，而非客观世界。【朴素的现实主义⑴】 与认知论（格式塔）来对抗行为论的狭缢论点 ⑴指人们会倾向于将自己建构好的、主观的现实，理解为忠实地表现了客观世界 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"爱好心理学","slug":"爱好心理学","permalink":"http://kisskisso.com/categories/%E7%88%B1%E5%A5%BD%E5%BF%83%E7%90%86%E5%AD%A6/"}],"tags":[{"name":"心理学","slug":"心理学","permalink":"http://kisskisso.com/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"}]},{"title":"React-Redux技术要点","slug":"React-Redux技术要点","date":"2020-08-01T11:59:08.000Z","updated":"2021-01-26T09:28:36.000Z","comments":true,"path":"2020/08/01/React-Redux技术要点/","link":"","permalink":"http://kisskisso.com/2020/08/01/React-Redux%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9/","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"react","slug":"react","permalink":"http://kisskisso.com/tags/react/"}]},{"title":"涂鸦？","slug":"涂鸦？","date":"2020-07-31T09:49:45.000Z","updated":"2021-01-26T10:32:34.000Z","comments":true,"path":"2020/07/31/涂鸦？/","link":"","permalink":"http://kisskisso.com/2020/07/31/%E6%B6%82%E9%B8%A6%EF%BC%9F/","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活与话","slug":"生活与话","permalink":"http://kisskisso.com/categories/%E7%94%9F%E6%B4%BB%E4%B8%8E%E8%AF%9D/"}],"tags":[{"name":"画","slug":"画","permalink":"http://kisskisso.com/tags/%E7%94%BB/"}]},{"title":"Krita软件","slug":"Krita软件","date":"2020-07-29T06:39:08.000Z","updated":"2021-01-26T09:20:20.000Z","comments":true,"path":"2020/07/29/Krita软件/","link":"","permalink":"http://kisskisso.com/2020/07/29/Krita%E8%BD%AF%E4%BB%B6/","excerpt":"","text":"Krita 是一款由社区驱动的自由开源数字绘画软件，可免费使用，无任何商用限制，让每一位画师都可以随心所欲地表达创意。 适合：概念草图、插画、漫画、动画、接景和 3D 贴图 支持：数位板、压感、防抖、图层、滤镜、色彩管理等 中文：软件、文档和网站内建官方中文版 Krita 4.3文档 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"应用与插件","slug":"应用与插件","permalink":"http://kisskisso.com/categories/%E5%BA%94%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"Krita","slug":"Krita","permalink":"http://kisskisso.com/tags/Krita/"}]},{"title":"如何建立自己的知识体系?","slug":"如何建立自己的知识体系","date":"2020-07-28T11:16:24.000Z","updated":"2021-01-26T10:22:56.000Z","comments":true,"path":"2020/07/28/如何建立自己的知识体系/","link":"","permalink":"http://kisskisso.com/2020/07/28/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"知识","slug":"知识","permalink":"http://kisskisso.com/tags/%E7%9F%A5%E8%AF%86/"}]},{"title":"怎样才算会读书？","slug":"怎样才算会读书？","date":"2020-07-28T07:13:56.000Z","updated":"2021-01-26T10:42:48.000Z","comments":true,"path":"2020/07/28/怎样才算会读书？/","link":"","permalink":"http://kisskisso.com/2020/07/28/%E6%80%8E%E6%A0%B7%E6%89%8D%E7%AE%97%E4%BC%9A%E8%AF%BB%E4%B9%A6%EF%BC%9F/","excerpt":"","text":"类比一下这个问题：“怎么才算会吃饭？” 一口尝出七八味作料算会吃（对书本理解非常透彻），还是吃完之后能舌灿如花地点评（善于写各种书评）算会吃？吃完了马上到厨房COPY一份几乎尝不出差别的复制品（能够学以致用指导人生）算会吃，还是悠悠道来这道菜的悠久历史（善于触类旁通）才算会吃？ 活到现在基本健康的人们都出来回答一下，你觉得怎么才算会吃饭？ 读个书而已，多大点事啊。 知乎对读书的矫枉过正也不是一两天了~但是读书不过就是读书啊，想要读成博士或者想要读成大师，想要通透地理解一本书，跟“会读书”应该不是一个概念吧。而且呀，知行合一不是那么容易做到的，古人说“知易行难”诚不欺我也啊。 读书跟吃饭都是个动宾短语，一个是供养精神，一个是供养身体，真的没必要搞得跟参拜一样。能在西餐厅礼仪万方地吃饭，不意味着在大排档站着聊天啃串的人就不会吃饭了。 邯郸学步大概就是说这个状态。有人善于走猫步，漂亮潇洒高端大气，但这不意味着别人都不会走路了。而且我也不觉得只有那样才叫“会走路”。 想读书，就读；跟饿了就吃饭一样。 &lt;怎样才算读书?&gt; 知乎 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://kisskisso.com/tags/%E8%AF%BB%E4%B9%A6/"}]},{"title":"腾讯COS+PicGo","slug":"腾讯COS-PicGo","date":"2020-07-28T04:54:45.000Z","updated":"2021-01-26T10:31:42.000Z","comments":true,"path":"2020/07/28/腾讯COS-PicGo/","link":"","permalink":"http://kisskisso.com/2020/07/28/%E8%85%BE%E8%AE%AFCOS-PicGo/","excerpt":"1.腾讯COS+PicGo 1.1登录腾讯云搜索COS（对象存储） 1.2点击立即使用 1.3之后是实名认证之类的（微信） 1.4进入对象存储桶列表创建存储桶","text":"1.腾讯COS+PicGo 1.1登录腾讯云搜索COS（对象存储） 1.2点击立即使用 1.3之后是实名认证之类的（微信） 1.4进入对象存储桶列表创建存储桶 1.5填写(看情况填写) 1.6申请API密钥 会提示（继续使用） 新建密钥 2.在PicGo填写 注：COS版本选择V5（我选V4不能上传） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"应用与插件","slug":"应用与插件","permalink":"http://kisskisso.com/categories/%E5%BA%94%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"图床","slug":"图床","permalink":"http://kisskisso.com/tags/%E5%9B%BE%E5%BA%8A/"}]},{"title":"Github图床+PicGo","slug":"Github图床-PicGo","date":"2020-07-27T11:25:16.000Z","updated":"2021-01-26T09:00:18.000Z","comments":true,"path":"2020/07/27/Github图床-PicGo/","link":"","permalink":"http://kisskisso.com/2020/07/27/Github%E5%9B%BE%E5%BA%8A-PicGo/","excerpt":"1.新建图床仓库 1.1 在Github中创建一个仓库 1.2在Github生成一个token（给PicGo使用）","text":"1.新建图床仓库 1.1 在Github中创建一个仓库 1.2在Github生成一个token（给PicGo使用） 1.3之后点最下面的Generate token,会生成一串token，注：生成的token最好保存到本地，因为下次再进GitHub的时候，这个token就不再显示了。 2.PicGo客户端 PicGo下载 PS:仓库名就是github用户名/仓库名，前/后什么都不加。分支默认master。上一部生成的token。存储路径可写可不写 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"应用与插件","slug":"应用与插件","permalink":"http://kisskisso.com/categories/%E5%BA%94%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"图床","slug":"图床","permalink":"http://kisskisso.com/tags/%E5%9B%BE%E5%BA%8A/"}]},{"title":"vue知识体","slug":"vue知识体","date":"2020-07-27T11:19:12.000Z","updated":"2021-01-26T09:46:02.000Z","comments":true,"path":"2020/07/27/vue知识体/","link":"","permalink":"http://kisskisso.com/2020/07/27/vue%E7%9F%A5%E8%AF%86%E4%BD%93/","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://kisskisso.com/tags/vue/"}]},{"title":"html语义化（基本）","slug":"html语义化","date":"2020-07-23T22:25:27.000Z","updated":"2021-01-26T09:04:00.000Z","comments":true,"path":"2020/07/24/html语义化/","link":"","permalink":"http://kisskisso.com/2020/07/24/html%E8%AF%AD%E4%B9%89%E5%8C%96/","excerpt":"根据内容的结构化，选择合适的标签 优点： 有利于SEO。有利于开发与维护。有利于用户阅读，在丢失样式时，能让页面呈现清晰的结构。方便设备解读 扩展： html5是什么？ 是html标准的最新演进的版本，多样化，功能更强大","text":"根据内容的结构化，选择合适的标签 优点： 有利于SEO。有利于开发与维护。有利于用户阅读，在丢失样式时，能让页面呈现清晰的结构。方便设备解读 扩展： html5是什么？ 是html标准的最新演进的版本，多样化，功能更强大 新特征： 1.语义特性 2.多媒体 3.图像效果 4.设备兼容性 5.离线或存储 6.性能与集成特性 css选择器 通配符选择器 。 类选择器。 id选择器 。伪类选择器 。 后代选择器 。 属性选择器 ！important -行内样式 - id选择器 - 类选择器 - 伪类选择器 - 通配符选择器 - 继承 - 默认 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与面试题","slug":"算法与面试题","permalink":"http://kisskisso.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://kisskisso.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"rem和em的区别","slug":"rem和em的区别","date":"2020-07-23T22:19:56.000Z","updated":"2021-01-26T09:33:56.000Z","comments":true,"path":"2020/07/24/rem和em的区别/","link":"","permalink":"http://kisskisso.com/2020/07/24/rem%E5%92%8Cem%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"rem：表示根元素字体的大小 em：表示父元素（fontsize）大小 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与面试题","slug":"算法与面试题","permalink":"http://kisskisso.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://kisskisso.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"W3C标准是什么","slug":"W3C标准是什么","date":"2020-07-21T14:21:38.000Z","updated":"2021-01-26T09:46:20.000Z","comments":true,"path":"2020/07/21/W3C标准是什么/","link":"","permalink":"http://kisskisso.com/2020/07/21/W3C%E6%A0%87%E5%87%86%E6%98%AF%E4%BB%80%E4%B9%88/","excerpt":"1.结构标准，代表语言是xHTML 2.表现标准，代表语言是CSS 3.动作标准，代表语言是JavaScrip 除了以上的标准，还有XML，DOM标准","text":"1.结构标准，代表语言是xHTML 2.表现标准，代表语言是CSS 3.动作标准，代表语言是JavaScrip 除了以上的标准，还有XML，DOM标准 扩展： XHTML 可扩展超文本标记语言，是一种标记语言，表现方式与超文本标记语言（HTML）类似，不过语法上更加严格。 XML XML 被设计用来传输和存储数据。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与面试题","slug":"算法与面试题","permalink":"http://kisskisso.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://kisskisso.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"MVC开发思想","slug":"MVC开发思想","date":"2020-07-21T14:08:25.000Z","updated":"2021-01-26T09:24:32.000Z","comments":true,"path":"2020/07/21/MVC开发思想/","link":"","permalink":"http://kisskisso.com/2020/07/21/MVC%E5%BC%80%E5%8F%91%E6%80%9D%E6%83%B3/","excerpt":"","text":"MVC即Model、View、Controller即模型、视图、控制器。是一种软件架构的思想，将一个软件按照模型、视图、控制器进行划分。模型用来封装业务逻辑，视图用来实现表示逻辑，而控制器用来协调模型与视图 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与面试题","slug":"算法与面试题","permalink":"http://kisskisso.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://kisskisso.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"c语言学习思路","slug":"c语言学习思路","date":"2020-07-21T02:28:23.000Z","updated":"2021-01-26T08:54:46.000Z","comments":true,"path":"2020/07/21/c语言学习思路/","link":"","permalink":"http://kisskisso.com/2020/07/21/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%B7%AF/","excerpt":"","text":"1）数据类型：需要死记硬背。其中–浮点数表示法 需要学习下 程度达到能理解就行二进制 十进制 十六进制 8进制也需要了解整数的负数表示方法2) 判断 分支 循环 和 数组会了数组和循环后,就可以学基础的三个排序算法: 选择 冒泡 插入,其中冒泡在吧里讨论最广泛,有很多问题出现 然后会接触到 随机函数，时间函数，和 个别的数学函数3) 基本的输入和输出函数printf 和 scanf 需要非常熟悉, 同样有很多问题会拿出来讨论4) 流程图 以及 NS流程图的画法5) 函数 以及 函数调用栈6) 字符串、字符串输入输出、字符串常用函数7) 指针：需要多练练，需要弄得很懂。字符串的几个函数和指针的联系很紧，尝试用自己的方法实现字符串的几个常用函数，对理解指针会很有帮助。 文件和文件输入输出 结构体 联合体 数据结构和算法中的基础部分 —链表 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"语言与Linux","slug":"语言与Linux","permalink":"http://kisskisso.com/categories/%E8%AF%AD%E8%A8%80%E4%B8%8ELinux/"}],"tags":[{"name":"C","slug":"C","permalink":"http://kisskisso.com/tags/C/"}]},{"title":"Git命令","slug":"Git命令","date":"2020-07-19T01:54:03.000Z","updated":"2021-01-26T09:01:18.000Z","comments":true,"path":"2020/07/19/Git命令/","link":"","permalink":"http://kisskisso.com/2020/07/19/Git%E5%91%BD%E4%BB%A4/","excerpt":"","text":"git branch &lt;分支名&gt; 新建分支 git checkout &lt;分支名&gt; 切换分支 合并分支： git merge一: git checkout -b &lt;分支名&gt; 新建并切换分支名 git commit -m ‘注释’ 提交注释 git push origin &lt;分支名&gt; 上传 git checkout master 切换主分支 git merge &lt;分支名&gt; 合并分支 git rebase二： git checkout -b &lt;分支名&gt; 新建并切换分支名 git commit -m ‘注释’ 提交注释 git checkout master 切换主分支 git commit -m ‘注释’ 提交注释 git checkout &lt;分支名&gt; 切换分支 git rebase master 合并到主分支 相对引用： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"语言与Linux","slug":"语言与Linux","permalink":"http://kisskisso.com/categories/%E8%AF%AD%E8%A8%80%E4%B8%8ELinux/"}],"tags":[{"name":"Git命令","slug":"Git命令","permalink":"http://kisskisso.com/tags/Git%E5%91%BD%E4%BB%A4/"}]},{"title":"话十肆","slug":"话十肆","date":"2020-07-14T01:58:24.000Z","updated":"2021-01-26T10:05:08.000Z","comments":true,"path":"2020/07/14/话十肆/","link":"","permalink":"http://kisskisso.com/2020/07/14/%E8%AF%9D%E5%8D%81%E8%82%86/","excerpt":"","text":"我们没有人可以凭借与众不同而与众不同，因为与众不同是你所能做的最与众不同的事情，因为它是一件会自然而然地发生在每个人身上的事情。所以，相比“做一个与众不同的人”,我们或许更应该说：“尽情地做个显而易见的混蛋吧，因为与众不同已经让别人占有了。”——已经被所有人占有了，这可真讽刺呀！ 或者，我们应该把这句话改为“不要甘于平庸，要做一个最平庸的人”。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活与话","slug":"生活与话","permalink":"http://kisskisso.com/categories/%E7%94%9F%E6%B4%BB%E4%B8%8E%E8%AF%9D/"}],"tags":[{"name":"话","slug":"话","permalink":"http://kisskisso.com/tags/%E8%AF%9D/"}]},{"title":"Linux美化","slug":"Linux美化","date":"2020-07-13T23:18:31.000Z","updated":"2021-01-26T09:23:38.000Z","comments":true,"path":"2020/07/14/Linux美化/","link":"","permalink":"http://kisskisso.com/2020/07/14/Linux%E7%BE%8E%E5%8C%96/","excerpt":"","text":"主题图标网址：https://www.pling.com/browse/cat/381/order/latest/ 管理界面：https://github.com/elementary-tweaks/elementary-tweaks document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"语言与Linux","slug":"语言与Linux","permalink":"http://kisskisso.com/categories/%E8%AF%AD%E8%A8%80%E4%B8%8ELinux/"}],"tags":[{"name":"美化","slug":"美化","permalink":"http://kisskisso.com/tags/%E7%BE%8E%E5%8C%96/"}]},{"title":"推理小说","slug":"推理小说","date":"2020-07-11T00:23:44.000Z","updated":"2021-01-26T10:33:14.000Z","comments":true,"path":"2020/07/11/推理小说/","link":"","permalink":"http://kisskisso.com/2020/07/11/%E6%8E%A8%E7%90%86%E5%B0%8F%E8%AF%B4/","excerpt":"怪盗的二十面相 魔术师 八声甘州 蜘蛛男（3/10） 钟表馆事件","text":"怪盗的二十面相 魔术师 八声甘州 蜘蛛男（3/10） 钟表馆事件 血字研究 四签名 红发会 跳舞的小人 北方夕鹤2/3杀人事件 占星术杀人魔法 东方快车谋杀事件 尼罗河上的惨案 无人生还 斜屋犯罪 异邦骑士 奇想，天动 克莱因壶 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"词","slug":"词","date":"2020-07-10T09:32:12.000Z","updated":"2021-01-26T09:54:00.000Z","comments":true,"path":"2020/07/10/词/","link":"","permalink":"http://kisskisso.com/2020/07/10/%E8%AF%8D/","excerpt":"","text":"拼音 词解释 lian pian lei du（2 1 3 2） 连篇累牍 篇幅过多，文辞冗(rong)长 an cun (4 3) 暗忖 思量，盘算，推算 ao sang (4 4) 懊丧 因事情不如意而情绪低落 an zi si cun (4 4 1 3) 暗自思忖 在私底下里思量；在暗地：~盘算 | ~高兴 ji ( 4) 蓟 草本植物：大蓟 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"话十叁","slug":"话十叁","date":"2020-07-10T09:26:40.000Z","updated":"2021-01-26T10:04:44.000Z","comments":true,"path":"2020/07/10/话十叁/","link":"","permalink":"http://kisskisso.com/2020/07/10/%E8%AF%9D%E5%8D%81%E5%8F%81/","excerpt":"","text":"“愿灵魂安息吧。” 这句话相当自私。它的根本意思是：“待在你的坟墓里，别在我身边游荡”。 相反的一句话会是：“动不动翻个身吧” 和 “去跑个步吧”。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活与话","slug":"生活与话","permalink":"http://kisskisso.com/categories/%E7%94%9F%E6%B4%BB%E4%B8%8E%E8%AF%9D/"}],"tags":[{"name":"话","slug":"话","permalink":"http://kisskisso.com/tags/%E8%AF%9D/"}]},{"title":"话十二","slug":"话十二","date":"2020-07-04T00:25:44.000Z","updated":"2021-01-26T10:04:24.000Z","comments":true,"path":"2020/07/04/话十二/","link":"","permalink":"http://kisskisso.com/2020/07/04/%E8%AF%9D%E5%8D%81%E4%BA%8C/","excerpt":"","text":"了解一件事是桥梁和道路上回转的可能性，解释一件事却是专横独断，有时甚至是谋杀了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活与话","slug":"生活与话","permalink":"http://kisskisso.com/categories/%E7%94%9F%E6%B4%BB%E4%B8%8E%E8%AF%9D/"}],"tags":[{"name":"话","slug":"话","permalink":"http://kisskisso.com/tags/%E8%AF%9D/"}]},{"title":"妖怪","slug":"妖怪","date":"2020-06-25T12:40:47.000Z","updated":"2021-01-26T10:39:14.000Z","comments":true,"path":"2020/06/25/妖怪/","link":"","permalink":"http://kisskisso.com/2020/06/25/%E5%A6%96%E6%80%AA/","excerpt":"","text":"巷说百物语 续巷说百物语 后巷说百物语 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"数据类型","slug":"数据类型","date":"2020-06-24T05:20:50.000Z","updated":"2021-01-26T10:29:54.000Z","comments":true,"path":"2020/06/24/数据类型/","link":"","permalink":"http://kisskisso.com/2020/06/24/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"基本类型 整型 字浮型 实型（浮点型） int char 单精度型 | 双精度型 float | double ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| 构造类型 枚举类型 数组类型 结构体类型 共用体类型 ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| 指针类型 ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| 空类型 小记：浮点数据指带小数点后的数字 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"语言与Linux","slug":"语言与Linux","permalink":"http://kisskisso.com/categories/%E8%AF%AD%E8%A8%80%E4%B8%8ELinux/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://kisskisso.com/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"歌声","slug":"歌声","date":"2020-06-15T07:21:15.000Z","updated":"2021-01-26T10:00:58.000Z","comments":true,"path":"2020/06/15/歌声/","link":"","permalink":"http://kisskisso.com/2020/06/15/%E6%AD%8C%E5%A3%B0/","excerpt":"","text":"在时间的沙池中 我终于听到了 那柔和的心跳声 可是却无法触碰 在爱的阳炎下 赤着脚丫 飞驰而去 我和你是相反的存在 在那个我们相互追逐的春天里的某一天 在风儿的带动下 沙砾翩翩起舞 如果这个世界宛如瓶底的话 把它翻转过来的话 我们的明天就能永远描绘下去 在最后 请把爱的残月给予我 仅需那一秒的时间 就那么一秒钟 宛如剥落星辰一般 脸庞传来你指尖的感触 把拂晓照亮了 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"第一章复习题","slug":"第一章复习题","date":"2020-06-12T09:11:51.000Z","updated":"2021-01-26T09:56:52.000Z","comments":true,"path":"2020/06/12/第一章复习题/","link":"","permalink":"http://kisskisso.com/2020/06/12/%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%A4%8D%E4%B9%A0%E9%A2%98/","excerpt":"1.对编程而言，可移植性意味着什么？ 在一中系统中编写的c程序稍作修改或不修改就能在其他系统运行 2.解释源代码文件、目标代码文件、可执行文件有什么区别？ 源代码文件包含程序员使用的任何编程语言编写的代码。 目标代码文件包含机器语言代码，它不必是完整的代码。 可执行文件包含组成可执行程序的完整机器语言代码。 3.编程的7个主要步骤？","text":"1.对编程而言，可移植性意味着什么？ 在一中系统中编写的c程序稍作修改或不修改就能在其他系统运行 2.解释源代码文件、目标代码文件、可执行文件有什么区别？ 源代码文件包含程序员使用的任何编程语言编写的代码。 目标代码文件包含机器语言代码，它不必是完整的代码。 可执行文件包含组成可执行程序的完整机器语言代码。 3.编程的7个主要步骤？ 1.定义程序的目标 2.设计程序 3.编写代码 4.编译 5.运行程序 6.测试和调试程序 7.维护和修改程序 4.编译器的任务是什么？ 把源代码转换成中间代码 5.链接器的任务是什么？ 把中间代码和其他代码合并，生成可执行文件 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"语言与Linux","slug":"语言与Linux","permalink":"http://kisskisso.com/categories/%E8%AF%AD%E8%A8%80%E4%B8%8ELinux/"}],"tags":[{"name":"复习题","slug":"复习题","permalink":"http://kisskisso.com/tags/%E5%A4%8D%E4%B9%A0%E9%A2%98/"}]},{"title":"C基础","slug":"C基础","date":"2020-06-12T08:01:19.000Z","updated":"2021-01-26T08:54:26.000Z","comments":true,"path":"2020/06/12/C基础/","link":"","permalink":"http://kisskisso.com/2020/06/12/C%E5%9F%BA%E7%A1%80/","excerpt":"C（嵌入式语言）是一门功能强大的专业化编程语言。强大的控制结构、快速、代码紧凑、可移植性。 c语言天下第一！！！ C语言中的6个语句：","text":"C（嵌入式语言）是一门功能强大的专业化编程语言。强大的控制结构、快速、代码紧凑、可移植性。 c语言天下第一！！！ C语言中的6个语句： 语句：【标号语句 复合语句 表达式语句 选择语句 迭代语句 跳转语句】—–关键字、标识符、运算符、数据 【典型的c程序】 | &lt;stdio.h&gt;--------------头文件(包含了编译器创建最终可执行程序要用的到信息) |----#include---------预处理器指令 |-----int main ()----------------总是第一个被调用的函数 | |________________________________语句--------------组成函数的语句 |------function a() | |________________________语句 | |-------function b() | | |__________________语句 | 函数是C程序的构造块 main()函数 c语言一定从main函数执行。圆括号用于识别main（）是一个函数 int则是main函数返回类型。 注释：编译器会忽视 /* 这是一种注释*/ // 这也是一种注释 花括号、函数体、块 { ... // 花括号会把main函数扩起来。也就是开始和结束。也可以把函数中的多条语句合并为一个单元格或块 } 声明：c语言中声明是最重要的特性之一 Eg：int mun mun是一个变量，int则表明mun是一个整数（int则是一种数据类型） 命名：给变量命名时要使用有意义的变量名或标识符 PS: c99和c11允许使用更长的标识符名，但编译器只识别前63个(但是没意义，63个手不累吗？) Eg：可以用小写字母、大写字母、数字、下划线( _ ) 来命名。注：名字的第一个字符必须是字母或下划线，不能是数字。c语言的命名大小要区分，一个字母的大小写会被视为两个不同的字符。 声明变量的4个理由： 1.把所有的变量放在一处，方便读者查找和理解程序的用途。变量名要有意义，如果无法表述清楚，则注释解释变量的含义、 2.声明变量会促使在编写程序之前做些计划 3.声明变量有助于发现隐藏的bug。拼写错误等 4.未声明变量则无法编译 赋值：从右侧把值赋到左侧 printf()函数：一个标准函数PS：打印？ return语句：返回值的c函数要有return语句… 扩展： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"语言与Linux","slug":"语言与Linux","permalink":"http://kisskisso.com/categories/%E8%AF%AD%E8%A8%80%E4%B8%8ELinux/"}],"tags":[{"name":"C","slug":"C","permalink":"http://kisskisso.com/tags/C/"}]},{"title":"vscode代码片段(html篇)","slug":"vscode代码片段-html篇","date":"2020-06-12T01:58:18.000Z","updated":"2021-01-26T09:41:06.000Z","comments":true,"path":"2020/06/12/vscode代码片段-html篇/","link":"","permalink":"http://kisskisso.com/2020/06/12/vscode%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5-html%E7%AF%87/","excerpt":"此篇用于创建html代码片段，代码如下： “prefix”: “vh”,指的是你自定义的快捷代码,输入vh就会出现快速生成代码提示，也可以自定义其他字段。","text":"此篇用于创建html代码片段，代码如下： “prefix”: “vh”,指的是你自定义的快捷代码,输入vh就会出现快速生成代码提示，也可以自定义其他字段。 { \"Html5-Vue\": { \"prefix\": \"vh\", \"body\": [ \"&lt;!DOCTYPE html&gt;\", \"&lt;html lang=\\\"zh-CN\\\"&gt;\\n\", \"&lt;head&gt;\", \"\\t&lt;meta charset=\\\"UTF-8\\\"&gt;\", \"\\t&lt;meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"&gt;\", \"\\t&lt;meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"ie=edge\\\"&gt;\", \"\\t&lt;title&gt;Document&lt;/title&gt;\", \"&lt;/head&gt;\\n\", \"&lt;body&gt;\", \"\\t&lt;script&gt;\", \"\\t&lt;/script&gt;\", \"&lt;/body&gt;\\n\", \"&lt;/html&gt;\" ] } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"代码片段","slug":"代码片段","permalink":"http://kisskisso.com/tags/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"}]},{"title":"vscode代码片段(vue篇)","slug":"vscode代码片段-vue篇","date":"2020-06-12T01:49:08.000Z","updated":"2021-01-26T09:41:24.000Z","comments":true,"path":"2020/06/12/vscode代码片段-vue篇/","link":"","permalink":"http://kisskisso.com/2020/06/12/vscode%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5-vue%E7%AF%87/","excerpt":"此篇用于快速创建vue模板，代码如下: 管理——&gt;用户代码片段———-&gt;新建全局代码片段 xxx.json PS：覆盖 “prefix”: “vue”,指的是你自定义的快捷代码，输入vue就会出现快速生成代码提示，也可以自定义其他字段。","text":"此篇用于快速创建vue模板，代码如下: 管理——&gt;用户代码片段———-&gt;新建全局代码片段 xxx.json PS：覆盖 “prefix”: “vue”,指的是你自定义的快捷代码，输入vue就会出现快速生成代码提示，也可以自定义其他字段。 { \"Print to console\": { \"prefix\": \"vue\", \"body\": [ \"&lt;!-- $1 --&gt;\", \"&lt;template&gt;\", \"&lt;div&gt;&lt;/div&gt;\", \"&lt;/template&gt;\", \"\", \"&lt;script&gt;\", \"export default {\", \"data() {\", \"return {\", \"\", \"}\", \"},\", \"//生命周期 - 创建完成（访问当前this实例）\", \"created() {\", \"\", \"},\", \"//生命周期 - 挂载完成（访问DOM元素）\", \"mounted() {\", \"\", \"}\", \"}\", \"&lt;/script&gt;\", \"&lt;style scoped&gt;\", \"/* @import url(); 引入css类 */\", \"$4\", \"&lt;/style&gt;\" ] } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"代码片段","slug":"代码片段","permalink":"http://kisskisso.com/tags/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"}]},{"title":"javascript语句","slug":"javascript语句","date":"2020-06-11T23:43:20.000Z","updated":"2021-01-26T09:08:04.000Z","comments":true,"path":"2020/06/12/javascript语句/","link":"","permalink":"http://kisskisso.com/2020/06/12/javascript%E8%AF%AD%E5%8F%A5/","excerpt":"语句：使用一或多个关键字来完成给定任务 if语句：可以嵌套多个if…esle… if () { ... } else { ... } do-while语句: 一种后测试循环语句 PS：最常用于循环体中的代码至少要被执行一次的情形","text":"语句：使用一或多个关键字来完成给定任务 if语句：可以嵌套多个if…esle… if () { ... } else { ... } do-while语句: 一种后测试循环语句 PS：最常用于循环体中的代码至少要被执行一次的情形 do { ... } while (...) while语句: 在某个条件表达式为真的前提下，循环执行指定的一段代码，直到那个表达式不为真时结束循环。 while (...) { ... } for语句：用于创建一个循环，它包含了三个可选的表达式 for ([initialization]; [condition]; [final-expression]) { ... } for-in语句：以任意顺序遍历一个对象的 for (variable in object) { ... } 注：for…in是为遍历对象属性而构成的，不建议与数组一起使用 PS：数组可以用Array.prototype.forEach() 和 for...of label语句：标记就是在一条语句前面加个可以引用的标识符（identifier）（了解？？？） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://kisskisso.com/tags/js/"}]},{"title":"常见错误(二)","slug":"常见错误二","date":"2020-06-09T13:07:02.000Z","updated":"2021-01-26T09:52:32.000Z","comments":true,"path":"2020/06/09/常见错误二/","link":"","permalink":"http://kisskisso.com/2020/06/09/%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E4%BA%8C/","excerpt":"17.’vue-cli-service’ 不是内部或外部命令，也不是可运行的程序 解决： 删除node_modules文件夹，重新运行npm install 18.npm install 报错（npm ERR! errno -4048，Error: EPERM: operation not permitted,） npm ERR! code EPERMnpm ERR! syscall unlink……npm ERR! errno: -4048,npm ERR! code: ‘EPERM’,npm ERR! syscall: ‘unlink’,npm ERR! path: ‘C:\\Users\\15969\\Desktop\\vue-admin-beautiful\\node_modules\\.staging\\echarts-9aadd223\\dist\\echarts-en.common.min.js’,npm ERR! parent: ‘vue-admin-beautiful’npm ERR! }npm ERR!npm ERR! The operation was rejected by your operating system.npm ERR! It’s possible that the file was already in use (by a text editor or antivirus),npm ERR! or that you lack permissions to access it.npm ERR!npm ERR! If you believe this might be a permissions issue, please double-check thenpm ERR! permissions of the file and its containing directories, or try runningnpm ERR! the command again as root/Administrator. 解决方案：","text":"17.’vue-cli-service’ 不是内部或外部命令，也不是可运行的程序 解决： 删除node_modules文件夹，重新运行npm install 18.npm install 报错（npm ERR! errno -4048，Error: EPERM: operation not permitted,） npm ERR! code EPERMnpm ERR! syscall unlink……npm ERR! errno: -4048,npm ERR! code: ‘EPERM’,npm ERR! syscall: ‘unlink’,npm ERR! path: ‘C:\\Users\\15969\\Desktop\\vue-admin-beautiful\\node_modules\\.staging\\echarts-9aadd223\\dist\\echarts-en.common.min.js’,npm ERR! parent: ‘vue-admin-beautiful’npm ERR! }npm ERR!npm ERR! The operation was rejected by your operating system.npm ERR! It’s possible that the file was already in use (by a text editor or antivirus),npm ERR! or that you lack permissions to access it.npm ERR!npm ERR! If you believe this might be a permissions issue, please double-check thenpm ERR! permissions of the file and its containing directories, or try runningnpm ERR! the command again as root/Administrator. 解决方案： 首先检查是不是管理员运行，如果不是则用管理员运行命令。 或 清除npm缓存npm cache clean --force 或 删除C:\\Users\\{账户}\\下的.npmrc文件.. 终极方案：npm cache verify PS：大概估计也许可能有用。我没用过npm 19.Git报错：error: failed to push some refs to To https://xxx.com/xxx/xxx.git ! [rejected] master -&gt; master (fetch first) error: failed to push some refs to 'https://xxx.com/xxx/xxx.git' hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., 'git pull ...') before pushing again. hint: See the 'Note about fast-forwards' in 'git push --help' for details. 错误原因：在推送前没有进行本地仓库和远程服务器的同步 解决方法： 如果确定本地是最新的则强行推送 git&nbsp;push&nbsp;-f&nbsp;origin&nbsp;master 20.解决Git建立远程分支关联时fatal the current branch master has no upstream branch 问题 发生的原因： 执行sh的时候推送没推上去，sh中没由写master 解决办法： git push -u origin master 21.运行项目报以下错误Error: PostCSS plugin autoprefixer requires PostCSS 8. Update PostCSS or downgrade this plugin. 发生原因：启动模板项目报错 解决办法：未找到解决办法 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"错误","slug":"错误","permalink":"http://kisskisso.com/tags/%E9%94%99%E8%AF%AF/"}]},{"title":"findIndex","slug":"findIndex","date":"2020-06-08T23:34:33.000Z","updated":"2021-01-26T08:58:12.000Z","comments":true,"path":"2020/06/09/findIndex/","link":"","permalink":"http://kisskisso.com/2020/06/09/findIndex/","excerpt":"","text":"findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。 语法： arr.findIndex(callback[, thisArg]) 参数： callback¹——&gt;针对数组中的每个元素，都会执行该回调函数，执行时会自动传入三个参数:element——&gt;当前元素。index——&gt;元素的索引。array——&gt;调用findIndex的数组。 thisArg²——&gt;（可选）执行callback时作为this对象的值。 返回值： 数组中通过提供测试函数的第一个元素的索引。否则，返回-1 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"findIndex","slug":"findIndex","permalink":"http://kisskisso.com/tags/findIndex/"}]},{"title":"选择排序","slug":"选择排序","date":"2020-06-08T13:48:10.000Z","updated":"2021-01-26T10:38:08.000Z","comments":true,"path":"2020/06/08/选择排序/","link":"","permalink":"http://kisskisso.com/2020/06/08/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","excerpt":"","text":"原理：：每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，以此循环，直至排序完毕。 代码： void select_sort(int arr[], int len){ //每次从后边选择一个最小值 for (int i = 0; i &lt; len-1; i++){ //只需选择n-1次 int min = i; for (int j = i+1; j &lt; len; j++){ if (arr[min]&gt;arr[j]){ min = j; } } if (min != i){ swap(arr[i], arr[min]); } } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与面试题","slug":"算法与面试题","permalink":"http://kisskisso.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://kisskisso.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"vscode中ESLint配置","slug":"vscode中ESLint配置","date":"2020-06-08T08:51:23.000Z","updated":"2021-01-26T09:41:50.000Z","comments":true,"path":"2020/06/08/vscode中ESLint配置/","link":"","permalink":"http://kisskisso.com/2020/06/08/vscode%E4%B8%ADESLint%E9%85%8D%E7%BD%AE/","excerpt":"在创建项目选择ESLint，创建项目之后会看到根目录下有个.eslintrc.js. 在vscode中对eslint进行配置：在根目录下创建一个文件夹.vscode，并在文件夹下创建一个名为settings.json的文件，填写一下内容：PS：按下ctrl + s保存代码：自动调试eslint修复 { \"eslint.run\":\"onType\", \"editor.codeActionsOnSave\": { \"source.fixAll.eslint\": true }, \"eslint.alwaysShowStatus\": true } 或","text":"在创建项目选择ESLint，创建项目之后会看到根目录下有个.eslintrc.js. 在vscode中对eslint进行配置：在根目录下创建一个文件夹.vscode，并在文件夹下创建一个名为settings.json的文件，填写一下内容：PS：按下ctrl + s保存代码：自动调试eslint修复 { \"eslint.run\":\"onType\", \"editor.codeActionsOnSave\": { \"source.fixAll.eslint\": true }, \"eslint.alwaysShowStatus\": true } 或 管理—-设置 然后点击工作区 点击右上角的打开设置（json）添加一下内容： { \"eslint.run\":\"onType\", \"editor.codeActionsOnSave\": { \"source.fixAll.eslint\": true }, \"eslint.alwaysShowStatus\": true } PS：核实用户设置（json）的插件设置（禁用，防止设置失效） 或 运行npm run lint 命令用来eslint检查并自动修复代码中的问题 如果上述还是报错： 直接在脚手架关掉eslint：首先在根目录下创建一个vue.config.js写入以下内容： module.exports = { lintOnSave: false // 默认是true } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ESLint","slug":"ESLint","permalink":"http://kisskisso.com/tags/ESLint/"}]},{"title":"操作符","slug":"操作符","date":"2020-06-08T04:06:51.000Z","updated":"2021-01-26T09:49:42.000Z","comments":true,"path":"2020/06/08/操作符/","link":"","permalink":"http://kisskisso.com/2020/06/08/%E6%93%8D%E4%BD%9C%E7%AC%A6/","excerpt":"算术操作符（如加号和减号）、位操作符、 关系操作符和相等操作符 一元运算符：只能操作一个值的操作符 1.递增或递减 // 递增 var age = 29; ++age; // 递减 var age = 29; --age; 2.一元加和减操作符","text":"算术操作符（如加号和减号）、位操作符、 关系操作符和相等操作符 一元运算符：只能操作一个值的操作符 1.递增或递减 // 递增 var age = 29; ++age; // 递减 var age = 29; --age; 2.一元加和减操作符 // 加 var num = 25; num = +num; // 减 var num = 25; num = -num; 位操作符：按内存中表示数值的位来操作数值。（了解？） 布尔操作：逻辑运算符 逻辑与(&amp;&amp;) –AND x1 &amp;&amp; x2 // 逻辑或(||)–OR x1 || x2 逻辑非(!)–NOT !x 双重非(!!)运算符 !!x 乘性操作符: 乘法、除法和求模 乘法 * 除法 / PS：第二个操作数除第一个操作数的计算 求模% Eg：var result = 26 % 5; 加性操作符：加与减—-+与- PS：如果要和字符串相加会被转换成字符串“ var a = 5; var b = “2” a+ b= “52”;” 关系操作符： 小于（&lt;）大于（&gt;）小于等于（&lt;=） 大于等于（&gt;=） 相等操作符： 1.相等和不相等 ​ ① == ​ ② != 2.全等和不全等 ​ ① === ​ ② !== 条件操作符：（三元） 语法 condition ? exprIfTrue : exprIfFalse 赋值操作符: 右侧的值赋给左侧的变量 // 赋值 // 乘赋值 // 除赋值 // 模赋值 // 加赋值 // 减赋值 // 左移赋值 // 有符合右移赋值 // 无符号右移赋值 var a = 10; var a *= 10; var a /= 10; var a %= 10; var a += 10; var a -= 10; var a &lt;&lt;= 10; var a &gt;&gt;= 10; var a &lt;&lt;&lt;= 10; 逗号操作符：逗号操作符多用于声明多个变量 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://kisskisso.com/tags/js/"}]},{"title":"变量与数据类型","slug":"变量与数据类型","date":"2020-06-08T00:01:50.000Z","updated":"2021-01-26T09:49:12.000Z","comments":true,"path":"2020/06/08/变量与数据类型/","link":"","permalink":"http://kisskisso.com/2020/06/08/%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"ECMAScript的变量是松散类型：可以用来保存任何类型的数据 var let const var message = 'hello word' // 右边赋值到左边 var 声明语句声明一个变量 let message = 'hello word' // let声明一个块级作用域的本地变量 const messgae = 'hello word' // 常量是块级作用域，很像使用 let 语句定义的变量。常量的值不能通过重新赋值来改变，并且不能重新声明。 注：在严格模式下，不能定义名为 eval 或 arguments 的变量，否则会导致语法错误 数据类型： 5中简单数据类型（基本数据类型）：一种复杂数据类型","text":"ECMAScript的变量是松散类型：可以用来保存任何类型的数据 var let const var message = 'hello word' // 右边赋值到左边 var 声明语句声明一个变量 let message = 'hello word' // let声明一个块级作用域的本地变量 const messgae = 'hello word' // 常量是块级作用域，很像使用 let 语句定义的变量。常量的值不能通过重新赋值来改变，并且不能重新声明。 注：在严格模式下，不能定义名为 eval 或 arguments 的变量，否则会导致语法错误 数据类型： 5中简单数据类型（基本数据类型）：一种复杂数据类型 Undefined Null Boolean Number String 未定义(一个值) 空对象指针(一个值) 布尔值 数值 字符串(不可变) true与false 由双 引号（”）或单引号（’）表示（左右引号必须匹配*） 如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null 而不是其他值 true 不一定等于 1，而 false 也不一定等于 0 十进制表示外，整数还可以通过八进制（以 8 为基数）或十六进制（以 16 为基数）的字面值 来表示。 由零或多个 16位Unicode字符组成的字符序列 八进制字面值的第一位必须是零（0），然后是八进制数字序列（0～7）。如果字面值中的 数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析。（八进制字面量在严格模式下是无效的，会导致支持的 JavaScript引擎抛出错误。）* Object 对象可以通过执行 new 操作符后跟要创建 的对象类型的名称来创建。 一组数据和功能的集合 即在 ECMAScript中， Object 类型是所有它的实例的基础。 复杂数据类型 “Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。” 构造函数（constructor） 就是 Object() Object 本质上是由一组无序的名值对组成的 typeof操作符：检测给定的数据类型[它是一个操作符而不是一个函数] PS：typeof 操作符会返回一些令人迷惑但技术上却正确的值。比如，调用 typeof null 会返回”object”，因为特殊值 null 被认为是一个空的对象引用 转换： 数值转换: 3个函数可以把非数值转换为数值：Number()、parseInt()和 parseFloat()。第一个函数， 即转型函数 Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。 转换为字符串： toString()方法 PS：null 和 undefined 没有 toString()方法 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://kisskisso.com/tags/js/"}]},{"title":"关键字与保留字(了解)","slug":"关键字与保留字(了解)","date":"2020-06-07T23:30:30.000Z","updated":"2021-01-26T10:01:16.000Z","comments":true,"path":"2020/06/08/关键字与保留字(了解)/","link":"","permalink":"http://kisskisso.com/2020/06/08/%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97(%E4%BA%86%E8%A7%A3)/","excerpt":"特定用途的关键字，来表示控制语句的开始或结束，或用于执行特定的操作。但是不能用作标识符 break do instanceof typeof case else new var catch finally return void continue for switch while debugger* function this with default if throw delete in try 关键字","text":"特定用途的关键字，来表示控制语句的开始或结束，或用于执行特定的操作。但是不能用作标识符 break do instanceof typeof case else new var catch finally return void continue for switch while debugger* function this with default if throw delete in try 关键字 保留字 abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public 保留字 …. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://kisskisso.com/tags/js/"}]},{"title":"语句","slug":"语句","date":"2020-06-07T14:54:02.000Z","updated":"2021-01-26T10:40:42.000Z","comments":true,"path":"2020/06/07/语句/","link":"","permalink":"http://kisskisso.com/2020/06/07/%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"语句以一个分号结尾;如果省略分号，则由解析器确定语句的结尾。虽然语句结尾分号不是必须的，但最好不要省略它，∵加上分号可以避免很多错误（输入不完整）压缩js的时候也不会导致压缩错误，也可以增进代码的性能。多条语句组合到一个代码块中，则需要左花括号（ { ）开头,右花括号（{）结尾 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://kisskisso.com/tags/js/"}]},{"title":"javascript概念基础","slug":"javascript概念基础","date":"2020-06-07T14:10:54.000Z","updated":"2021-01-26T09:06:14.000Z","comments":true,"path":"2020/06/07/javascript概念基础/","link":"","permalink":"http://kisskisso.com/2020/06/07/javascript%E6%A6%82%E5%BF%B5%E5%9F%BA%E7%A1%80/","excerpt":"区分大小写，不能用关键字命名，标识符则指变量、函数、属性的名字，或者函数的参数： 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；其它字符可以是字母、下划线、美元符号或数字。命名的时候首字母不能是数字 PS：不能把关键字、保留字、true、false 和null 用作标识符","text":"区分大小写，不能用关键字命名，标识符则指变量、函数、属性的名字，或者函数的参数： 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；其它字符可以是字母、下划线、美元符号或数字。命名的时候首字母不能是数字 PS：不能把关键字、保留字、true、false 和null 用作标识符 注释可以使用单行注释:两个斜杠开头 // 单行注释 也可使用块级注释:一个斜杠和一个星号（/ *）开头，以一个星号和一个斜杠（*/）结尾 /* * 这是一个多行 * （块级）注释 */ 扩展： 严格模式是为 JavaScript 定义了一种不同的 解析与执行模型。 在严格模式下，ECMAScript 3中的一些不确定的行为将得到处理，而且对某些不安全 的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码： “use strict”; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://kisskisso.com/tags/js/"}]},{"title":"文档模式(了解)","slug":"文档模式-了解","date":"2020-06-07T13:31:14.000Z","updated":"2021-01-26T10:33:30.000Z","comments":true,"path":"2020/06/07/文档模式-了解/","link":"","permalink":"http://kisskisso.com/2020/06/07/%E6%96%87%E6%A1%A3%E6%A8%A1%E5%BC%8F-%E4%BA%86%E8%A7%A3/","excerpt":"","text":"HTML文档模式是通过使用文档类型DOCTYPE来指定的。DOCTYPE中会引用对应的dtd文件，这个文件告诉浏览器按什么标准、规则来解析文件。html5标准不依赖于SGML规则，所以不需要引用dtd文件。 文档模式是：混杂模式（quirks mode） 和 标准模式（standards mode）以及IE提出的 准标准模 式（almost standards mode）。而准标准模式，则可以通过使用过渡型（transitional）或框架集型（frameset）文档类型来触发， document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活与话","slug":"生活与话","permalink":"http://kisskisso.com/categories/%E7%94%9F%E6%B4%BB%E4%B8%8E%E8%AF%9D/"}],"tags":[{"name":"js","slug":"js","permalink":"http://kisskisso.com/tags/js/"}]},{"title":"html中使用JavaScript","slug":"html中使用JavaScript","date":"2020-06-07T11:56:01.000Z","updated":"2021-01-26T09:04:22.000Z","comments":true,"path":"2020/06/07/html中使用JavaScript/","link":"","permalink":"http://kisskisso.com/2020/06/07/html%E4%B8%AD%E4%BD%BF%E7%94%A8JavaScript/","excerpt":"javascript在html中主要使用方法是&lt;script&gt;元素,有6个属性： async charset defer language src type 可选 可选(少) 可选 废用 可选 可选 立即下载脚本，不妨碍页面其它操作 指定代码字符集 延迟文档完全被解析和显示之后执行外部脚本有效 执行代码的外部文件 脚本语言内容类型 两种使用方式：直接页面嵌入js代码 和引入包含外部js文件","text":"javascript在html中主要使用方法是&lt;script&gt;元素,有6个属性： async charset defer language src type 可选 可选(少) 可选 废用 可选 可选 立即下载脚本，不妨碍页面其它操作 指定代码字符集 延迟文档完全被解析和显示之后执行外部脚本有效 执行代码的外部文件 脚本语言内容类型 两种使用方式：直接页面嵌入js代码 和引入包含外部js文件 而包含元素内部的js则是从上往下依次解析，但在使用&lt;script&gt;嵌入js代码时，不要在任何地方出现&lt;script&gt;字符串，会报错，使用转义字符“/”可以解决。 引入外部js文件使用src引入，但不能在其&lt;script&gt;下写格外的js代码，还有一点就是引入的先后顺序，则点尤为重要。引入的位置则是在body中，这样在解析js代码之前，页面的内容将完全展现在浏览器中，从而感到打开页面速度变快了。 如果想要延迟脚本，需要加defer属性也就是defer=\"defer\"，但defer只适用于外部js文件. 还有一个和他相同行为的属性async异步脚本但不同的是async的脚本并不保证按照指定它们的先后顺序执行，而是不让页面等待两个脚本下载和执行，来达到异步加载页面其它内容。 一般来说推荐使用外部引入文件： 可维护性 可缓存 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://kisskisso.com/tags/js/"}]},{"title":"1049799107101114","slug":"啥","date":"2020-06-06T01:25:49.000Z","updated":"2021-01-26T10:26:58.000Z","comments":true,"path":"2020/06/06/啥/","link":"","permalink":"http://kisskisso.com/2020/06/06/%E5%95%A5/","excerpt":"","text":"u0049u0020u0077u0061u006eu0074u0020u0074u006fu0020u0062u0065u0020u0061u0020u0068u0061u0063u006bu0065u0072u0020u0061u006eu0064u0020u006eu006fu0074u0020u0061u0020u0073u0063u0072u0069u0070u0074u0020u006bu0069u0064\\u0048\\u006f\\u0077\\u0020\\u0074\\u006f\\u0020\\u006c\\u0065\\u0061\\u0072\\u006e\\u0020\\u0077\\u0065\\u006c\\u006c document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"侧记","slug":"侧记","date":"2020-06-04T11:12:48.000Z","updated":"2021-01-31T12:11:51.363Z","comments":true,"path":"2020/06/04/侧记/","link":"","permalink":"http://kisskisso.com/2020/06/04/%E4%BE%A7%E8%AE%B0/","excerpt":"","text":"不要过分强调选择什么语言。选择一种语言，这将有助于你学习编程，并完成你的任务。😊 不要担心什么很酷或最新的东西适合你。不管怎样，你以后还是会学习新的语言。因此，只要你有基本的编程概念，并放下技术，你就能更容易地学习一门新语言。最重要的部分是玩得开心！享受你正在做的事情，或者为什么这样做？","categories":[{"name":"生活与话","slug":"生活与话","permalink":"http://kisskisso.com/categories/%E7%94%9F%E6%B4%BB%E4%B8%8E%E8%AF%9D/"}],"tags":[]},{"title":"话十一","slug":"话十一","date":"2020-06-04T10:38:31.000Z","updated":"2021-01-26T10:05:22.000Z","comments":true,"path":"2020/06/04/话十一/","link":"","permalink":"http://kisskisso.com/2020/06/04/%E8%AF%9D%E5%8D%81%E4%B8%80/","excerpt":"","text":"过高地估计了你和别人的关系，希望越大，失望也会越大。一旦期待落空，那种强烈的落差感就会让人寒心。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活与话","slug":"生活与话","permalink":"http://kisskisso.com/categories/%E7%94%9F%E6%B4%BB%E4%B8%8E%E8%AF%9D/"}],"tags":[{"name":"话","slug":"话","permalink":"http://kisskisso.com/tags/%E8%AF%9D/"}]},{"title":"小狼毫输入法","slug":"小狼毫输入法","date":"2020-06-04T07:09:58.000Z","updated":"2021-01-26T10:35:48.000Z","comments":true,"path":"2020/06/04/小狼毫输入法/","link":"","permalink":"http://kisskisso.com/2020/06/04/%E5%B0%8F%E7%8B%BC%E6%AF%AB%E8%BE%93%E5%85%A5%E6%B3%95/","excerpt":"","text":"RIME 是一个跨平台、开源、免费、且特别简洁流畅的输入法框架 (输入法引擎) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"应用与插件","slug":"应用与插件","permalink":"http://kisskisso.com/categories/%E5%BA%94%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"输入法","slug":"输入法","permalink":"http://kisskisso.com/tags/%E8%BE%93%E5%85%A5%E6%B3%95/"}]},{"title":"话十","slug":"话十","date":"2020-06-04T05:58:19.000Z","updated":"2021-01-26T10:04:08.000Z","comments":true,"path":"2020/06/04/话十/","link":"","permalink":"http://kisskisso.com/2020/06/04/%E8%AF%9D%E5%8D%81/","excerpt":"","text":"想要能获得什么 就必须付出相应的代价 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活与话","slug":"生活与话","permalink":"http://kisskisso.com/categories/%E7%94%9F%E6%B4%BB%E4%B8%8E%E8%AF%9D/"}],"tags":[{"name":"话","slug":"话","permalink":"http://kisskisso.com/tags/%E8%AF%9D/"}]},{"title":"扩展运算符(...)","slug":"扩展运算符","date":"2020-06-04T02:26:03.000Z","updated":"2021-01-26T10:11:34.000Z","comments":true,"path":"2020/06/04/扩展运算符/","link":"","permalink":"http://kisskisso.com/2020/06/04/%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"扩展运算符(spread)：是三个点（…）。主要用于函数调用/数组构造是，将数组表达式或者string在语法层面展开，但值得注意的是如果扩展运算符后面是一个空数组，则不产生任何效果，而且只有函数调用时，扩展运算符才可以放在圆括号中，否则会报Uncaught SyntaxError: Unexpected number 语法： 函数调用 myFunction(...iterableObj); 数组结构或字符串","text":"扩展运算符(spread)：是三个点（…）。主要用于函数调用/数组构造是，将数组表达式或者string在语法层面展开，但值得注意的是如果扩展运算符后面是一个空数组，则不产生任何效果，而且只有函数调用时，扩展运算符才可以放在圆括号中，否则会报Uncaught SyntaxError: Unexpected number 语法： 函数调用 myFunction(...iterableObj); 数组结构或字符串 [...iterableObj, '4', ...'hello', 6]; 进行克隆或者属性拷贝（原数组不受影响） var arr = [1, 2, 3]; var arr2 = [...arr]; // like arr.slice() arr2.push(4); // arr2 此时变成 [1, 2, 3, 4] // arr 不受影响let objClone = { ...obj }; 放置表达式? const arr = [ ...(x &gt; 0 ? ['a'] : []), 'b', ]; 扩展： 扩展运算符等价与apply的方式 function myFunction(x, y, z) { } var args = [0, 1, 2]; myFunction.apply(null, args); PS：使用new关键字调用构造函数时，不能直接使用数组+apply的方式（apply 执行的是调用 [[Call]] , 而不是构造 [[Construct]]） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ECS6","slug":"ECS6","permalink":"http://kisskisso.com/tags/ECS6/"}]},{"title":"Atom插件合集","slug":"Atom插件合集","date":"2020-06-03T12:13:57.000Z","updated":"2021-01-26T08:47:44.000Z","comments":true,"path":"2020/06/03/Atom插件合集/","link":"","permalink":"http://kisskisso.com/2020/06/03/Atom%E6%8F%92%E4%BB%B6%E5%90%88%E9%9B%86/","excerpt":"代码美化： file-icons 显示文件类型对应的图标 atom-beautify 支持大多数语言的代码格式化 pigments 颜色提示 minimap 代码预览图 提升效率： autocomplete-paths 补全路径","text":"代码美化： file-icons 显示文件类型对应的图标 atom-beautify 支持大多数语言的代码格式化 pigments 颜色提示 minimap 代码预览图 提升效率： autocomplete-paths 补全路径 atom-ternjs 补全 JS emmet 超有名的前端工具 docblockr 代码注释 vim-mode 在 Atom 上使用 Vim platformio-ide-terminal 集成终端 markdown-writer markdown工具 autoclose-html 自动闭合html标签 代码相关：react language-babel atom内开发react的核心插件 language-javascript-jsx JavaScript, ES6, ES7, react，JSX, Flow支持 atom-react-autocomplete 组件名及状态的自动补全 autocomplete-js-import 模块导入智能提示 react-es6-snippets es6写法的react snippet &amp;&amp; react-snippets 代码相关：vue language-vue atom内开发vue的核心插件 vue2-autocomplete vue中自动补全插件 vuejs2-snippets vue碎片提示 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"应用与插件","slug":"应用与插件","permalink":"http://kisskisso.com/categories/%E5%BA%94%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"Atom","slug":"Atom","permalink":"http://kisskisso.com/tags/Atom/"}]},{"title":"彻底删除软件依赖包","slug":"彻底删除软件依赖包","date":"2020-06-02T13:39:20.000Z","updated":"2021-01-26T09:53:04.000Z","comments":true,"path":"2020/06/02/彻底删除软件依赖包/","link":"","permalink":"http://kisskisso.com/2020/06/02/%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E8%BD%AF%E4%BB%B6%E4%BE%9D%E8%B5%96%E5%8C%85/","excerpt":"","text":"apt-get remove –purge xxx # 移除应用及配置apt-get autoremove # 移除没用的包 1.删除已安装包（不保留配置文件） apt-get purge 删除为满足依赖而安装且不需要的软件包（保留配置文件） apt-get autoremove 3.删除已安装的软件包（保留配置文件），不会删除依赖软件包，且保留配置文件。 apt-get remove document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"语言与Linux","slug":"语言与Linux","permalink":"http://kisskisso.com/categories/%E8%AF%AD%E8%A8%80%E4%B8%8ELinux/"}],"tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"http://kisskisso.com/tags/Linux%E5%91%BD%E4%BB%A4/"}]},{"title":"rm删除命令","slug":"rm删除命令","date":"2020-06-02T10:32:29.000Z","updated":"2021-01-26T09:34:28.000Z","comments":true,"path":"2020/06/02/rm删除命令/","link":"","permalink":"http://kisskisso.com/2020/06/02/rm%E5%88%A0%E9%99%A4%E5%91%BD%E4%BB%A4/","excerpt":"","text":"rm删除文件: rm [选项] 文件夹名 选项： -d：直接把欲删除的目录的硬连接数据删除成0，删除该目录； -f：强制删除文件或目录； -i：删除已有文件或目录之前先询问用户； -r或-R：递归处理，将指定目录下的所有文件与子目录一并处理； --preserve-root：不对根目录进行递归操作； -v：显示指令的详细执行过程。 注：指定被删除的文件列表，如果参数中含有目录，则必须加上-r或者-R选项。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"语言与Linux","slug":"语言与Linux","permalink":"http://kisskisso.com/categories/%E8%AF%AD%E8%A8%80%E4%B8%8ELinux/"}],"tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"http://kisskisso.com/tags/Linux%E5%91%BD%E4%BB%A4/"}]},{"title":"Width(了解)","slug":"Width","date":"2020-06-02T02:54:42.000Z","updated":"2021-01-26T09:47:42.000Z","comments":true,"path":"2020/06/02/Width/","link":"","permalink":"http://kisskisso.com/2020/06/02/Width/","excerpt":"","text":"width的默认值是auto。但至少包含栏4种不同的宽度表现： 1）充分利用可用空间。也叫作fill-available(了解) 2）收缩与包裹。也就是浮动、绝对定位、 inline-block元素或者table元素。 3）收缩到最小。 min-content 4）超出容器限制。max-content Ps：除非有明确的width设置，否则不会超过父容器宽度。Eg：white-space:nowrap document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"css","slug":"css","permalink":"http://kisskisso.com/tags/css/"}]},{"title":"块级元素","slug":"块级元素","date":"2020-06-01T01:07:29.000Z","updated":"2021-01-26T10:09:40.000Z","comments":true,"path":"2020/06/01/块级元素/","link":"","permalink":"http://kisskisso.com/2020/06/01/%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0/","excerpt":"“块级元素”和“display 为 block 的元素”不是一个概念。 由于“块级元素”具有换行特性，因此理论上它都可以配合 clear 属性来清除浮动 带来的影响。 使用 block或使用 table，但不会使用list-item &amp;&amp; Ps:设置display：list-item,会出现项目符号，他就会生成了一个附加盒子，学名“标记盒子”（marker box）用于存放原点、数字项目符号. .在此之后又增添了display：inline-block ——”内在盒子“也叫作”容器盒子“。","text":"“块级元素”和“display 为 block 的元素”不是一个概念。 由于“块级元素”具有换行特性，因此理论上它都可以配合 clear 属性来清除浮动 带来的影响。 使用 block或使用 table，但不会使用list-item &amp;&amp; Ps:设置display：list-item,会出现项目符号，他就会生成了一个附加盒子，学名“标记盒子”（marker box）用于存放原点、数字项目符号. .在此之后又增添了display：inline-block ——”内在盒子“也叫作”容器盒子“。 display: block和display: inline-block与display: inline-table区别： 值为block的元素盒子实际由外在的”块级盒子“和内在的”块级容器盒子“组成，而inline-block的元素则是由外在的”内联盒子“和内在的”块级容器盒子“组成，值为inline的元素则内外均是“内联盒子”.display: inline-table的话则是外面是“内联盒子”，里面是“table 盒子” display:inline-block元素既能和图文一行显示，又能直接设置宽与高，外面的盒子是inline，而里面盒子是block Ps：display：block 可以理解为block-block，虽然没什么人说就是 而宽或高作用在“容器盒子上” document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"css","slug":"css","permalink":"http://kisskisso.com/tags/css/"}]},{"title":"CSS术语","slug":"CSS术语","date":"2020-05-31T14:31:49.000Z","updated":"2021-01-26T08:52:16.000Z","comments":true,"path":"2020/05/31/CSS术语/","link":"","permalink":"http://kisskisso.com/2020/05/31/CSS%E6%9C%AF%E8%AF%AD/","excerpt":"术语： 属性： 值：整数值，数值，百分比 ， 长度值 ，颜色值 关键字：很关键的字 变量：也可以说自定义属性或级联变量","text":"术语： 属性： 值：整数值，数值，百分比 ， 长度值 ，颜色值 关键字：很关键的字 变量：也可以说自定义属性或级联变量 自定义属性： element { --main-bg-color: brown; } 局部变量： element { background-color： var(--main-bg-color) } 注：具体内容请查看MDN web docs 长度单位：px em rem等 %是不是长度单位，是一个完整的值 ​ ○相对长度单位 ​ •对字体长度单位，如 em 和 ex,rem ​ •相对视区长度单位，如 vh、vw、vmin 和 vmax ​ ○绝对长度单位 ​ •px 功能符：值以函数的形式指定 ​ ○颜色（rgba 和 hsla）、 背景图片地址（url）、元素属性值、计算（calc）和过渡效果等 属性值：属性冒号后面的所有内容统一称为属性值。 声明：属性名加上属性值就是声明 声明块：花括号（{}）包裹的一系列声明 规则或规则集：选择器+声明块 选择器： ​ ○类选择器：指以“.”这个点号开头的选择器 ​ ○ID 选择器：“#”打头，权重相当高。 ​ ○属性选择器：指含有[]的选择器 ​ ○ 伪类选择器：一般指前面有个英文冒号（:）的选择器 ​ ○伪元素选择器： 就是有连续两个冒号的选择器 关系选择器： ​ ○后代选择器：选择所有合乎规则的后代元素。空格连接。 ​ ○相邻后代选择器： 又称“子 选择器”。仅仅选择合乎规则的儿子元素，孙子、重孙元素忽略，&gt;连接。适用于 IE7 以上版本。 ​ ○ 兄弟选择器： 选择当前元素后面的所有合乎规则的兄弟元素。~连接。适用于 IE7 以上 版本。​ ○相邻兄弟选择器： 仅仅选择当前元素相邻的那个合乎规则的兄弟元素。+连接。适用于IE7 以上版本。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://kisskisso.com/tags/CSS/"}]},{"title":"CSS简述（了解）","slug":"CSS简述（了解）","date":"2020-05-31T14:00:11.000Z","updated":"2021-01-26T08:51:58.000Z","comments":true,"path":"2020/05/31/CSS简述（了解）/","link":"","permalink":"http://kisskisso.com/2020/05/31/CSS%E7%AE%80%E8%BF%B0%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89/","excerpt":"CSS 世界的诞生就是为图文信息展示服务的，CSS世界构建的基石是HTML，而HTML最具代表的两个基石&lt;\\div&gt;和&lt;\\span&gt;正好是CSS 世界中块级元素和内联级元素的代表. 对 CSS2.1 的全面支持是从微软公司的 IE8 开始的","text":"CSS 世界的诞生就是为图文信息展示服务的，CSS世界构建的基石是HTML，而HTML最具代表的两个基石&lt;\\div&gt;和&lt;\\span&gt;正好是CSS 世界中块级元素和内联级元素的代表. 对 CSS2.1 的全面支持是从微软公司的 IE8 开始的 CSS3: （1）布局更为丰富。 • 移动端的崛起，催生了 CSS3 媒介查询以及许多响应式布局特性的出现，如图片元素 的 srcset 属性、CSS 的 object-fit 属性。• 弹性盒子布局（flexible box layout） • 格栅布局（grid layout）（2）视觉表现长足进步。 • 圆角、阴影和渐变让元素更有质感。 • transform 变换让元素有更多可能。 • filter 滤镜和混合模式让 Web 轻松变成在线的 Photoshop；• animation 让动画变得非常简单。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://kisskisso.com/tags/CSS/"}]},{"title":"如何在Linux安装zsh","slug":"如何在Linux安装zsh","date":"2020-05-31T09:00:19.000Z","updated":"2021-01-28T11:30:42.000Z","comments":true,"path":"2020/05/31/如何在Linux安装zsh/","link":"","permalink":"http://kisskisso.com/2020/05/31/%E5%A6%82%E4%BD%95%E5%9C%A8Linux%E5%AE%89%E8%A3%85zsh/","excerpt":"Z shell（Zsh）是一款可用作交互式登录的shell及脚本编写的命令解释器 下载zsh sudo apt-get install zsh 下载Oh My ZSH! 根据官网的两条命令会出现以下错误 sh -c “$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused sh -c “$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)” 正在解析主机 raw.githubusercontent.com (raw.githubusercontent.com)… 0.0.0.0正在连接 raw.githubusercontent.com (raw.githubusercontent.com)|0.0.0.0|:443… 失败：Connection refused。 解决办法就是：","text":"Z shell（Zsh）是一款可用作交互式登录的shell及脚本编写的命令解释器 下载zsh sudo apt-get install zsh 下载Oh My ZSH! 根据官网的两条命令会出现以下错误 sh -c “$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused sh -c “$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)” 正在解析主机 raw.githubusercontent.com (raw.githubusercontent.com)… 0.0.0.0正在连接 raw.githubusercontent.com (raw.githubusercontent.com)|0.0.0.0|:443… 失败：Connection refused。 解决办法就是： 科学上网在浏览器输入https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh 像是保存js或者css一样。Ctrl + S保存到文件夹然后在终端运行 ./install.sh 切换shell命令： chsh -s /bin/zsh 然后重启 配置主题：主题地址 ~vim .zshrc ps:修改前需要先修改文件权限 更新oh my zsh： omz&nbsp;update 扩展: 查看当前使用的shell echo $SHELL 或 echo ＄０ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"应用与插件","slug":"应用与插件","permalink":"http://kisskisso.com/categories/%E5%BA%94%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"zsh","slug":"zsh","permalink":"http://kisskisso.com/tags/zsh/"}]},{"title":"javascript基础二","slug":"javascript基础二","date":"2020-05-26T23:04:53.000Z","updated":"2021-01-26T09:07:36.000Z","comments":true,"path":"2020/05/27/javascript基础二/","link":"","permalink":"http://kisskisso.com/2020/05/27/javascript%E5%9F%BA%E7%A1%80%E4%BA%8C/","excerpt":"","text":"javascript由以下三个不同的部分组成：核心（ecmascript）文档对象模型（dom）浏览器对象模型（bom） 规定：语法 类型 语句 关键字 保留字 操作符 对象 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://kisskisso.com/tags/js/"}]},{"title":"词汇","slug":"词汇","date":"2020-05-26T11:20:21.000Z","updated":"2021-01-26T09:54:26.000Z","comments":true,"path":"2020/05/26/词汇/","link":"","permalink":"http://kisskisso.com/2020/05/26/%E8%AF%8D%E6%B1%87/","excerpt":"","text":"能够以所有人都能理解、并且具有说服力的方式，来清晰阐明得出的结论的原因。或许可以说，让别人去接纳你所断定的结论，正好是逻辑思维的职责所在。在逻辑思维中，不能一下子从最初的论点直接跳到结论，而是应当以事实前提作为基础通过一系列判断的积累，形成起思考的调理。而其中的每一个判断，也都要清晰明确。 为此，在做出每个判决时，除了严谨的思维，果断也很重要。即便面对暧昧的灰色区域，你也可以基本一些前提，做出明确的判断（“黑色”），这才是现实中逻辑思维的使用方法。 当所有人都说错的时候，对的也变成错的。当所有人都说对的时候，错的也是对的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"我遇到的问题","slug":"遇到问题","date":"2020-05-24T11:39:11.610Z","updated":"2021-01-26T10:42:16.000Z","comments":true,"path":"2020/05/24/遇到问题/","link":"","permalink":"http://kisskisso.com/2020/05/24/%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98/","excerpt":"问题 什么是行内块元素()? 什么是块元素 (占一整行)? 什么是行内元素(一行内显示的) 阴影的设置 box-shadow :x轴 y轴 阴影大小 模糊程度 颜色 内阴影inset/外阴影(默认) 如果一分为二,需要设置模糊成度 权重问题 —- !&gt;行内式&gt;id选择器&gt;类选择器&gt;标签选择器&gt;通配符选择器&gt;浏览器默认&gt;继承选择","text":"问题 什么是行内块元素()? 什么是块元素 (占一整行)? 什么是行内元素(一行内显示的) 阴影的设置 box-shadow :x轴 y轴 阴影大小 模糊程度 颜色 内阴影inset/外阴影(默认) 如果一分为二,需要设置模糊成度 权重问题 —- !&gt;行内式&gt;id选择器&gt;类选择器&gt;标签选择器&gt;通配符选择器&gt;浏览器默认&gt;继承选择 定位 ? 绝对定位([absolute]不占位置) 相对定位(relative永远参照自身定位) 固定定位([fixed]浏览器的可是区域移动) 双伪元素的写法 (伪元素清除浮动)—( ) ① ② .clearfix:after{ .clearfix:before, content:\"\"; .clearfix:after{ display:block; contrnt:\"\"; height:0; display:table; visibitility:hidden;(隐藏) } clear: both; } .clearfix{ *zoom:1; } ​ *zoom:1(ps:应该是这个) overflow的用法 相对路径和绝对路径 按钮部分 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"问题","slug":"问题","permalink":"http://kisskisso.com/tags/%E9%97%AE%E9%A2%98/"}]},{"title":"知识点（一）","slug":"知识点","date":"2020-05-24T11:39:10.590Z","updated":"2021-01-26T10:43:54.000Z","comments":true,"path":"2020/05/24/知识点/","link":"","permalink":"http://kisskisso.com/2020/05/24/%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"知识点 ​ 1.display:none *与visitibility:hidden 前者不保留位置,后者保留位置 ​ 2.额外标签法 overflow 伪元素法 ​ 3.css3盒子模型border-box中,盒子的width包含了conter+border+padding(实际宽高) ​ 4.vertical-align:middle vertical-align:top vertical-align:bottom ​ 5.绝对定位元素可以配合除静态定位之外的所有定位属性使用。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"知识点（一）","slug":"知识点（一）","permalink":"http://kisskisso.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89/"}]},{"title":"动态路由与404","slug":"React动态路由与404","date":"2020-05-23T14:23:16.000Z","updated":"2021-01-26T09:30:04.000Z","comments":true,"path":"2020/05/23/React动态路由与404/","link":"","permalink":"http://kisskisso.com/2020/05/23/React%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E4%B8%8E404/","excerpt":"","text":"​ 动态路由在Router组件的path属性: {/url/:parameter} &lt;Router path='/xxx/:id' component={xxx} /&gt; Switch组件配置404页面： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"404","slug":"404","permalink":"http://kisskisso.com/tags/404/"}]},{"title":"React路由的基本组件","slug":"React路由的基本组件","date":"2020-05-23T14:05:13.000Z","updated":"2021-01-26T09:31:28.000Z","comments":true,"path":"2020/05/23/React路由的基本组件/","link":"","permalink":"http://kisskisso.com/2020/05/23/React%E8%B7%AF%E7%94%B1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6/","excerpt":"React路由基础组件: 1.路由组件(router components) &lt;BrowserRouter&gt; （推荐）和&lt;HashRouter&gt;两种路由组件 Eg: import { BrowserRouter } from \"react-router-dom\"; ReactDOM.render( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;, document.getElementById('root') ) 2.路由匹配组件（router matching components) &lt;Route&gt;和&lt;Switch&gt;路由匹配组件。","text":"React路由基础组件: 1.路由组件(router components) &lt;BrowserRouter&gt; （推荐）和&lt;HashRouter&gt;两种路由组件 Eg: import { BrowserRouter } from \"react-router-dom\"; ReactDOM.render( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;, document.getElementById('root') ) 2.路由匹配组件（router matching components) &lt;Route&gt;和&lt;Switch&gt;路由匹配组件。 Route:通过&lt;Route&gt;组件的path属性匹配当前地址，当匹配成功时就渲染component属性指定的组件。 import { Route, Switch } from \"react-router-dom\"; .... // 当前路径是'/about' &lt;Route path='/about' component={About}/&gt; // renders &lt;About/&gt; &lt;Route path='/contact' component={Contact}/&gt; // renders null &lt;Route component={Always}/&gt; // renders &lt;Always/&gt; Switch:遍历所有子Route元素，并仅渲染与当前地址匹配的第一个元素。实现404组件 &lt;Switch&gt; .... &lt;Route component={NoMatch}/&gt; &lt;/Switch&gt; 3.导航组件(nacigation components) Link和NavLink主要导航组件。 Link: 创建连接，渲染后为html的a标签 &lt;Link to='/'&gt;Home&lt;/Link&gt; =&gt; &lt;a to='/'&gt;Home&lt;/a&gt; NavLink:特殊类型的Link，当to属性与当前地址匹配时，自动添加active状态。 &lt;NavLink to=\"/react\" activeClassName=\"active\"&gt;React&lt;/NavLink&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"react","slug":"react","permalink":"http://kisskisso.com/tags/react/"}]},{"title":"React路由的基本使用","slug":"React路由的基本使用","date":"2020-05-23T13:01:31.000Z","updated":"2021-01-26T09:31:00.000Z","comments":true,"path":"2020/05/23/React路由的基本使用/","link":"","permalink":"http://kisskisso.com/2020/05/23/React%E8%B7%AF%E7%94%B1%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"前段路由是一套映射规则，在React中，是URL路径与组件的对应关系。就是配置路径和组件（一一对应） 1.React路由安装： $ npm i react-router-dom 2.导入路由的三个核心组件：Router / Route / Link import { BrowserRouter as Router , Route, LInk } from 'react-router-dom' 3.使用Router组件包裹整个应用（重要！！！）","text":"前段路由是一套映射规则，在React中，是URL路径与组件的对应关系。就是配置路径和组件（一一对应） 1.React路由安装： $ npm i react-router-dom 2.导入路由的三个核心组件：Router / Route / Link import { BrowserRouter as Router , Route, LInk } from 'react-router-dom' 3.使用Router组件包裹整个应用（重要！！！） &lt;Router&gt; &lt;nav className=\"menu\"&gt; // ... &lt;/nav&gt; &lt;div className=\"app\"&gt; // ...路由配置 &lt;/div&gt; &lt;/Router&gt; 4.使用Link组件作为导航菜单（路由入口） &lt;Link&gt; ... &lt;/Link&gt; 5.使用Router组件配置路由规则和要展示的组件（路由出口） class Home extends Component{ render () { return ( ..... ) } } .....b &lt;Router&gt; &lt;nav className=\"menu\"&gt; &lt;Link to=\"/home\"&gt;home&lt;/Link&gt; &lt;/nav&gt; &lt;div className=\"app\"&gt; &lt;Route path=\"/home\" component={Home} /&gt; &lt;/div&gt; &lt;/Router&gt; 注：Router组件：包裹整个应用，一个React应用只需使用一次 ​ Router Ｌink组件：须在Ｒouter组件内部 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"react","slug":"react","permalink":"http://kisskisso.com/tags/react/"}]},{"title":"React脚手架","slug":"React脚手架","date":"2020-05-23T12:14:43.000Z","updated":"2021-01-26T09:30:36.000Z","comments":true,"path":"2020/05/23/React脚手架/","link":"","permalink":"http://kisskisso.com/2020/05/23/React%E8%84%9A%E6%89%8B%E6%9E%B6/","excerpt":"使用脚手架初始化项目： 1.初始化项目，命令npx create-react-app xxx 2.启动项目，在项目根目录执行命令：npm start public/ // 公共资源 index.html // 首页（必须） manifest.json src / index.js // 项目入口文件（必须） App.js // 项目的根组件 App.test.js // App组件的测试文件 serviceworker.js // 实现pwa（可选） 扩展：","text":"使用脚手架初始化项目： 1.初始化项目，命令npx create-react-app xxx 2.启动项目，在项目根目录执行命令：npm start public/ // 公共资源 index.html // 首页（必须） manifest.json src / index.js // 项目入口文件（必须） App.js // 项目的根组件 App.test.js // App组件的测试文件 serviceworker.js // 实现pwa（可选） 扩展： npx是npm V5.2.0引入的一条命令，提升包内提供的命令行工具使用体验 在脚手架使用react： 1.导入react 和 react-dom 两个包 2.调用React.createElement()方法创建react元素 3.调用ReactDOM.render()方法渲染react元素到页面 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"react","slug":"react","permalink":"http://kisskisso.com/tags/react/"}]},{"title":"JQuery效果","slug":"JQuery效果","date":"2020-05-21T01:36:28.000Z","updated":"2021-01-26T10:55:02.000Z","comments":true,"path":"2020/05/21/JQuery效果/","link":"","permalink":"http://kisskisso.com/2020/05/21/JQuery%E6%95%88%E6%9E%9C/","excerpt":"常见的动画效果：动画或效果一旦触发就会执行，如果触发多次，就造成多个动画或效果排队执行。但可以停止动画排队：stop() 显示隐藏 滑入滑出 淡入淡出 自定义动画 show() slideDown() fadein() animate() hide() slideUp() fadeOut() toggle() slideToggle() fadeToggle() fadeTo()××× [speed,[easing],[fn] [speed,[easing],[fn] [speed,[easing],[fn] [params,speed,[easing],[fn] 显示语法：show([speed,[easing],[fn] )","text":"常见的动画效果：动画或效果一旦触发就会执行，如果触发多次，就造成多个动画或效果排队执行。但可以停止动画排队：stop() 显示隐藏 滑入滑出 淡入淡出 自定义动画 show() slideDown() fadein() animate() hide() slideUp() fadeOut() toggle() slideToggle() fadeToggle() fadeTo()××× [speed,[easing],[fn] [speed,[easing],[fn] [speed,[easing],[fn] [params,speed,[easing],[fn] 显示语法：show([speed,[easing],[fn] ) 参数：都可以省略，无动画直接显示。 speed：三种预订速度之一的字符串（“slow”， “noemal”，“fast”）或者表示动画时长的毫秒数值（1000） easing：(Optional)用来指定切换效果，默认“swing”，可选“linear”。 fn：回调函数，在动画完成时执行的函数，且每个元素执行一次。 隐藏语法：hide( [speed,[easing],[fn] ) 同上略…. 切换语法：toggle( [speed,[easing],[fn]) 同上略….注：没特殊情况，则不带参数，直接显示隐藏即可 ×××：参数：opacity 透明度必须写，取值0～1之间。speed：必须写 自定义动画：模拟上面所有动画！！！ 语法：animate(params, [speed],[easing],[fn]) params：更改样式属性则以对象形式传递，必须写。属性名可以不带引号，复合属性则需采用驼峰命名法 停止动画排队：stop()方法用于停止动画或效果。须写到动画或效果前面，相当于停止结束上一次动画。 也就是说每次使用动画前，先调用stop()在调用动画。 事件的切换：hover([over], out)类似css中伪类 :hover over：鼠标移到元素上触发的函数（相当于mouseenter） out：鼠标移出元素上触发的函数（相当于mouseleave） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JQ","slug":"JQ","permalink":"http://kisskisso.com/tags/JQ/"}]},{"title":"React表单处理","slug":"React表单处理","date":"2020-05-20T12:25:39.000Z","updated":"2021-01-26T09:29:00.000Z","comments":true,"path":"2020/05/20/React表单处理/","link":"","permalink":"http://kisskisso.com/2020/05/20/React%E8%A1%A8%E5%8D%95%E5%A4%84%E7%90%86/","excerpt":"","text":"受控组件(双向绑定（v-model）)： &nbsp;&nbsp; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"react","slug":"react","permalink":"http://kisskisso.com/tags/react/"}]},{"title":"类组件中state和setState()","slug":"类组件中state和setState","date":"2020-05-20T03:52:53.000Z","updated":"2021-01-26T10:12:04.000Z","comments":true,"path":"2020/05/20/类组件中state和setState/","link":"","permalink":"http://kisskisso.com/2020/05/20/%E7%B1%BB%E7%BB%84%E4%BB%B6%E4%B8%ADstate%E5%92%8CsetState/","excerpt":"state的基本使用：状态（state）即是数据,是组件内部的私有数据，只能在组件内部使用，且state的值是对象，表示一个组件中可以有多个数据 初始语法： class KEL extends React.Component { constructor() { super () { // 初始化state this.state = { count: 0 } } render () { return { &lt;div&gt;有状态组件&lt;/div&gt; } } } } 简化语法：","text":"state的基本使用：状态（state）即是数据,是组件内部的私有数据，只能在组件内部使用，且state的值是对象，表示一个组件中可以有多个数据 初始语法： class KEL extends React.Component { constructor() { super () { // 初始化state this.state = { count: 0 } } render () { return { &lt;div&gt;有状态组件&lt;/div&gt; } } } } 简化语法： class KEL extends React.Component { // 初始化state state = { count: 0 } render () { return { &lt;div&gt;有状态组件, {this.state.count}&lt;/div&gt; } } } 获取状态：this.state {this.state.count} setState()修改状态：注：不要直接修改state中的值，【this.state.num=2】&lt;-错误。【数据驱动视图】 语法：this.setState({key:val, key2:val2}) 作用：修改state和更新UI Eg： // 正确 this.setState({ count: this.state.count + 1 }) // 错误 this.state.count += 1 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"react","slug":"react","permalink":"http://kisskisso.com/tags/react/"}]},{"title":"类组件中this指向(注)","slug":"类组件中this指向","date":"2020-05-20T02:03:29.000Z","updated":"2021-01-26T10:13:00.000Z","comments":true,"path":"2020/05/20/类组件中this指向/","link":"","permalink":"http://kisskisso.com/2020/05/20/%E7%B1%BB%E7%BB%84%E4%BB%B6%E4%B8%ADthis%E6%8C%87%E5%90%91/","excerpt":"只有类组件下有这个问题（函数组件没有this） 利用bind修改this指向组件： class HEL extends React.Comonent { num = 0; addNum() { this.num += 1; alert(this.num) } render () { return ( &lt;div&gt; &lt;h1 onClick={this.addNum.bing(this)}&gt;数字加一&lt;/h1&gt; &lt;/div&gt; ) } } 利用箭头函数方法（推荐）：该语法是实验性语法，由于babel的存在可以直接使用","text":"只有类组件下有这个问题（函数组件没有this） 利用bind修改this指向组件： class HEL extends React.Comonent { num = 0; addNum() { this.num += 1; alert(this.num) } render () { return ( &lt;div&gt; &lt;h1 onClick={this.addNum.bing(this)}&gt;数字加一&lt;/h1&gt; &lt;/div&gt; ) } } 利用箭头函数方法（推荐）：该语法是实验性语法，由于babel的存在可以直接使用 class HEL extends React.Comonent { num = 0; addNum = () =&gt; { this.num += 1; alert(this.num) } render () { return ( &lt;div&gt; &lt;h1 onClick={this.addNum.bing(this)}&gt;数字加一&lt;/h1&gt; &lt;/div&gt; ) } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"react","slug":"react","permalink":"http://kisskisso.com/tags/react/"}]},{"title":"React事件处理","slug":"React事件处理","date":"2020-05-19T13:49:40.000Z","updated":"2021-01-26T09:32:04.000Z","comments":true,"path":"2020/05/19/React事件处理/","link":"","permalink":"http://kisskisso.com/2020/05/19/React%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/","excerpt":"​ 事件绑定：React事件绑定语法与DOM事件语法相似，而语法则是on+事件名称={事件处理程序fn}需要注意的是React事件则采用小驼峰命名法：除第一个单词之外，其他单词首字母大写。 类 组件绑定： class KL extends React.Component { headrClick () { ... } render () { return ( &lt;button onClick={this.headrClick}&gt;&lt;/button&gt; ) } } 函数组件绑定:","text":"​ 事件绑定：React事件绑定语法与DOM事件语法相似，而语法则是on+事件名称={事件处理程序fn}需要注意的是React事件则采用小驼峰命名法：除第一个单词之外，其他单词首字母大写。 类 组件绑定： class KL extends React.Component { headrClick () { ... } render () { return ( &lt;button onClick={this.headrClick}&gt;&lt;/button&gt; ) } } 函数组件绑定: function KL() { function headeClick() { ... } return ( &lt;button onClick={headeClick}&gt;&lt;/button&gt; ) } 事件对象: 通过处理程序的默认参数获取到事件对象，但是在React中事件对象叫做：合成事件（对象）&lt;—–兼容所有浏览器——-&gt; function hadeClick (e) { e.preventDefault() } &lt;a href=\"...\" onClick={hadeClick}&gt;&lt;/a&gt; // 阻止跳转 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"react","slug":"react","permalink":"http://kisskisso.com/tags/react/"}]},{"title":"es5类的创建与继承","slug":"es5类的创建与继承","date":"2020-05-19T12:16:08.000Z","updated":"2021-01-26T08:57:10.000Z","comments":true,"path":"2020/05/19/es5类的创建与继承/","link":"","permalink":"http://kisskisso.com/2020/05/19/es5%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%BB%A7%E6%89%BF/","excerpt":"父类：","text":"父类： function Parent(name) { // 实例的属性 this.name = name } // 定义静态属性 =》不在实例 Parent.a = 1; Parent.fn = function () { console.log(this.abc, Parent.a) } 原先方法： // 原型方法 Parent.prototype.getName = function () { console.log(this.name) } // 子类：继承 function Child(name) { // 继承实例的属性 Parent.call(this, name) } // Child.prototype = new Parent(); Child.prototype = Object.create(Parent.prototype, { constructor: { value: Child } }) // 测试 let Chi = new Child('普京'); console.log(Chi) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与面试题","slug":"算法与面试题","permalink":"http://kisskisso.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://kisskisso.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"JQuery样式操作","slug":"JQuery样式操作","date":"2020-05-19T02:29:51.000Z","updated":"2021-01-26T09:11:44.000Z","comments":true,"path":"2020/05/19/JQuery样式操作/","link":"","permalink":"http://kisskisso.com/2020/05/19/JQuery%E6%A0%B7%E5%BC%8F%E6%93%8D%E4%BD%9C/","excerpt":"Query中常用的样式操作：Jcss()和设置类样式方法 操作css方法：JQuery使用css方法修改简单元素样式，操作类，修改多个样式 // 1.参数只写属性名，则返回属性值 var strColor = $(this).css('color'); // 2.参数是属性名，属性值，逗号分隔（英文），设置一组样式，属性须加引号，如果是数字可不用加单位和引号 $(this).css(\"color\", \"red\"); // 3.参数可以是对象形式(css()用于样式少时) $(this).css({\"color\":\"white\", \"font-size\":\"20px\"}); 设置类样式：等同于classList，可以操作样式，注：操作类不加点且不会覆盖原先的类名","text":"Query中常用的样式操作：Jcss()和设置类样式方法 操作css方法：JQuery使用css方法修改简单元素样式，操作类，修改多个样式 // 1.参数只写属性名，则返回属性值 var strColor = $(this).css('color'); // 2.参数是属性名，属性值，逗号分隔（英文），设置一组样式，属性须加引号，如果是数字可不用加单位和引号 $(this).css(\"color\", \"red\"); // 3.参数可以是对象形式(css()用于样式少时) $(this).css({\"color\":\"white\", \"font-size\":\"20px\"}); 设置类样式：等同于classList，可以操作样式，注：操作类不加点且不会覆盖原先的类名 1.添加类 $(\"div\").addClass(\"current\"); 2.删除类 $(\"div\").removeClass(\"current\"); 3.切换类 $(\"div\").toggleClass(\"current\"); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JQ","slug":"JQ","permalink":"http://kisskisso.com/tags/JQ/"}]},{"title":"React组件","slug":"React组件","date":"2020-05-19T01:51:15.000Z","updated":"2021-01-26T09:32:34.000Z","comments":true,"path":"2020/05/19/React组件/","link":"","permalink":"http://kisskisso.com/2020/05/19/React%E7%BB%84%E4%BB%B6/","excerpt":"React组件创建：特点：复用 独立 可组合 函数创建：使用JS函数或箭头函数创建的组件 import React from 'react'; const Dnz = () =&gt; { return ( &lt;div&gt; &lt;h2&gt;函数组件&lt;/h2&gt; &lt;p onClick={fn}&gt;点击&lt;/p&gt; &lt;/div&gt; ) } ReactDOM.render(&lt;Dnz /&gt;, root) 【注意事项： ​ 1.类与函数名称都需以大写字母开头，使用大驼峰命名法。 ​ 2.函数组件必须有返回值，表示该组件的结构，而类组件则需提供render()方法。","text":"React组件创建：特点：复用 独立 可组合 函数创建：使用JS函数或箭头函数创建的组件 import React from 'react'; const Dnz = () =&gt; { return ( &lt;div&gt; &lt;h2&gt;函数组件&lt;/h2&gt; &lt;p onClick={fn}&gt;点击&lt;/p&gt; &lt;/div&gt; ) } ReactDOM.render(&lt;Dnz /&gt;, root) 【注意事项： ​ 1.类与函数名称都需以大写字母开头，使用大驼峰命名法。 ​ 2.函数组件必须有返回值，表示该组件的结构，而类组件则需提供render()方法。 ​ 3.函数的组件标签闭合，而类的render()方法须有返回值表示该组件的结构 】 class创建组件：使用ES6的class关键字创建的组件 类组件应继承React.Component父类，从而可以使用父类中提供的方法和属性。有关继承请访问es5类的创建与继承与es6类的创建与继承 import React from 'react'; class Hello extends React Component { render() { return &lt;div&gt;Hello Class Component!&lt;/div&gt; } } ReactDOM.render(&lt;Hello /&gt;, root) 组件抽离：将每个组件放到单独的JS文件中。独立体放单独JS文件中 步骤: ​ 1.创建JS文件 ​ 2.在JS中导入React核心包 ​ 3.创建组件（函数或类） ​ 4.在JS中导出组件 ​ 5.在index.js中导入组件 ​ 6.渲染组件 扩展： 状态组件与无状态组件 函数组件：无状态组件 类组件class：有状态组件 区别： 类组件有自己的状态，负责更新 UI，让页面“动” 起来 （响应式） 函数组件没有自己的状态，只负责数据展示（静） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"react","slug":"react","permalink":"http://kisskisso.com/tags/react/"}]},{"title":"数组","slug":"数组","date":"2020-05-19T01:31:14.000Z","updated":"2021-01-26T10:30:28.000Z","comments":true,"path":"2020/05/19/数组/","link":"","permalink":"http://kisskisso.com/2020/05/19/%E6%95%B0%E7%BB%84/","excerpt":"","text":"javascript的Array对象是用于构造数组的全局对象，数组是类似于列表的高阶对象。 创建数组：属性——Array.length于Array.prototype[] var fruits = ['App', 'ios'] // 打印数组 console.log(fruits.length) 遍历数组： fruits.forEach( (item, index, array) =&gt; { console.log(item, index); }) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://kisskisso.com/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"JSX基本使用","slug":"JSX基本使用","date":"2020-05-18T07:54:45.000Z","updated":"2021-01-26T09:15:16.000Z","comments":true,"path":"2020/05/18/JSX基本使用/","link":"","permalink":"http://kisskisso.com/2020/05/18/JSX%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"Babel会把JSX转译成一个名为React.createElement()函数调用 原生创建recat元素： const span = React.createElement('span', null, 'span') 用JSX创建react元素： const ul = &lt;div&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;hello worde!!!&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt; JSX中使用JS表达式： 语法：{JavaScript表达式} 注：语法中是单大括号，不是双大括号","text":"Babel会把JSX转译成一个名为React.createElement()函数调用 原生创建recat元素： const span = React.createElement('span', null, 'span') 用JSX创建react元素： const ul = &lt;div&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;hello worde!!!&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt; JSX中使用JS表达式： 语法：{JavaScript表达式} 注：语法中是单大括号，不是双大括号 const name = 'kl' const div = ( &lt;div&gt;XXX:{name}&lt;/div&gt; ) 使用jsx注意事项：自身也是js表达式 ​ 1.添加类名需小驼峰命名法：第一个单词首字母小写，从第二个单词及以后的首字母是大写开头 ​ 2.声明的jsx元素需圆括号下只能有一个根元素 &nbsp; 3.不能在{}中出现语句和对象（if/for,{a:555}等） 数据类型支持： 单大括号：值、变量、函数调用、三元运算符、数组（基本类型，jsx） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"react","slug":"react","permalink":"http://kisskisso.com/tags/react/"}]},{"title":"React初体验","slug":"React初体验","date":"2020-05-18T03:09:50.000Z","updated":"2021-01-26T09:29:34.000Z","comments":true,"path":"2020/05/18/React初体验/","link":"","permalink":"http://kisskisso.com/2020/05/18/React%E5%88%9D%E4%BD%93%E9%AA%8C/","excerpt":"","text":"引入react react-dom 安装包：npm Install react react-dom react：创建元素 react-dom：渲染元素 创建元素： const h1 = React.createElement('h1', {classNmae: 'k', id: 'hh'}, 'hello react') 渲染元素： React.render(div, document.getElementById('app')) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"react","slug":"react","permalink":"http://kisskisso.com/tags/react/"}]},{"title":"JQuery选择器","slug":"JQuery选择器","date":"2020-05-18T02:07:00.000Z","updated":"2021-01-26T09:11:06.000Z","comments":true,"path":"2020/05/18/JQuery选择器/","link":"","permalink":"http://kisskisso.com/2020/05/18/JQuery%E9%80%89%E6%8B%A9%E5%99%A8/","excerpt":"JQuery选择器：原生 JS 获取元素方式很多，很杂，而且兼容性情况不一致，因此 jQuery 做了封装，使获取元素统一标准。 基础选择器： $('选择器') // 直接写css选择器，需加引号 名称 用法 描述 ID选择器 $(“#id”) 获取指定的ID的元素 全选选择器 $(‘*’) 匹配所有元素 类选择器 $(‘.class’) 获取同一类class的元素 标签选择器 $(‘div’) 获取同一类标签的全有元素 并集选择器 $(‘div,p,li’) 选取多个元素 交集选择器 $(‘li.current’) 交集元素 层级选择器：后代选择器和子代选择器","text":"JQuery选择器：原生 JS 获取元素方式很多，很杂，而且兼容性情况不一致，因此 jQuery 做了封装，使获取元素统一标准。 基础选择器： $('选择器') // 直接写css选择器，需加引号 名称 用法 描述 ID选择器 $(“#id”) 获取指定的ID的元素 全选选择器 $(‘*’) 匹配所有元素 类选择器 $(‘.class’) 获取同一类class的元素 标签选择器 $(‘div’) 获取同一类标签的全有元素 并集选择器 $(‘div,p,li’) 选取多个元素 交集选择器 $(‘li.current’) 交集元素 层级选择器：后代选择器和子代选择器 名称 用法 描述 自带选择器 $(‘ul&gt;li’) 使用&gt;号获取亲儿子层级的元素；注：并不会获取孙子层级的元素 后代选择器 $(‘ul li’) 使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等 筛选选择器：选择满足条件进行筛选选择 语法 用法 描述 :first $(‘li:first’) 获取第一个li元素 :last $(‘li:last’) 获取最后一个li元素 :eq(index) $(‘li:eq(2)’) 获取到的li元素中，选择索引号为2的元素，索引号index从0开始 :odd $(‘li:odd’) 获取到li元素中，选择索引号为奇数的元素 :even $(‘li:even’) 获取到的li元素中，选择索引号为偶数的元素 扩展： 语法 用法 说明 parent() $(‘li’).parent() 查找父级 children(selector) $(‘ul’).children(‘li’) 相当于$(‘ul&gt;li’),最近一级 find(selector) $(‘ul’).find(“li”) 相当于$(“ul li”),后代选择器 siblings(selector) $(‘.first’).siblings(“li”) 查找兄弟节点，不包括本身 nextAll([expr]) $(‘.first’).nextAll() 查找当前元素之后所有的同辈元素 prevtAll([expr]) $(‘.last’).prevtAll() 查找当前元素之前所有的同辈元素 hasClass(class) $(‘div’).hasClass(‘protected’) 检查当前的元素是否有某个特定的类 eq(index) $(‘li’).eq(2) 相当于$(‘li:eq(2)’),index从0开始 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JQ","slug":"JQ","permalink":"http://kisskisso.com/tags/JQ/"}]},{"title":"心流","slug":"心流","date":"2020-05-18T01:02:00.000Z","updated":"2021-01-26T10:37:50.000Z","comments":true,"path":"2020/05/18/心流/","link":"","permalink":"http://kisskisso.com/2020/05/18/%E5%BF%83%E6%B5%81/","excerpt":"","text":"心流的成因和特征：第一，注意力。(自律、集中注意力)第二，有一个愿意为之付出的目标。(目标是什么不要紧，只要那目标将他的注意力集中于此)第三，有即时的回馈。第四，因全神贯注于此，日常恼人的繁琐被忘却和屏蔽。第五，达到了忘我的状态。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"爱好心理学","slug":"爱好心理学","permalink":"http://kisskisso.com/categories/%E7%88%B1%E5%A5%BD%E5%BF%83%E7%90%86%E5%AD%A6/"}],"tags":[{"name":"心流","slug":"心流","permalink":"http://kisskisso.com/tags/%E5%BF%83%E6%B5%81/"}]},{"title":"安装依赖包","slug":"Linux安装依赖包","date":"2020-05-17T23:41:12.000Z","updated":"2021-01-26T09:22:44.000Z","comments":true,"path":"2020/05/18/Linux安装依赖包/","link":"","permalink":"http://kisskisso.com/2020/05/18/Linux%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E5%8C%85/","excerpt":"","text":"apt -f install document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"语言与Linux","slug":"语言与Linux","permalink":"http://kisskisso.com/categories/%E8%AF%AD%E8%A8%80%E4%B8%8ELinux/"}],"tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"http://kisskisso.com/tags/Linux%E5%91%BD%E4%BB%A4/"}]},{"title":"如何安装linux中安装typora","slug":"如何安装linux中安装typora","date":"2020-05-17T23:32:52.000Z","updated":"2021-01-26T10:22:10.000Z","comments":true,"path":"2020/05/18/如何安装linux中安装typora/","link":"","permalink":"http://kisskisso.com/2020/05/18/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85linux%E4%B8%AD%E5%AE%89%E8%A3%85typora/","excerpt":"Typora给您既是读者又是作家的无缝体验。它删除了预览窗口，模式切换器，降价源代码的语法符号以及所有其他不必要的干扰。相反，它提供了真正的实时预览功能，可帮助您专注于内容本身。 如何在linux中安装typora： 第一步： wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add - 第二步：","text":"Typora给您既是读者又是作家的无缝体验。它删除了预览窗口，模式切换器，降价源代码的语法符号以及所有其他不必要的干扰。相反，它提供了真正的实时预览功能，可帮助您专注于内容本身。 如何在linux中安装typora： 第一步： wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add - 第二步： sudo add-apt-repository 'deb https://typora.io/linux ./' sudo apt-get update 第三步： sudo apt-get install typora 如果报错请查看12条 或者到官网下载 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"应用与插件","slug":"应用与插件","permalink":"http://kisskisso.com/categories/%E5%BA%94%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"typora","slug":"typora","permalink":"http://kisskisso.com/tags/typora/"}]},{"title":"remove卸载命令","slug":"remove卸载命令","date":"2020-05-17T23:30:45.000Z","updated":"2021-01-26T09:33:24.000Z","comments":true,"path":"2020/05/18/remove卸载命令/","link":"","permalink":"http://kisskisso.com/2020/05/18/remove%E5%8D%B8%E8%BD%BD%E5%91%BD%E4%BB%A4/","excerpt":"","text":"sudo apt-get remove XXX document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"语言与Linux","slug":"语言与Linux","permalink":"http://kisskisso.com/categories/%E8%AF%AD%E8%A8%80%E4%B8%8ELinux/"}],"tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"http://kisskisso.com/tags/Linux%E5%91%BD%E4%BB%A4/"}]},{"title":"Linux下安装.ded文件","slug":"Linux下安装-ded文件","date":"2020-05-17T23:27:08.000Z","updated":"2021-01-26T09:24:10.000Z","comments":true,"path":"2020/05/18/Linux下安装-ded文件/","link":"","permalink":"http://kisskisso.com/2020/05/18/Linux%E4%B8%8B%E5%AE%89%E8%A3%85-ded%E6%96%87%E4%BB%B6/","excerpt":"","text":"cd到安装包目录 dpkg -i 安装包名字 注：如果无法安装请尝试一下方法 cd到安装包目录 rpm -ivh 安装包名字 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"语言与Linux","slug":"语言与Linux","permalink":"http://kisskisso.com/categories/%E8%AF%AD%E8%A8%80%E4%B8%8ELinux/"}],"tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"http://kisskisso.com/tags/Linux%E5%91%BD%E4%BB%A4/"}]},{"title":"话玖","slug":"话玖","date":"2020-05-17T02:57:08.000Z","updated":"2021-01-26T10:03:12.000Z","comments":true,"path":"2020/05/17/话玖/","link":"","permalink":"http://kisskisso.com/2020/05/17/%E8%AF%9D%E7%8E%96/","excerpt":"","text":"有时候 周围无意的一句话远比施暴的人更伤人 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活与话","slug":"生活与话","permalink":"http://kisskisso.com/categories/%E7%94%9F%E6%B4%BB%E4%B8%8E%E8%AF%9D/"}],"tags":[{"name":"话","slug":"话","permalink":"http://kisskisso.com/tags/%E8%AF%9D/"}]},{"title":"chmod777与555","slug":"chmod777与555","date":"2020-05-17T02:04:05.000Z","updated":"2021-01-26T08:49:48.000Z","comments":true,"path":"2020/05/17/chmod777与555/","link":"","permalink":"http://kisskisso.com/2020/05/17/chmod777%E4%B8%8E555/","excerpt":"","text":"chmod修改文件与文件夹权限：chmod 777 xxx 所有用户都有读、写、执行权限。chmod 755 xxx 所有用户都是读取、执行权限 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"语言与Linux","slug":"语言与Linux","permalink":"http://kisskisso.com/categories/%E8%AF%AD%E8%A8%80%E4%B8%8ELinux/"}],"tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"http://kisskisso.com/tags/Linux%E5%91%BD%E4%BB%A4/"}]},{"title":"JQuery基本使用","slug":"JQuery基本使用","date":"2020-05-16T12:21:38.000Z","updated":"2021-01-26T09:09:52.000Z","comments":true,"path":"2020/05/16/JQuery基本使用/","link":"","permalink":"http://kisskisso.com/2020/05/16/JQuery%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"JQuery中常见的两种入口函数： 第一种：简单易用 $(function () { ... // 此处是页面DOM加载完成的入口 }) 第二种：繁琐，（不推荐） $(document).ready(function() { ... 此处是页面DOM加载完成的入口 }) JQuery中的顶级对象$: $是JQuery的顶级对象，相当于原生JavaScript中的window。把元素利用*包装成JQuery对象。","text":"JQuery中常见的两种入口函数： 第一种：简单易用 $(function () { ... // 此处是页面DOM加载完成的入口 }) 第二种：繁琐，（不推荐） $(document).ready(function() { ... 此处是页面DOM加载完成的入口 }) JQuery中的顶级对象$: $是JQuery的顶级对象，相当于原生JavaScript中的window。把元素利用*包装成JQuery对象。 JQuery对象和DOM对象： JQuery方法和原生js获取的元素是不一样的： ​ 1.用原生的js获取来的对象就是DOM对象 ​ 2.JQuery方法获取的元素就是JQuery对象 JQuery对象本质是：利用$对DOM对象包装后产生的对象（伪数组形式存储） 注：只有JQuery对象才能使用JQuery方法，DOM对象册使用原生的JavaScript方法.常用的是把DOM对象转换为JQuery对象 JQuery对象和DOM对象转换： 原生的一些属性和方法JQuery没有封装，需将JQuery对象转换为DOM对象才能使用 // 1.DOM对象转换成JQuery对象 var box = document.getElementById('box') // 获取 var JQueryObject = $(box) // 把DOM对象转换为JQuery对象 // 2.JQuery对象转换为DOM对象 var domObject = $('div')[0] // 第一种 var domObject = $('div').get[0] // 第二种 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JQ","slug":"JQ","permalink":"http://kisskisso.com/tags/JQ/"}]},{"title":"如何下载公司github的代码","slug":"如何下载公司github的代码","date":"2020-05-16T07:02:51.000Z","updated":"2021-01-26T10:23:26.000Z","comments":true,"path":"2020/05/16/如何下载公司github的代码/","link":"","permalink":"http://kisskisso.com/2020/05/16/%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BD%E5%85%AC%E5%8F%B8github%E7%9A%84%E4%BB%A3%E7%A0%81/","excerpt":"","text":"找个地方命令窗口输入git clone 仓库地址等待…. cd 仓库名 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与面试题","slug":"算法与面试题","permalink":"http://kisskisso.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://kisskisso.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"返回上两级目录","slug":"Linux的cd命令","date":"2020-05-16T06:37:25.000Z","updated":"2021-01-26T09:23:10.000Z","comments":true,"path":"2020/05/16/Linux的cd命令/","link":"","permalink":"http://kisskisso.com/2020/05/16/Linux%E7%9A%84cd%E5%91%BD%E4%BB%A4/","excerpt":"","text":"cd ../..返回上两级目录 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"语言与Linux","slug":"语言与Linux","permalink":"http://kisskisso.com/categories/%E8%AF%AD%E8%A8%80%E4%B8%8ELinux/"}],"tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"http://kisskisso.com/tags/Linux%E5%91%BD%E4%BB%A4/"}]},{"title":"话八","slug":"话八","date":"2020-05-16T06:25:28.000Z","updated":"2021-01-26T10:02:44.000Z","comments":true,"path":"2020/05/16/话八/","link":"","permalink":"http://kisskisso.com/2020/05/16/%E8%AF%9D%E5%85%AB/","excerpt":"","text":"不是所有的事情都能两全 任何事情 不管是好是坏 都要付出代价 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活与话","slug":"生活与话","permalink":"http://kisskisso.com/categories/%E7%94%9F%E6%B4%BB%E4%B8%8E%E8%AF%9D/"}],"tags":[{"name":"话","slug":"话","permalink":"http://kisskisso.com/tags/%E8%AF%9D/"}]},{"title":"话七","slug":"话七","date":"2020-05-16T06:14:37.000Z","updated":"2021-01-26T10:03:40.000Z","comments":true,"path":"2020/05/16/话七/","link":"","permalink":"http://kisskisso.com/2020/05/16/%E8%AF%9D%E4%B8%83/","excerpt":"","text":"这世上那来什么幸与不幸 那全都是看你怎么解读 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活与话","slug":"生活与话","permalink":"http://kisskisso.com/categories/%E7%94%9F%E6%B4%BB%E4%B8%8E%E8%AF%9D/"}],"tags":[{"name":"话","slug":"话","permalink":"http://kisskisso.com/tags/%E8%AF%9D/"}]},{"title":"前端交互动画优化","slug":"前端交互动画优化","date":"2020-05-16T02:07:06.000Z","updated":"2021-01-26T10:18:28.000Z","comments":true,"path":"2020/05/16/前端交互动画优化/","link":"","permalink":"http://kisskisso.com/2020/05/16/%E5%89%8D%E7%AB%AF%E4%BA%A4%E4%BA%92%E5%8A%A8%E7%94%BB%E4%BC%98%E5%8C%96/","excerpt":"","text":"最基本的优化思路就是优化DOM的读写操作 减少对DOM元素读操作： 缓存DOM引用 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与面试题","slug":"算法与面试题","permalink":"http://kisskisso.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://kisskisso.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"touch和mkdir","slug":"touch和mkdir","date":"2020-05-15T07:28:54.000Z","updated":"2021-01-26T09:39:22.000Z","comments":true,"path":"2020/05/15/touch和mkdir/","link":"","permalink":"http://kisskisso.com/2020/05/15/touch%E5%92%8Cmkdir/","excerpt":"","text":"创建文件：touch XXX 创建文件夹：mkdir XXX document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"语言与Linux","slug":"语言与Linux","permalink":"http://kisskisso.com/categories/%E8%AF%AD%E8%A8%80%E4%B8%8ELinux/"}],"tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"http://kisskisso.com/tags/Linux%E5%91%BD%E4%BB%A4/"}]},{"title":"Vue如何实现组件缓存","slug":"Vue如何实现组件缓存","date":"2020-05-15T04:24:33.000Z","updated":"2021-01-26T09:44:26.000Z","comments":true,"path":"2020/05/15/Vue如何实现组件缓存/","link":"","permalink":"http://kisskisso.com/2020/05/15/Vue%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E7%BC%93%E5%AD%98/","excerpt":"keep-alive：组件级缓存 两种模式：全局缓存/局部组件缓存 页面跳转到详情页面时，需要保持列表页的滚动条的深度，等返回的时候也然在这个位置。 使用方式：keep-alive是抽象组件（或称为功能型组件），实际不会被渲染在 DOM树中。它的作用是在内存中缓存组件（不让组件销毁），等到下次渲染的时候，还保持其中的所有状态，并触发activated钩子函数。缓存的额需要通常出现在页面切换时 全局缓存&nbsp;","text":"keep-alive：组件级缓存 两种模式：全局缓存/局部组件缓存 页面跳转到详情页面时，需要保持列表页的滚动条的深度，等返回的时候也然在这个位置。 使用方式：keep-alive是抽象组件（或称为功能型组件），实际不会被渲染在 DOM树中。它的作用是在内存中缓存组件（不让组件销毁），等到下次渲染的时候，还保持其中的所有状态，并触发activated钩子函数。缓存的额需要通常出现在页面切换时 全局缓存&nbsp; &lt;keep-alive&gt; &lt;router-view /&gt; &lt;/keep-alive&gt; 局部缓存：使用keep-alive组件的include/exclude属性。include属性表示要缓存的组件名（组件定义时的name属性） &lt;!--缓存想要缓存的页面，实现后退不刷新--&gt; &lt;!--加上v-if的判断，可以自定义想要缓存的组件，自定义在router里面--&gt; &lt;keep-alive&gt; &lt;router-view v-if=\"$route.meta.keepAlive\"&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;router-view v-if=\"!$route.meta.keepAlive\"&gt;&lt;/router-view&gt; 在router文件加上meta判断 export default new Router({ { // home会被缓存 path:\"/home\", component:home, meta:{keepAlive: true} }, { // home不会被缓存 path:\"/home\", component:home, meta:{keepAlive: false} } }) 注：如果想要看有没有缓存成功，可以再各个组件的created钩子里面打印输出标志，缓存成功就是首次进入页面，created会请求数据，后面就不会再次请求而是直接调用缓存的 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与面试题","slug":"算法与面试题","permalink":"http://kisskisso.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://kisskisso.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"watch用箭头函数会出现什么情况？","slug":"watch用箭头函数会出现什么情况？","date":"2020-05-15T04:15:16.000Z","updated":"2021-01-26T09:46:36.000Z","comments":true,"path":"2020/05/15/watch用箭头函数会出现什么情况？/","link":"","permalink":"http://kisskisso.com/2020/05/15/watch%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%EF%BC%9F/","excerpt":"","text":"this是undefined，typeError错误。Cannot read property ‘xxx’ of undefined document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与面试题","slug":"算法与面试题","permalink":"http://kisskisso.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://kisskisso.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"箭头函数和普通函数的区别","slug":"箭头函数和普通函数的区别","date":"2020-05-15T02:26:47.000Z","updated":"2021-01-26T10:07:34.000Z","comments":true,"path":"2020/05/15/箭头函数和普通函数的区别/","link":"","permalink":"http://kisskisso.com/2020/05/15/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"1.箭头函数没有this对象，因此不可以用构造函数，不能用call(), apply(), bin()这些方法去改变this指向","text":"1.箭头函数没有this对象，因此不可以用构造函数，不能用call(), apply(), bin()这些方法去改变this指向 2.不绑定arguments对象，不过可以使用rest参数来解决 3.不能使用new操作符，会报错 4.没有prototype属性（原型） 5.不能作用生成器 总结： 箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或 new.target。这些函数表达式最适合用于非方法函数(non-method functions)，并且它们不能用作构造函数。 扩展： 箭头函数的 IIEF: (() =&gt; { console.log('1'); })(); 上面的是可以，但是下面的写法就会报错 (() =&gt; { console.log('1'); }()); 原因： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与面试题","slug":"算法与面试题","permalink":"http://kisskisso.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://kisskisso.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"vuex常用的属性","slug":"vuex常用的属性","date":"2020-05-15T01:50:13.000Z","updated":"2021-01-26T09:42:32.000Z","comments":true,"path":"2020/05/15/vuex常用的属性/","link":"","permalink":"http://kisskisso.com/2020/05/15/vuex%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7/","excerpt":"","text":"state geters muations acions modules 全局基本数据 计算属性 提交更改数据的方法，同步 提交更改数据的方法，可以异步 分割成模块 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与面试题","slug":"算法与面试题","permalink":"http://kisskisso.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://kisskisso.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"mv命令","slug":"mv命令","date":"2020-05-15T01:21:18.000Z","updated":"2021-01-26T09:25:08.000Z","comments":true,"path":"2020/05/15/mv命令/","link":"","permalink":"http://kisskisso.com/2020/05/15/mv%E5%91%BD%E4%BB%A4/","excerpt":"Linux mv命令用来为文件或目录改名 或这文件或目录移动到其它位置 mv 源文件名 目标文件名 表示将源文件名改为目标文件名 命令格式： 命令格式 结果 mv 文件名 文件名 将源文件名改为目标文件名 mv 文件名 目录名 将文件移动到目标目录 mv 目录名 目录名 目标目录已存在，将源目录移动到目标目录；目标目录不存在则改名 mv 目录名 文件名 出错 参数：","text":"Linux mv命令用来为文件或目录改名 或这文件或目录移动到其它位置 mv 源文件名 目标文件名 表示将源文件名改为目标文件名 命令格式： 命令格式 结果 mv 文件名 文件名 将源文件名改为目标文件名 mv 文件名 目录名 将文件移动到目标目录 mv 目录名 目录名 目标目录已存在，将源目录移动到目标目录；目标目录不存在则改名 mv 目录名 文件名 出错 参数： -i 若存在同名文件，则向用户询问是否覆盖 -f 覆盖已有文件时，不进行任何提示 -b 当文件存在时，覆盖前为其创建一个备份 -u 当源文件比目标文件新，或者目标文件不存在时，才执行移动此操作 -t 复制多个文件或文件夹 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"语言与Linux","slug":"语言与Linux","permalink":"http://kisskisso.com/categories/%E8%AF%AD%E8%A8%80%E4%B8%8ELinux/"}],"tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"http://kisskisso.com/tags/Linux%E5%91%BD%E4%BB%A4/"}]},{"title":"Vue的两种路由模式","slug":"Vue的两种路由模式","date":"2020-05-15T00:52:10.000Z","updated":"2021-01-26T09:43:40.000Z","comments":true,"path":"2020/05/15/Vue的两种路由模式/","link":"","permalink":"http://kisskisso.com/2020/05/15/Vue%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F/","excerpt":"在vue-router路由对象中，有两种模式：hash和history，默认的是hash模式 扩展: hash路由:监听路由的变化：onhashchange事件，只有#后的地址发生变化，可以在window对象上监听： window.onhashchange = function(event) { let hash = loaction.hash } history路由:模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。","text":"在vue-router路由对象中，有两种模式：hash和history，默认的是hash模式 扩展: hash路由:监听路由的变化：onhashchange事件，只有#后的地址发生变化，可以在window对象上监听： window.onhashchange = function(event) { let hash = loaction.hash } history路由:模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。 const router = new VueRouter({ mode: 'history', routes: [...] }) 注：使用history需要后台配置支持，因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问网页就会返回 404。 只需在服务器增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与面试题","slug":"算法与面试题","permalink":"http://kisskisso.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://kisskisso.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"Vue全家桶","slug":"Vue全家桶","date":"2020-05-14T22:57:25.000Z","updated":"2021-01-26T09:44:04.000Z","comments":true,"path":"2020/05/15/Vue全家桶/","link":"","permalink":"http://kisskisso.com/2020/05/15/Vue%E5%85%A8%E5%AE%B6%E6%A1%B6/","excerpt":"","text":"Vue vue-router vue-cli Vuex-resource document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与面试题","slug":"算法与面试题","permalink":"http://kisskisso.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://kisskisso.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"路由的动态获取","slug":"路由的动态获取","date":"2020-05-14T14:13:31.000Z","updated":"2021-01-26T10:14:34.000Z","comments":true,"path":"2020/05/14/路由的动态获取/","link":"","permalink":"http://kisskisso.com/2020/05/14/%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96/","excerpt":"","text":"第一种利用$route.query属性获取连接上的参数，url参数使用？形式 第二种利用$route.params获取参数，url形式是/参数形式 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与面试题","slug":"算法与面试题","permalink":"http://kisskisso.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://kisskisso.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"jquery和react区别","slug":"jquery和react区别","date":"2020-05-14T05:14:12.000Z","updated":"2021-01-26T09:09:14.000Z","comments":true,"path":"2020/05/14/jquery和react区别/","link":"","permalink":"http://kisskisso.com/2020/05/14/jquery%E5%92%8Creact%E5%8C%BA%E5%88%AB/","excerpt":"","text":"React是UI库而JQuery则是工具库，然后就是对Dom操作的不同，Reactjs提供了一整套的vistualDom（虚拟Dom）所有的操作都在这个虚拟的额Dom上而非 真实的Dom，React默认这个真实Dom是不会被改变，而改变的只有虚拟的Dom，然后通过这个虚拟的Dom来对真实的Dom进行渲染。JQuery则是操作真实的Dom，处理事件方式就是用选择器筛选出需要改变的Dom元素，或者监听Dom，最后改变真实的Dom来达到预期的结构 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与面试题","slug":"算法与面试题","permalink":"http://kisskisso.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://kisskisso.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"2.x与3.x脚手架的区别","slug":"2-0与3-0脚手架的区别","date":"2020-05-14T03:17:56.000Z","updated":"2021-01-27T08:40:42.000Z","comments":true,"path":"2020/05/14/2-0与3-0脚手架的区别/","link":"","permalink":"http://kisskisso.com/2020/05/14/2-0%E4%B8%8E3-0%E8%84%9A%E6%89%8B%E6%9E%B6%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"3.x启动npm run serve 2.x启动npm run dev document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与面试题","slug":"算法与面试题","permalink":"http://kisskisso.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[]},{"title":"项目脚手架的创建与运行","slug":"项目脚手架的创建与运行","date":"2020-05-14T00:24:56.000Z","updated":"2021-01-26T10:35:14.000Z","comments":true,"path":"2020/05/14/项目脚手架的创建与运行/","link":"","permalink":"http://kisskisso.com/2020/05/14/%E9%A1%B9%E7%9B%AE%E8%84%9A%E6%89%8B%E6%9E%B6%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/","excerpt":"","text":"下载： npm install -g @vue/cli # OR yarn global add @vue/cli 然后用vue –version检查版本是否正确 创建项目：vue create XXX 注： 根据需要选择 运行项目：npm run serve document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与面试题","slug":"算法与面试题","permalink":"http://kisskisso.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://kisskisso.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"Vue双向数据绑定的原理","slug":"Vue双向数据绑定的原理","date":"2020-05-13T01:06:24.000Z","updated":"2021-01-26T09:44:50.000Z","comments":true,"path":"2020/05/13/Vue双向数据绑定的原理/","link":"","permalink":"http://kisskisso.com/2020/05/13/Vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86/","excerpt":"vue的双向数据绑定：是通过数据劫持 结合 发布订阅模式的方式实现。数据和视图同步，数据发生变化，视图也跟着变化，数据也随之发生改变。 简单来说就是通过Object对象的defineProperty属性，重写data的set和get函数来实现的 核心就是Object.defineProperty()方法 扩展：Object.defineProperty()方法 Object.defineProperty(obj，prop，descriptor)参数：obj（定义属性对象）prop（定义或修改的属性）descriptor（具体的改变方法）","text":"vue的双向数据绑定：是通过数据劫持 结合 发布订阅模式的方式实现。数据和视图同步，数据发生变化，视图也跟着变化，数据也随之发生改变。 简单来说就是通过Object对象的defineProperty属性，重写data的set和get函数来实现的 核心就是Object.defineProperty()方法 扩展：Object.defineProperty()方法 Object.defineProperty(obj，prop，descriptor)参数：obj（定义属性对象）prop（定义或修改的属性）descriptor（具体的改变方法） 用这个方法定义一个值，当调用时使用它里面的get方法，当给属性赋值时，又用到set方法 var obj = {}; Object.defineProperty(obj, 'hello',{ get: function () { console.log('调用了get方法') }, set: function (newVal) { console.log('调用了set方法，方法的值为' + newVal) } })； obj.hello; obj.hello = 'hi'; JS双向数据绑定通过添加事件监听keyup来触发set方法，而set在修改访问器属性的同时，在修改了dom样式，改变了span标签的文本 &lt;script&gt; var obj = []; // 定义一个空对象 var k = 'once'; // 赋予初始值 Object.defineProperty(obj, 'k', { get: function () { return k; }, set: function (newK) { k = newK; // 定义k等于修改后的内容 // 让文本框的内容等于k document.getElementById('a').value = k // 让span的内容等于k document.getElementById('b').innerHTML = k } }); document.addEventListener('keyup', function (e) { //当在文本框输入内容时让对象里你定义的val等于文本框的值 obj.k = e.target.value; }) &lt;/script&gt; vue的双向数据绑定：就是普通单向绑定和事件组合来完成的 &lt;div id=\"vm\"&gt; &lt;p&gt;邮箱&lt;input v-model=\"email\"&gt;&lt;/p&gt; &lt;span&gt;{{email}}&lt;/span&gt; &lt;p&gt;名字&lt;input v-model=\"name\"&gt;&lt;/p&gt; &lt;span&gt;{{name}}&lt;/span&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el: '#vm', data: { email: '', name: '' } }); &lt;/script&gt; 理解： ①将vue中的data中的内容绑定到输入文本框和文本节点中 ②文本框的内容改变时，vue实例中的data也同时发生改变 ③当data中的内容发生改变时，输入框及文本节点的内容也发生变化 注：如果使用appendCid方法将原dom树中的节点添加到DocumenntFragment中时，会删除原来的节点 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与面试题","slug":"算法与面试题","permalink":"http://kisskisso.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://kisskisso.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"导航守卫的理解","slug":"导航守卫的理解","date":"2020-05-12T08:41:51.000Z","updated":"2021-01-26T09:55:58.000Z","comments":true,"path":"2020/05/12/导航守卫的理解/","link":"","permalink":"http://kisskisso.com/2020/05/12/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"导航守卫主要用来通过跳转或取消的方式守卫导航。 ​ 简单来说就是路由跳转过程中的一些钩子函数 扩展： 钩子函数执行顺序： 全局前置守卫：beforeEach——&gt;路由beforeEnter守卫——&gt;组件路由守卫beforeRouteEnter（this并不指向该组件实例）——&gt;全局解析守卫：beforeResolve——&gt;全局后置守卫：afterEach——&gt;组件生命周期：beforeCreate——&gt;组件生命周期created——&gt;组件生命周期beforeMount——&gt;组件声明周期mounted——&gt;组件路由守卫beforeRouteEnter的next回调 导航守卫分为： 全局、单个路由独享、组件内三种。","text":"导航守卫主要用来通过跳转或取消的方式守卫导航。 ​ 简单来说就是路由跳转过程中的一些钩子函数 扩展： 钩子函数执行顺序： 全局前置守卫：beforeEach——&gt;路由beforeEnter守卫——&gt;组件路由守卫beforeRouteEnter（this并不指向该组件实例）——&gt;全局解析守卫：beforeResolve——&gt;全局后置守卫：afterEach——&gt;组件生命周期：beforeCreate——&gt;组件生命周期created——&gt;组件生命周期beforeMount——&gt;组件声明周期mounted——&gt;组件路由守卫beforeRouteEnter的next回调 导航守卫分为： 全局、单个路由独享、组件内三种。 全局：指路由实例上直接操作的钩子函数，所有路由配置的组件都会触发，大白话就是触发路由就会触发这些钩子函数。 beforeEach、beforeResolve（2.5+）、afterEach const router = new VueRouter({ router.beforeEach((to, from, next) =&gt; { .... }) }) [beforeEach] :在路由跳转前触发，参数包括to，from，next作用：用于登录验证，路由没跳转前告知 [beforeResolve]（2.5+） :以上类似，官方文档：区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。 [afterEach]:在路由跳转后触发，参数to ，from 发生在beforeEach和beforeResolve之后，beforeRouteEnter之前 路由独享:指单个路由配置的时候设置钩子函数 const router = new VueRouter({ roues: [ { path: '', component: , beforeEnter: (to, from ,next) =&gt; { .... } } ] }) [beforeEnter] ：和…Each相同，都设置在…Each之后执行参数to,from,next 组件内：指在组件内执行钩子函数，类似组件的生命周期，相当于为路由组件添加生命周期钩子函数 beforeRouteEnter、beforeRouteUpdate（2.2+）、beforeRouteLeave export default { name: '', data () { return { .... } }, beforeRouteEnter (to, from, next) { // 在渲染组件的对用路由被confirm前调用 // 不能用this！！不能用this！！不能用this！！ // this并不指向该组件实例 }， beforeRouteUpdate (to, from, next) { // 当前路由改变，组件被复用时调用 // 可以访问组件实例！！this！！ }， beforeRouteLeave （to, from, next）{ // 导航离开组件的对应路由时调用 // 可以访问组件实例 ！！this！！ } } [beforeRouteEnter] :路由之前调用，参数to，from，next 在全局守卫beforeEach和独享守卫beforeEnter之后，全局beforeResolve和全局afterEach之前调用。在beforeCreate生命周期前触发。 注：该守卫访问不到组件实例，this为undefined ★★★可以通过传一个回调给next来访问组件实例，在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数，可以在这个守卫中请求服务端获取数据，当成功获取并能进入路由时，调用next并在回调中通果vm访问组件实例进行赋值等操作需注意的是next中函数的调用在mounted之后：主要是为了确保能对组件实例的完整访问 beforeRouteEnter （to, from, next）{ next (vm =&gt; { // 通过vm访问组件实例 }) } [beforeRouteUpdate] (2.2+) :路由改变时，且组件被复用时调用（this可以！！！）参数：to，from， next ★★什么时候路由改变？ &amp;&amp; 什么时候组件被复用？ 1.带有动态参数的路径 2.路由query变更时，该守卫会被调用 ★★★补充：query和params的用法区别 query: this.$router.push({ path: '', query: { type: , typeDesc: } }) 【query用path引入，params要用name引入。接收参数类似：this.$route.query.name和 this.$route.params.name query在浏览器地址中显示参数params则不显示 【注：query刷新不会丢失query里面的数据。params刷新会丢失params里面的数据】看需求使用 ​ 如：刷新获取不同的值用params，反之就用query】 params: this.$router.push({ name: '', params: { type: , typeDesc: } }) [beforeRouteLeave] :导航组件离开组件的对应路由时调用（this可以！！！） 参数：to, from, next 回调参数:【重点★★★★】 to: 目标路由对象 from：离开的路由对象 next：下一个钩子 值得注意的是但凡涉及到next参数的钩子，需调用next（）才能继续执行下一个钩子，否则路由跳转会停止。还有就是如果要中断当前的导航要调用next(false)【用于登录验证不通过处理】，URL的改变（手动或浏览器回退按钮）会让URL地址重置到from路由对应的地址。当然next也可以如以下方法使用：next(‘/‘)或next({path:’/‘}):跳转到一个不同的地址。白话就是当前导航被中断，则执行一个新的导航。参数router.push一致 beforeRouteEnter钩子中的next（（vm）=&gt; {}）内接受的回调函数参数为当前组件的实例vm，在生命周期mounted之后调用。最后执行的钩子函数 next(error)：（v2.4.0+）如果传入next的参数是一个Error实例，则导航会被终止该错误会被传递给router.onError注册过得回调 被调用的错误如以下情形： 错误在一个路由守卫函数中被同步抛出； 错误在一个路由守卫函数中通过调用 next(err) 的方式异步捕获并处理； 渲染一个路由的过程中，需要尝试解析一个异步组件时发生错误。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与面试题","slug":"算法与面试题","permalink":"http://kisskisso.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://kisskisso.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"clear命令","slug":"clear命令","date":"2020-05-12T08:29:02.000Z","updated":"2021-01-26T08:50:18.000Z","comments":true,"path":"2020/05/12/clear命令/","link":"","permalink":"http://kisskisso.com/2020/05/12/clear%E5%91%BD%E4%BB%A4/","excerpt":"","text":"clear ：清空终端 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"语言与Linux","slug":"语言与Linux","permalink":"http://kisskisso.com/categories/%E8%AF%AD%E8%A8%80%E4%B8%8ELinux/"}],"tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"http://kisskisso.com/tags/Linux%E5%91%BD%E4%BB%A4/"}]},{"title":"如何安装Cmder","slug":"如何安装Cmder","date":"2020-05-12T07:15:48.000Z","updated":"2021-01-26T10:21:44.000Z","comments":true,"path":"2020/05/12/如何安装Cmder/","link":"","permalink":"http://kisskisso.com/2020/05/12/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85Cmder/","excerpt":"替换win10自带的cmd和power shell，两项方案： ​ 方案一：Windows terminal 在微软商场下载Windows terminal不过只能win10下载而且版本号要升级到1903版本以上 方案二：Cmder ​ 在官网下载Cmder,不要下载Mini（不支持Git）下载Download Full ​ ①安装：把下载的压缩包解压到C:\\Users\\XXX进入文件夹（免安装直接运行但是需要配置） ​ ②需要把这个地址（解压的地址）加到系统的path环境中 (Cmder的c要大写！！！Cmder的c要大写！！！Cmder的c要大写！！！)","text":"替换win10自带的cmd和power shell，两项方案： ​ 方案一：Windows terminal 在微软商场下载Windows terminal不过只能win10下载而且版本号要升级到1903版本以上 方案二：Cmder ​ 在官网下载Cmder,不要下载Mini（不支持Git）下载Download Full ​ ①安装：把下载的压缩包解压到C:\\Users\\XXX进入文件夹（免安装直接运行但是需要配置） ​ ②需要把这个地址（解压的地址）加到系统的path环境中 (Cmder的c要大写！！！Cmder的c要大写！！！Cmder的c要大写！！！) win--&gt;搜索编辑系统环境变量--&gt;环境变量--&gt;用户变量/系统变量--&gt;新建--&gt;变量名CMDER_ROOT/值**(解压地址+Cmder.exe)** ③配置cmder到右键菜单：右键Cmder.exe属性-兼容性-以管理员身份运行此程序然后重新打开Cmder.exe输入Cmder.exe /REGISTER ALL 补充：Cmder.exe /REGISTER ALL开头一定大写，有可能会报错 也可以到github上参考官方设置 了解： Windows terminal是微软在2019年5月6日至5月8日的 Build 2019 大会上展示了 Windows Terminal且开源 Cmder是一个增强型命令行工具，不仅可以使用windows下的所有命令，也可以使用linux的命令,shell命令。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"应用与插件","slug":"应用与插件","permalink":"http://kisskisso.com/categories/%E5%BA%94%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"cmder","slug":"cmder","permalink":"http://kisskisso.com/tags/cmder/"}]},{"title":"编译的三个步骤（了解）","slug":"编译的三个步骤","date":"2020-05-10T08:06:07.000Z","updated":"2021-01-26T09:48:28.000Z","comments":true,"path":"2020/05/10/编译的三个步骤/","link":"","permalink":"http://kisskisso.com/2020/05/10/%E7%BC%96%E8%AF%91%E7%9A%84%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4/","excerpt":"","text":"分词/词法分析（Tokenizing/Lexing） 将由字符组成的字符串分解成有意义的代码块，被称为词法单元 他们俩的主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的 解析/语法分析（Parsing） 将词法单元流（数组）转换成一个有元素逐级嵌套所1组成的代表了程序语法结构的书，被称为抽象语法树也就是常说的AST，全名为Abstract Syntax Tree 代码生成 将AST转化为可执行代码的过程称为代码生成 注：这里说的是传统编译器 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS进阶","slug":"JS进阶","permalink":"http://kisskisso.com/tags/JS%E8%BF%9B%E9%98%B6/"}]},{"title":"话六","slug":"话六","date":"2020-05-08T11:19:50.000Z","updated":"2021-01-26T10:03:26.000Z","comments":true,"path":"2020/05/08/话六/","link":"","permalink":"http://kisskisso.com/2020/05/08/%E8%AF%9D%E5%85%AD/","excerpt":"","text":"生命中总有不期而遇的惊喜和生生不息的希望。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活与话","slug":"生活与话","permalink":"http://kisskisso.com/categories/%E7%94%9F%E6%B4%BB%E4%B8%8E%E8%AF%9D/"}],"tags":[{"name":"话","slug":"话","permalink":"http://kisskisso.com/tags/%E8%AF%9D/"}]},{"title":"话五","slug":"话五","date":"2020-04-27T13:07:20.000Z","updated":"2021-01-26T10:05:42.000Z","comments":true,"path":"2020/04/27/话五/","link":"","permalink":"http://kisskisso.com/2020/04/27/%E8%AF%9D%E4%BA%94/","excerpt":"","text":"记忆是一种相聚的方式，放下是一种自由的形式。不必悲伤，不必忧愁，邂逅的回忆都是美好的故事。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活与话","slug":"生活与话","permalink":"http://kisskisso.com/categories/%E7%94%9F%E6%B4%BB%E4%B8%8E%E8%AF%9D/"}],"tags":[{"name":"话","slug":"话","permalink":"http://kisskisso.com/tags/%E8%AF%9D/"}]},{"title":"话四","slug":"话四","date":"2020-04-26T12:08:11.000Z","updated":"2021-01-26T10:05:32.000Z","comments":true,"path":"2020/04/26/话四/","link":"","permalink":"http://kisskisso.com/2020/04/26/%E8%AF%9D%E5%9B%9B/","excerpt":"","text":"如果结果不如你所愿 就在尘埃落定的那一刻，奋力一搏！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活与话","slug":"生活与话","permalink":"http://kisskisso.com/categories/%E7%94%9F%E6%B4%BB%E4%B8%8E%E8%AF%9D/"}],"tags":[{"name":"话","slug":"话","permalink":"http://kisskisso.com/tags/%E8%AF%9D/"}]},{"title":"冒泡排序","slug":"冒泡排序","date":"2020-04-25T12:01:11.000Z","updated":"2021-01-26T10:15:28.000Z","comments":true,"path":"2020/04/25/冒泡排序/","link":"","permalink":"http://kisskisso.com/2020/04/25/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","excerpt":"冒泡排序:的实现思路是比较任何两个相邻的项, 如果前者比后者大, 则将它们互换位置. ​ 生成指定个数的随机数组 const generateArr = (num = 10) =&gt; { let arr = [] for(let i = 0; i&lt; num; i++) { let item = Math.floor(Math.random() * (num + 1)) arr.push(item) } return arr } ​ 冒泡排序:","text":"冒泡排序:的实现思路是比较任何两个相邻的项, 如果前者比后者大, 则将它们互换位置. ​ 生成指定个数的随机数组 const generateArr = (num = 10) =&gt; { let arr = [] for(let i = 0; i&lt; num; i++) { let item = Math.floor(Math.random() * (num + 1)) arr.push(item) } return arr } ​ 冒泡排序: bubbleSort(arr = []) { let lkz = arr.length for(let i = 0; i&lt; lkz; i++) { for(let j = 0; j &lt; lkz - 1; j++) { if(arr[j] &gt; arr[j+1]) { [arr[j], arr[j+1]] = [arr[j+1], arr[j]] } } } return arr } const arr = generateArr(60) 冒泡排序优化: bubbleSort(arr = []) { let lkz = arr.length // 优化 for(let i = 0; i&lt; lkz; i++) { for(let j = 0; j &lt; lkz - 1 - i; j++) { if(arr[j] &gt; arr[j+1]) { // 置换 [arr[j], arr[j+1]] = [arr[j+1], arr[j]] } } } return arr } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与面试题","slug":"算法与面试题","permalink":"http://kisskisso.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://kisskisso.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"线性思维","slug":"线性思维","date":"2020-04-21T15:22:32.000Z","updated":"2021-01-26T10:33:50.000Z","comments":true,"path":"2020/04/21/线性思维/","link":"","permalink":"http://kisskisso.com/2020/04/21/%E7%BA%BF%E6%80%A7%E6%80%9D%E7%BB%B4/","excerpt":"","text":"引：通常夸大生活事件所带来的消极影响的倾向称之为“恐怖化” 而线性思维所带来最大的负面影响，就是让人容易产生恐怖化的情绪 一但有什么事情没有按照既定的线性往上发展的时候，我们就会给自己给自己制造障碍，自己给自己加戏，对，你没听错是加戏。但实际上，让我们焦头烂额的事情其实是受制于这样的线性思维，往往会刻意夸大现在的痛苦…. 1.用追求卓越来替代追求优秀 2.紧盯别人的成功，不如记录自己的想法 3.再多思考一层 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"爱好心理学","slug":"爱好心理学","permalink":"http://kisskisso.com/categories/%E7%88%B1%E5%A5%BD%E5%BF%83%E7%90%86%E5%AD%A6/"}],"tags":[{"name":"思维","slug":"思维","permalink":"http://kisskisso.com/tags/%E6%80%9D%E7%BB%B4/"}]},{"title":"token","slug":"token","date":"2020-04-18T07:41:13.000Z","updated":"2021-01-26T09:39:00.000Z","comments":true,"path":"2020/04/18/token/","link":"","permalink":"http://kisskisso.com/2020/04/18/token/","excerpt":"响应拦截器： 处理token过期问题 &nbsp;替换token","text":"响应拦截器： 处理token过期问题 &nbsp;替换token // Add a 响应拦截器 interceptor request.interceptors.response.use(function (response) { // Any status code that lie within the range of 2xx cause this function to trigger // Do something with response data return response }, async function (error) { // 有错误到这里来,只处理401错误(是由token过期，错误导致)。 if (error.response.status === 401) { if (store.state.user &amp;&amp; store.state.user.refresh_token) { try { // 用refresh_token去求一个特殊的接口以获取新的token const result = await axios({ url: 'http://ttapi.research.itcast.cn/app/v1_0/authorizations', method: 'PUT', headers: { Authorization: `Bearer ${store.state.user.refresh_token}` } }) // 从接口返加值中去取出新token，更新到当前的vuex中 // mutations去改token store.commit('updateToken', result.data.data.token) console.log('更新token ok') // console.log(result) // error.config 就是当前错误发生时，axios中的配置 // 更新了token请求重发一次 return request(error.config) // store.state.user.token = result.data.data.token } catch (e) { console.log('更新token，refresh_token 失败') // 消除vuex的token store.commit('setUser', null) // 必须要重新登陆 router.push({ path: '/login', query: { // router中有一个属性currentRoute from: router.currentRoute.fullPath } }) } } else { console.log('没有refresh token,准备去重新登陆吧') router.push({ path: '/login', query: { // router中有一个属性currentRoute from: router.currentRoute.fullPath } }) } console.log('响应拦截器') console.dir(error) } else { return Promise.reject(error) } }) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"token","slug":"token","permalink":"http://kisskisso.com/tags/token/"}]},{"title":"节流与防抖","slug":"节流与防抖","date":"2020-04-17T02:58:57.000Z","updated":"2021-01-26T10:08:56.000Z","comments":true,"path":"2020/04/17/节流与防抖/","link":"","permalink":"http://kisskisso.com/2020/04/17/%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/","excerpt":"防抖:抖：高频率的发送请求 思路：当函数被调用时，不立即执行，而是延迟10秒执行。 如果在这10秒内再次调用了这个函数，则从当前被调用的时间开始计算","text":"防抖:抖：高频率的发送请求 思路：当函数被调用时，不立即执行，而是延迟10秒执行。 如果在这10秒内再次调用了这个函数，则从当前被调用的时间开始计算 hSearch () { if (this.timer) { cleraTimeout(this.timer) } this.timer = setTimeout(async () =&gt; { if (!this.keyword) { return } const result = await getSearchSuggestions(this.keyword) this.searchSuggestions = result.data.data.options }, 0.3 * 1000) } 节流：低频率发送请求 思路：如果这个函数距离上一次被调用的时间之间相隔不到10秒，则本次调用，不执行代码 两次有效调用时间，并且至少相隔10秒 hSearch () { // 只有this.timer是null，才会开启下一个定时器 if (!this.timer) { // 只要setTimeout一执行，this.timer就有值了 this.timer = setTimeout(async () =&gt; { this.timer = null if (!this.keyword) { return } const result = await getSearchSuggestions(this.word) }, 0.3 * 1000) } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"节流与防抖","slug":"节流与防抖","permalink":"http://kisskisso.com/tags/%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/"}]},{"title":"话三","slug":"话三","date":"2020-04-16T10:51:45.000Z","updated":"2021-01-26T10:03:52.000Z","comments":true,"path":"2020/04/16/话三/","link":"","permalink":"http://kisskisso.com/2020/04/16/%E8%AF%9D%E4%B8%89/","excerpt":"","text":"正义从来不是道德的标杆，而是立场的选择 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活与话","slug":"生活与话","permalink":"http://kisskisso.com/categories/%E7%94%9F%E6%B4%BB%E4%B8%8E%E8%AF%9D/"}],"tags":[{"name":"话","slug":"话","permalink":"http://kisskisso.com/tags/%E8%AF%9D/"}]},{"title":"话二","slug":"话二","date":"2020-04-14T09:53:45.000Z","updated":"2021-01-26T10:03:02.000Z","comments":true,"path":"2020/04/14/话二/","link":"","permalink":"http://kisskisso.com/2020/04/14/%E8%AF%9D%E4%BA%8C/","excerpt":"","text":"人会有前 后的观念，只不过因为视野太小， 所谓的前进 也就只是向着狭小视野的方向移动罢了 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活与话","slug":"生活与话","permalink":"http://kisskisso.com/categories/%E7%94%9F%E6%B4%BB%E4%B8%8E%E8%AF%9D/"}],"tags":[{"name":"话","slug":"话","permalink":"http://kisskisso.com/tags/%E8%AF%9D/"}]},{"title":"关于如何使用跨组件","slug":"关于如何使用跨组件","date":"2020-04-14T01:48:02.000Z","updated":"2021-01-26T10:01:44.000Z","comments":true,"path":"2020/04/14/关于如何使用跨组件/","link":"","permalink":"http://kisskisso.com/2020/04/14/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%B7%A8%E7%BB%84%E4%BB%B6/","excerpt":"","text":"事件总线三种方法： $on,$emit,$off 画图： 1.index.vue. 2.articleList.vue 3.moreAction.vue 4.channelEdit.vue eventBus document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"组件","slug":"组件","permalink":"http://kisskisso.com/tags/%E7%BB%84%E4%BB%B6/"}]},{"title":"Electron安装问题","slug":"Electron安装问题","date":"2020-04-13T06:25:55.000Z","updated":"2021-01-26T08:55:46.000Z","comments":true,"path":"2020/04/13/Electron安装问题/","link":"","permalink":"http://kisskisso.com/2020/04/13/Electron%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/","excerpt":"","text":"关于如何安装eletron卡在node install.js的解决方法 ①在.npmrc里写入以下数据：在C:\\Users\\***下 electron_mirror=\"https://npm.taobao.org/mirrors/electron/\" ②npm安装node-sass 网速慢可以切换淘宝的镜像源或npm i nrm工具 在.npmrc里写入以下数据： registry=https://registry.npm.taobao.org sass_binary_site=https://npm.taobao.org/mirrors/node-sass/ phantomjs_cdnurl=http://npm.taobao.org/mirrors/phantomjs ELECTRON_MIRROR=http://npm.taobao.org/mirrors/electron/ 注：需要删除已安装的node_modules然后重新安装electron，如果有其它的包则需要重新npm install下。应该都有初始化吧npm init ​ Eg:npm install --save-dev electron document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"应用与插件","slug":"应用与插件","permalink":"http://kisskisso.com/categories/%E5%BA%94%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6/"}],"tags":[]},{"title":"话一","slug":"话一","date":"2020-04-09T12:43:02.000Z","updated":"2021-01-26T10:05:56.000Z","comments":true,"path":"2020/04/09/话一/","link":"","permalink":"http://kisskisso.com/2020/04/09/%E8%AF%9D%E4%B8%80/","excerpt":"","text":"要别人肯定你的同时，首先自己要先肯定自己，自己若不能肯定自己，那你最大的敌人永远也是你自己，这个观念讲起来很简单，但你有认真想过吗？自己是如何输给自己，又是如何赢了自己，又要如何才能超越自己。有些事没必要想的太复杂。犹豫不决，所换到的结果就是浪费时间，时间不是你想掌握就会停止的东西..所以珍惜现在吧 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活与话","slug":"生活与话","permalink":"http://kisskisso.com/categories/%E7%94%9F%E6%B4%BB%E4%B8%8E%E8%AF%9D/"}],"tags":[{"name":"话","slug":"话","permalink":"http://kisskisso.com/tags/%E8%AF%9D/"}]},{"title":"vuex的核心","slug":"vuex的核心","date":"2020-04-08T05:33:08.000Z","updated":"2021-01-26T09:43:02.000Z","comments":true,"path":"2020/04/08/vuex的核心/","link":"","permalink":"http://kisskisso.com/2020/04/08/vuex%E7%9A%84%E6%A0%B8%E5%BF%83/","excerpt":"state：作用：定义全局数据(保存所以公共数据)。类似data export default new Vue.store({ state:{ } }) export default store 获取数据：state 直接使用：1.this.$store.state.自定义 映射的方式：2.computed:{...mapState([''])}","text":"state：作用：定义全局数据(保存所以公共数据)。类似data export default new Vue.store({ state:{ } }) export default store 获取数据：state 直接使用：1.this.$store.state.自定义 映射的方式：2.computed:{...mapState([''])} 注：在Vue中不推荐直接在组件内部通过this.$store.state.全局数据名称=新值来修改Vue mutation作用：修改公共数据 const store = new Vuex.Store({ state: { }, mutations: { } }) 修改：mutations 直接使用：this.$store.commit('','')不推荐 map映射的方式：{ methods:{ // 相当于是在当前组件内部的methods加了对应的方法 ...mapMutations(['mutation名'，'mutation名']) } } ※action作用：可以执行异步代码；可以同时调用多个mutation new Vuex.store ({ state: {}, actions: { 函数名 :function（参数1，参数2）{ } } }) 使用：actions 直接使用：this.$store.dispatch map映射的方式：methods:{...mapActions ([''])} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vuex","slug":"vuex","permalink":"http://kisskisso.com/tags/vuex/"}]},{"title":"组建之间共享方式","slug":"组建之间共享方式","date":"2020-04-06T02:14:06.000Z","updated":"2021-01-26T10:46:40.000Z","comments":true,"path":"2020/04/06/组建之间共享方式/","link":"","permalink":"http://kisskisso.com/2020/04/06/%E7%BB%84%E5%BB%BA%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F/","excerpt":"","text":"vuex独立于所有的组件 作用 对所以组件需要用到的公共数据,进行管理 是一种新的组建之间数据共享的方式 父子 eventBus Vuex payload mapMutations mapState actions 中 调用 ———————— 去修改数据？ mutation document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"vertical-align","slug":"vertical-align","date":"2020-03-24T12:14:15.000Z","updated":"2021-01-26T09:40:24.000Z","comments":true,"path":"2020/03/24/vertical-align/","link":"","permalink":"http://kisskisso.com/2020/03/24/vertical-align/","excerpt":"CSS 的属性 vertical-align 用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。 语法：vertical-align: ; 行内元素的值: ​ **相对父元素的值：**这些值使元素相对其父元素垂直对齐： baseline 使元素的基线与父元素的基线对齐。 sub 使元素的基线与父元素的下标基线对齐。","text":"CSS 的属性 vertical-align 用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。 语法：vertical-align: ; 行内元素的值: ​ **相对父元素的值：**这些值使元素相对其父元素垂直对齐： baseline 使元素的基线与父元素的基线对齐。 sub 使元素的基线与父元素的下标基线对齐。 super 使元素的基线与父元素的上标基线对齐。 text-top 使元素的顶部与父元素的字体顶部对齐。 text-bottom 使元素的底部与父元素的字体底部对齐。 middle 使元素的中部与父元素的基线加上父元素x-height（译注：x高度）的一半对齐。 &lt;length&gt; 使元素的基线对齐到父元素的基线之上的给定长度。可以是负数。 &lt;percentage&gt; 使元素的基线对齐到父元素的基线之上的给定百分比，该百分比是line-height属性的百分比。可以是负数。 **相对行的值：**使元素相对整行垂直对齐 top 使元素及其后代元素的顶部与整行的顶部对齐。 bottom 使元素及其后代元素的底部与整行的底部对齐。 没有基线的元素，使用外边距的下边缘替代。 表格单元格的值 baseline (以及 sub, super, text-top, text-bottom, &lt;length&gt;, &lt;percentage&gt;) 使单元格的基线，与该行中所有以基线对齐的其它单元格的基线对齐 top 使单元格内边距的上边缘与该行顶部对齐。 middle 使单元格内边距盒模型在该行内居中对齐。 bottom 使单元格内边距的下边缘与该行底部对齐。 可以是负数。 注： vertical-align 只对行内元素、表格单元格元素生效：不能用它垂直对齐块级元素。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"css属性","slug":"css属性","permalink":"http://kisskisso.com/tags/css%E5%B1%9E%E6%80%A7/"}]},{"title":"重定向与编程式导航与路由嵌套","slug":"重定向与编程式导航","date":"2020-03-20T23:27:11.000Z","updated":"2021-01-26T10:45:50.000Z","comments":true,"path":"2020/03/21/重定向与编程式导航/","link":"","permalink":"http://kisskisso.com/2020/03/21/%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA/","excerpt":"vue-router-重定向 指：访问某一个路由，自动跳转到另外一个路径 核心代码：{path:”/“,redirect:”/home} vue-touter-编程式导航 指：通过js的方式触发路由的跳转 核心代码：提供路由相关函数跳转方法this.$router.push() 注：route是获取路由相关信息路由传参 this.$route.params","text":"vue-router-重定向 指：访问某一个路由，自动跳转到另外一个路径 核心代码：{path:”/“,redirect:”/home} vue-touter-编程式导航 指：通过js的方式触发路由的跳转 核心代码：提供路由相关函数跳转方法this.$router.push() 注：route是获取路由相关信息路由传参 this.$route.params vue-router-路由嵌套 指：套娃 核心：children 引：要进行路由的嵌套，只需要在**一级路由规则**下，加上一个属性 children，即可定义二级路由规则。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue-router","slug":"vue-router","permalink":"http://kisskisso.com/tags/vue-router/"}]},{"title":"语法糖","slug":"语法糖","date":"2020-03-20T09:51:30.000Z","updated":"2021-01-26T10:40:20.000Z","comments":true,"path":"2020/03/20/语法糖/","link":"","permalink":"http://kisskisso.com/2020/03/20/%E8%AF%AD%E6%B3%95%E7%B3%96/","excerpt":"​ Vue指令 1.v-model 指令是一个语法糖（简写）就是简写了：:value 与 @input 两段代码 :value = 'msg' 与 @input = 'msg=$event.target.value' class: :class绑定类 style: 绑定行内样式","text":"​ Vue指令 1.v-model 指令是一个语法糖（简写）就是简写了：:value 与 @input 两段代码 :value = 'msg' 与 @input = 'msg=$event.target.value' class: :class绑定类 style: 绑定行内样式 v-mode: 1 v-cloak: [v-cloak]{display:none}; 浏览器解析插值表达式闪烁问题 v-once:指渲染一次，之后不受影响 没有值 自定义过滤器： 全局： api使用方法 Vue.filter(‘过滤器名称’,’ 处理函数’) Vue.filter('up',(value)=&gt;{}) 局部：vue实例管理的视图才可以使用 const vm = new Vue ({ filter:{ up(value){} } el:'' data:{ } }) 使用过滤器：进行格式转换，使用过滤器 &lt;div&gt; {{***|up}} 术语：管道符 &lt;/div&gt; Vue操作DOM:获取dom操作dom 1.Vue.filter('过滤器名称','处理函数') 固定 2.filter:{'过滤器名称':'处理函数'}固定 3.处理函数return使用固定 dom：给需要获取的表签加上ref属性 eg:&lt;div ref='myDom'&gt;&lt;/div&gt; 1.ref固定 2.this.$refs也是固定 3.myDom自定 Vue自定义指令 全局自定义指令：Vue.directive(‘指令的名称’,’指令的配置对象’) 基本语法 指令的名字在定义时候不需要加v-，在是用的时候才需要加v- 固定属性：inserted 在使用指令的元素渲染完毕后触发的函数 这个函数执行了，代表元素渲染完毕，才可以操作元素。 最后根据你指令的需求，实现业务逻辑。el 是使用指令的dom元素 Vue.directive('focus', { inserted (el) { el.focus() dom提供的api用了获取焦点 } }) 局部自定义指令： directives:{ key: value }基本语法 key是 指令的名称 要求：定义时候不需要加v-，在是用的时候才需要加v- value是 指令的配置对象 directives: { focus: { inserted (el) { el.focus() } } }, el: '#app' }) vue的计算属性： computed: { // reversedMessage () { // 反转逻辑，处理之后的结果，是一定要return出去 return this.message.split('').reverse().join('') } } }) 使用：直接使用 &lt;div id=\"app\"&gt; {{reversedMessage}} &lt;/div&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://kisskisso.com/tags/vue/"}]},{"title":"术语与指令","slug":"术语与指令","date":"2020-03-15T10:11:05.000Z","updated":"2021-01-26T10:29:08.000Z","comments":true,"path":"2020/03/15/术语与指令/","link":"","permalink":"http://kisskisso.com/2020/03/15/%E6%9C%AF%E8%AF%AD%E4%B8%8E%E6%8C%87%E4%BB%A4/","excerpt":"选项： el: 获取指定的容器（具体的标签）element的缩写注：不能指定html和body容器作为试图容器 data: 数据驱动视图 响应式数据必须是 显性的声明 响应式数据必须在data当中提前声明 methods: 声明函数 可以给vm使用也可以提供视图使用 不可使用箭头函数","text":"选项： el: 获取指定的容器（具体的标签）element的缩写注：不能指定html和body容器作为试图容器 data: 数据驱动视图 响应式数据必须是 显性的声明 响应式数据必须在data当中提前声明 methods: 声明函数 可以给vm使用也可以提供视图使用 不可使用箭头函数 指令： 标签的扩展功能属性 v-text ：相当于innerText v-html：相当于innerHTML v-show：样式隐藏display：none v-show使用场景：当元素要频繁的切换显示和隐藏 v-if使用常用场景：当渲染的时候，就需要判断是否显示，今后不需要频繁切换 true显示 false 隐藏 v-if：通过创建和移除元素隐藏 v-on：事件 简写方式：@click=处理函数 如果给绑定的函数传参需要带括号而且必须带$event &nbsp; 事件修饰符 v-for：遍历 in 或of都一样 v-bind： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://kisskisso.com/tags/vue/"}]},{"title":"前后端的身份验证（概念）","slug":"前后端的身份验证（概念）","date":"2020-03-12T14:22:58.000Z","updated":"2021-01-26T10:18:56.000Z","comments":true,"path":"2020/03/12/前后端的身份验证（概念）/","link":"","permalink":"http://kisskisso.com/2020/03/12/%E5%89%8D%E5%90%8E%E7%AB%AF%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%EF%BC%88%E6%A6%82%E5%BF%B5%EF%BC%89/","excerpt":"Web 开发模式： 1**.服务器端渲染的传统模式Web开发模式** 服务器通过字符串的拼接，动态生成的 优点： ① 前端耗时少。因为服务器端负责动态生成 HTML 内容，浏览器只需要直接渲染页面即可。尤其是移动端，更省电。 ② 有利于SEO。因为服务器端响应的是完整的 HTML 页面内容，所以爬虫更容易爬取获得信息，更有利于 SEO。 缺点：","text":"Web 开发模式： 1**.服务器端渲染的传统模式Web开发模式** 服务器通过字符串的拼接，动态生成的 优点： ① 前端耗时少。因为服务器端负责动态生成 HTML 内容，浏览器只需要直接渲染页面即可。尤其是移动端，更省电。 ② 有利于SEO。因为服务器端响应的是完整的 HTML 页面内容，所以爬虫更容易爬取获得信息，更有利于 SEO。 缺点： ① 占用服务器端资源。即服务器端完成 HTML 页面内容的拼接，如果请求较多，会对服务器造成一定的访问压力。 ② 不利于前后端分离，开发效率低。使用服务器端渲染，则无法进行分工合作，尤其对于前端复杂度高的项目，不利于项目高效开发。 2.前后端分离的新型Web开发模式 依赖于 Ajax 技术，也就是后端只负责提供 API 接口，前端使用 Ajax 调用接口的开发模式 优点： ① 开发体验好。前端专注于 UI 页面的开发，后端专注于api 的开发，且前端有更多的选择性。 ② 用户体验好。Ajax 技术的广泛应用，极大的提高了用户的体验，可以轻松实现页面的局部刷新。 ③ 减轻了服务器端的渲染压力。因为页面最终是在每个用户的浏览器中生成的。 缺点： ① 不利于 SEO（解决方案：利用Vue、React等前端框架SSR） 如何选择 Web 开发模式 看需求 没有复杂的交互用服务器…….. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"概念","slug":"概念","permalink":"http://kisskisso.com/tags/%E6%A6%82%E5%BF%B5/"}]},{"title":"常见错误","slug":"常见错误","date":"2020-03-12T12:37:41.000Z","updated":"2021-01-26T09:52:02.000Z","comments":true,"path":"2020/03/12/常见错误/","link":"","permalink":"http://kisskisso.com/2020/03/12/%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/","excerpt":"1.nodemon不是内部或外部命令，也不是可运行的程序 问题解决： 全局安装nodemon包，这样新创建的node.js应用都可以使用nodemon 运行起来 npm install -g nodemon 2.不小心把磁盘变成EFI分区了 解决办法： 用管理员打开 CMD 或者 PowerShell 第一步——输入diskpart 提示：在计算机上：***** 第二步——输入list vol 显示EFI分区","text":"1.nodemon不是内部或外部命令，也不是可运行的程序 问题解决： 全局安装nodemon包，这样新创建的node.js应用都可以使用nodemon 运行起来 npm install -g nodemon 2.不小心把磁盘变成EFI分区了 解决办法： 用管理员打开 CMD 或者 PowerShell 第一步——输入diskpart 提示：在计算机上：***** 第二步——输入list vol 显示EFI分区 第三步——输入sel vol 多余EFI分区的号卷 * 是所选的卷 第三步——del vol override 成功删除了卷 注：别删错EFI分区 3.U盘启动盘提示缺少mmx64.efi的问题 解决： 把U盘里的EFI/BOOT里的文件随便一个文件名命名为mmx64.efi 4.关于ThinkPad笔记本安装 双系统的问题 BIOS设置：Secure Boot设置为Enabled 分区：没试过，直接选择和win10共存 关于UEFL设置： 第一.将U盘设为第一启动项 shift + Starup=&gt;boot=&gt;enter=&gt;选择USB HDD …=&gt;shift 加 ‘+’ 第二.将Boot Mode设为Quick 第三.将Secure Boot设置为Enabled 4.Linux下如何升级nodejs ​ 方案： ​ 安装n模块：npm install -g n ​ 升级node.js到最新稳定版 ​ n stable(推荐) ​ 升级node.js到最新版 ​ n latest 报错： cp: cannot stat `/usr/local/n/versions/node/12.16.1/lib': No such file or directory cp: cannot stat `/usr/local/n/versions/node/12.16.1/include': No such file or directory cp: cannot stat `/usr/local/n/versions/node/12.16.1/share': No such file or directory 执行 n - 版本号 然后重新安装 注：可能需要酸酸乳 5.无法找到add-apt-repository命令 解决办法： sudo apt-get install python-software-properties sudo apt-get install software-properties-common 6.Linux下报错internal/modules/cjs/loader.js:985 throw err 解决： 卸载npm——–sudo apt-get remove --purge npm 删除————–rm -rf npm folder in 删除 ————-rm -rf cahce_npm folder in 然后重新下载npm------sudo apt-get install npm 7.如何切换包管理器 Windows： 解决： ①直接删除c:/用户/**/下的.vuerc 再次创建vue create xx或提示选择配置 ②手动修改.vuerc下的包 注：*修改为npm或者yarn { \"useTaobaoRegistry\": true, \"packageManager\": \"***\" } Linux： ~/.vuerc 被保存的 preset 将会存在用户的 home 目录下一个名为 .vuerc 的 JSON 文件里。如果你想要修改被保存的 preset / 选项，可以编辑这个文件。 终端下输入vim .vuerc修改 8.如何删除hexo中的分类 解决： 首先删除source文件夹中的分类文件与删除_postos里的.md文件 然后删除db.json文件 在然后hexo clean接着hexo g和hexo d 9.如何解决ssh: connect to host github.com port 22: Connection timed out 问题的原因：.ssh目录缺少config配置文件 解决： 进入.ssh文件夹，创建config文件写入xxx为你的邮箱地址 Host github.com User xxxxx@xx.com Hostname ssh.github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa Port 443 然后输入ssh -T git@github.com会出现一下提示 RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8. Are you sure you want to continue connecting (yes/no/[fingerprint])? yPlease type ‘yes’, ‘no’ or the fingerprint: yes 其实写入yes就可以了 10.如何解决npm下载错误问题？ npm ERR! Unexpected end of JSON input while parsing near ‘…TURE—–\\r\\n”}},”1.2’ 问题的原因可能是：1.网络问题：需替换淘宝镜像源，2.解析时JSON输入的意外结束 解决： 1.运行npm cache clean --force 2.更换淘宝镜像源npm config set registry=https://registry.npm.taobao.org/ 11.下载node-sass报错 npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! node-sass@4.14.1 postinstall: node scripts/build.js npm ERR! Exit status 1 npm ERR! npm ERR! Failed at the node-sass@4.14.1 postinstall script. npm ERR! This is probably not a problem with npm. There is likely additional logging output above. ​ 原因：在github上克隆代码npm install时候报错，也无法run项目 解决： 1.更换源npm install -g mirror-config-china --registry=http://registry.npm.taobao.org 然后在单独下载npm install node-sass node-sass的 github地址 12.deepin下typora安装报错 Error: could not find a distribution template 解决办法： ​ 终端打开 /etc/apt/sources.list 添加 ​ deb https://typora.io/linux ./ 注：首先要修改文件权限，在更改 13.误操作导致硬盘格式化 问题： 安装linux分区的时候，不小心点击格式化 解决办法： 下载大白菜做pe启动盘 bios设置u盘启动 进入pe系统后点击分区工具（diskgenius）进入之后，点击搜索分区…. 搜索完毕后，点击保存更改 重启系统 14.数据恢复后，重启显示verification failed:(15) access denied 解决办法：进入BIOS里面关闭安全启动（secure boot —-Enabled） 重新启动 15.重新启动后开机引导方式变成PCI LAN选项 问题： 开机的引导方式变成PCI LAN,并且前面有一个小箭头,无法正常启动加载。在BIOS中重置调整启动顺序也无法解决。无法进入U盘启动盘 解决办法： 1.进入BIOS找到ecurity--&gt;Secure Boot选项回车 2.回车后,把Secure Boot回车改成Disabled 3.接着按ESC返回上一级菜单,选择StartUp选项,把UEFI/Legacy Boot回车改成Both把UEFI/Legacy Boot Priority改成Legacy First，把 CSM Support改成YEs，接着按F10-YES保存即可 重新启动 16.运行nrm时候PowerShell显示系统禁止运行脚本 解决办法： 以管理员打开PowerShell输入set-executionpolicy remotesigned 恢复原来设置则set-executionpolicy Restricted 已完（开新）错误（二）… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"错误","slug":"错误","permalink":"http://kisskisso.com/tags/%E9%94%99%E8%AF%AF/"}]},{"title":"模块从缓存中加载（了解）","slug":"模块从缓存中加载（了解）","date":"2020-03-10T05:36:07.000Z","updated":"2021-01-26T10:16:28.000Z","comments":true,"path":"2020/03/10/模块从缓存中加载（了解）/","link":"","permalink":"http://kisskisso.com/2020/03/10/%E6%A8%A1%E5%9D%97%E4%BB%8E%E7%BC%93%E5%AD%98%E4%B8%AD%E5%8A%A0%E8%BD%BD%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89/","excerpt":"模块的加载机制：优先从缓存中加载 **模块在第一次加载后会被缓存**。这也意味着多次调用require() 不会导致模块的代码被执行多次。 注意：不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率。 内置模块的加载机制：内置模块的加载优先级最高。","text":"模块的加载机制：优先从缓存中加载 **模块在第一次加载后会被缓存**。这也意味着多次调用require() 不会导致模块的代码被执行多次。 注意：不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率。 内置模块的加载机制：内置模块的加载优先级最高。 自定义模块的加载机制：必须指定以**./** 或 ../ 开头的路径标识符加载否则会把它当作内置模块或第三方模块进行加载。 如果按确切的文件名没有找到模块，则Node.js 会尝试带上 .js、 .json 或 .node 拓展名再加载。 ⚫ .js 文件会被解析为JavaScript 文本文件 ⚫ .json 文件会被解析为JSON 文本文件 ⚫ .node 文件会被解析为通过process.dlopen() 加载的编译后的插件模块 第三方模块的加载机制：从当前模块的父目录开 始，尝试从它的/node_modules 目录里加载模块。 目录作为模块： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"模块","slug":"模块","permalink":"http://kisskisso.com/tags/%E6%A8%A1%E5%9D%97/"}]},{"title":"基本SQL语句的学习","slug":"基本SQL语句的学习","date":"2020-03-09T15:33:04.000Z","updated":"2021-01-26T10:07:12.000Z","comments":true,"path":"2020/03/09/基本SQL语句的学习/","link":"","permalink":"http://kisskisso.com/2020/03/09/%E5%9F%BA%E6%9C%ACSQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"– SELECT 和 FROM 是 SQL 中的关键字，因此被高亮了 – SELECT * FROM users – 只查询 id 和 username 两列 – 列之间使用英文的 , 进行分隔 – SELECT id, username FROM users – 向 users 表中插入一条新数据 – insert into users (？, ？) values (‘？’, ‘？’)– select * from users","text":"– SELECT 和 FROM 是 SQL 中的关键字，因此被高亮了 – SELECT * FROM users – 只查询 id 和 username 两列 – 列之间使用英文的 , 进行分隔 – SELECT id, username FROM users – 向 users 表中插入一条新数据 – insert into users (？, ？) values (‘？’, ‘？’)– select * from users – 把 id 为 1 的这个用户的密码，更新为 888888 – 注意：在使用 update 更新数据的时候，千万要记得添加 where 条件，否则整张表的数据都会被更新 – update users set ？ where id=？ – 需求：更新 id 为 2 这个用户，把密码更新成 admin123 同时把status更新为 1 – update users set password=’admin123’, status=1 where id=2 – 删除 id 为 4 的这条用户数据– delete from users where id=4 – 总结： – select insert into update delete – 演示常用的 WHERE 子句运算符 – 不等于 &lt;&gt; 或 != – select * from users where id&lt;&gt;2 – select * from users where id!=2 – 大于和小于 &gt; &lt; – select * from users where id&gt;2 – select * from users where id&lt;2 – 大于等于 &gt;= – select * from users where id&gt;=2 – 小于等于 &lt;= – select * from users where id&lt;=2 – 查询 status 为 0 且 id 小于 10 的用户 – select * from users where status=0 and id&lt;10 – 查询status为1或username为zs的用户列表 – select * from users where status=1 or username=’zs’ – order by 用来根据指定的列进行排序 – desc 代表降序排序 asc 代表升序排序 – 按照 status 对结果进行降序排序 – select * from users order by status desc – 按照 id 对结果进行降序排序 – select * from users order by id desc document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://kisskisso.com/tags/SQL/"}]},{"title":"开发自己的包","slug":"开发自己的包","date":"2020-03-08T14:08:33.000Z","updated":"2021-01-26T10:09:18.000Z","comments":true,"path":"2020/03/08/开发自己的包/","link":"","permalink":"http://kisskisso.com/2020/03/08/%E5%BC%80%E5%8F%91%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8C%85/","excerpt":"初始化包的基本结构： ① 新建 itheima-utils文件夹，作为包的根目录 ② 在 itheima-utils文件夹中，新建如下三个文件： ⚫ package.json （包管理配置文件） ⚫ index.js （包的入口文件） ⚫ README.md （包的说明文档） 将不同的功能进行模块化拆分","text":"初始化包的基本结构： ① 新建 itheima-utils文件夹，作为包的根目录 ② 在 itheima-utils文件夹中，新建如下三个文件： ⚫ package.json （包管理配置文件） ⚫ index.js （包的入口文件） ⚫ README.md （包的说明文档） 将不同的功能进行模块化拆分 编写包的说明文档 注册npm账号 npm login npm publish 【根目录】 注：包名不能一样 删除已发布的包—–npm unpublish 包名 –force命令 注意： ① npm unpublish 命令只能删除 72 小时以内发布的包 ② npm unpublish 删除的包，在 24 小时内不允许重复发布 ③ 发布包的时候要慎重，尽量不要往npm 上发布没有意义的包 发布包：不要乱发包 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"npm包","slug":"npm包","permalink":"http://kisskisso.com/tags/npm%E5%8C%85/"}]},{"title":"npm命令合集","slug":"npm命令合集","date":"2020-03-08T14:07:06.000Z","updated":"2021-01-26T09:26:54.000Z","comments":true,"path":"2020/03/08/npm命令合集/","link":"","permalink":"http://kisskisso.com/2020/03/08/npm%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86/","excerpt":"命令： npm -v ——-可以查看版本号 npm init -y ——–初始化【文件夹不能是中文】package.json npm install 包的完整名 &amp;&amp; npm i 包的名字（所以完整包） npm uninstall 包 ——–卸载指定的包 npm i 包安装包 @版本号———-安装指定版本的包 npm i 包名 -D ——–项目上线不使用的包记录进去 查看当前的下包的镜像源：","text":"命令： npm -v ——-可以查看版本号 npm init -y ——–初始化【文件夹不能是中文】package.json npm install 包的完整名 &amp;&amp; npm i 包的名字（所以完整包） npm uninstall 包 ——–卸载指定的包 npm i 包安装包 @版本号———-安装指定版本的包 npm i 包名 -D ——–项目上线不使用的包记录进去 查看当前的下包的镜像源： npm config get registry 切换镜像源： npm config set registry=https://registrytaobao.org/ npm config set registry=https://registry.npm.taobao.org/ 检查镜像源是否下载成功： npm config get registry 简单： 下载nrm工具 npm i nrm -g ——将nrm安装为全局可用工具 查看所有可用的镜像源 nrm ls 切换镜像源： nrm use taobao document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"npm命令","slug":"npm命令","permalink":"http://kisskisso.com/tags/npm%E5%91%BD%E4%BB%A4/"}]},{"title":"npm与包","slug":"npm与包","date":"2020-03-07T05:59:19.000Z","updated":"2021-01-26T09:27:22.000Z","comments":true,"path":"2020/03/07/npm与包/","link":"","permalink":"http://kisskisso.com/2020/03/07/npm%E4%B8%8E%E5%8C%85/","excerpt":"什么叫做包？ 就是指第三方模块，叫法同而已 ps:感觉就像是闲的无聊 包的来源？有网就可以下载，不是很麻烦 但是下载速吧。。。可能会让你抓狂 为什么需要包？ ​ 为了提高开发效率 像是JQuery和浏览器内置API的关系 官网： https://www.npmjs.com ps：没有中文请自备翻译器 初次安装包后，项目多node_module的文件夹和package-lock.json配置文件","text":"什么叫做包？ 就是指第三方模块，叫法同而已 ps:感觉就像是闲的无聊 包的来源？有网就可以下载，不是很麻烦 但是下载速吧。。。可能会让你抓狂 为什么需要包？ ​ 为了提高开发效率 像是JQuery和浏览器内置API的关系 官网： https://www.npmjs.com ps：没有中文请自备翻译器 初次安装包后，项目多node_module的文件夹和package-lock.json配置文件 node_modules 文件夹用来存放所有已安装到项目中的包。require() 导入第三方包时，就是从这个目录中查找并加载包。 package-lock.json配置文件用来记录node_modules 目录下的每一个包的信息，例如包的名字、版本号、下载地址等。 注意：不要手动修改node_modules 或 package-lock.json文件中的任何代码，npm 包管理工具会自动维护它们 ps：估计没人会手贱吧(￣.￣) 多人协作问题： 遇到的问题：第三方包的体积过大，不 方便团队成员之间共享项目源代码。 解决方法： 共享时剔除node_modules package.json，用来记录项目中安装了哪些包。 注：运行时npm i 自动安装包和版本号 dependencies 节点： package.json 文件中，有一个dependencies 节点，专门用来记录您使用npm install 命令安装了哪些包。 注意：npm install 命令运行完毕之后，会自动把包的信息，添加到package.json 的 dependencies 节点中。 devDependencies 节点： 某些包只在项目开发阶段会用到，在项目上线之后不会用到，则建议把这些包记录到devDependencies 节点 包的分类： 项目包与全局包 项目包 那些被安装到项目的node_modules 目录中的包，都是项目包。 项目包又分为两类，分别是： ⚫ 开发依赖包（被记录到devDependencies 节点中的包，只在开发期间会用到） ⚫ 核心依赖包（被记录到dependencies 节点中的包，在开发期间和项目上线之后都会用到 全局包 ​ npm i 包名 -g 全局包 注意： ① 只有工具性质的包，才有全局安装的必要性。因为它们提供了好用的终端命令。 ② 判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可。 规范的包结构： ① 包必须以单独的目录而存在 ② 包的顶级目录下要必须包含package.json 这个包管理配置文件 ③ package.json 中必须包含 name，version，main这三个属性，分别代表包的名字、版本号、包的入口。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://kisskisso.com/tags/npm/"}]},{"title":"Node.js的加载方法","slug":"Node-js的加载方法","date":"2020-03-05T12:27:37.000Z","updated":"2021-01-26T09:25:48.000Z","comments":true,"path":"2020/03/05/Node-js的加载方法/","link":"","permalink":"http://kisskisso.com/2020/03/05/Node-js%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E6%B3%95/","excerpt":"加载其它模块，使用require()方法： //加载内置的fs模块 const fs = require('fs') //必须加单引号 //加载用户自定义模块 const cistom = require('./cistom.js') //加载第三方模块（关于第三方模块的下载和使用，会在后面的课程中进行专门的讲解） 注：使用require()方法加载其它模块时，会执行被加载模块中的代码 向外共享模块作用域中的成员： module对象：","text":"加载其它模块，使用require()方法： //加载内置的fs模块 const fs = require('fs') //必须加单引号 //加载用户自定义模块 const cistom = require('./cistom.js') //加载第三方模块（关于第三方模块的下载和使用，会在后面的课程中进行专门的讲解） 注：使用require()方法加载其它模块时，会执行被加载模块中的代码 向外共享模块作用域中的成员： module对象： 在每个 .js 自定义模块中都有一个module 对象，它表示当前这个具体的.js 模块。module 对象上存储了和当前模块有关的信息 module.exports 对象： 在自定义模块中，可以使用module.exports 对象，将模块内的成员共享出去，供外界使用。 外界用 require() 方法导入自定义模块时，得到的就是module.exports 所指向的对象。 Eg： module.exporst{ ... } exports对象: exports 是对 module.exports 的引用，默认情况下，exports 和 module.exports 指向同一个对象。使用exports 向 外共享成员更加方便。 exports 和 module.exports 的使用误区: 时刻谨记，require() 模块时，得到的永远是module.exports 指向的对象： 注：为了防止混乱，建议大家不要在同一个模块中同时使用exports 和 module.exports 杂： Node.js 遵循了 CommonJS 模块化规范，CommonJS 规定了模块的特性和各模块之间如何相互依赖。 CommonJS 规定： ① 每个模块内部，module 变量代表当前模块。 ② module 变量是一个对象，它的exports 属性（即 module.exports）是对外的接口。 ③ 加载某个模块，其实是加载该模块的module.exports 属性。require() 方法用于加载模块。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"node","slug":"node","permalink":"http://kisskisso.com/tags/node/"}]},{"title":"模块化基本概念","slug":"模块化基本概念","date":"2020-03-05T12:10:19.000Z","updated":"2021-01-26T10:17:28.000Z","comments":true,"path":"2020/03/05/模块化基本概念/","link":"","permalink":"http://kisskisso.com/2020/03/05/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"什么是模块化？ -模块化是指解决一个复杂问题时，自顶向下逐层把系统划分分成若干模块的过程。对于整个系统来说，模块是可组合、分解和更换的单元。 -编程领域中的模块化，就是遵守固定的规则，把一个大文件拆成独立并互相依赖的多个小模块。 把代码进行模块化拆分的好处: 1. 提高了代码的复用性 2. 提高了代码的可维护性 3. 可以实现按需加载 4. etc.... 模块化规范： 模块化规范就是对代码进行模块化的拆分与组合时，需要遵守的那些规则 模块化规范的好处：","text":"什么是模块化？ -模块化是指解决一个复杂问题时，自顶向下逐层把系统划分分成若干模块的过程。对于整个系统来说，模块是可组合、分解和更换的单元。 -编程领域中的模块化，就是遵守固定的规则，把一个大文件拆成独立并互相依赖的多个小模块。 把代码进行模块化拆分的好处: 1. 提高了代码的复用性 2. 提高了代码的可维护性 3. 可以实现按需加载 4. etc.... 模块化规范： 模块化规范就是对代码进行模块化的拆分与组合时，需要遵守的那些规则 模块化规范的好处： 大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块之间的相互调用， 利人利己 Node.js 中模块的分类： Node.js 中根据模块来源的不同，将模块分为了3 大类，分别是： ⚫ 内置模块（内置模块是由Node.js 官方提供的，例如fs、path、http 等） ⚫ 自定义模块（用户创建的每个.js 文件，都是自定义模块） ⚫ 第三方模块（由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载） Node.js 中的模块作用域： 在 Node.js 中，用户创建的每个.js 文件都是自定义模块。 在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域 模块作用域的好处： 防止了全局变量污染的问题 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"模块化","slug":"模块化","permalink":"http://kisskisso.com/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"}]},{"title":"http模块","slug":"http模块","date":"2020-03-04T05:36:23.000Z","updated":"2021-01-26T09:04:56.000Z","comments":true,"path":"2020/03/04/http模块/","link":"","permalink":"http://kisskisso.com/2020/03/04/http%E6%A8%A1%E5%9D%97/","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"node","slug":"node","permalink":"http://kisskisso.com/tags/node/"}]},{"title":"path路径模块","slug":"path路径模块","date":"2020-03-03T14:12:49.000Z","updated":"2021-01-26T09:28:06.000Z","comments":true,"path":"2020/03/03/path路径模块/","link":"","permalink":"http://kisskisso.com/2020/03/03/path%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97/","excerpt":"●path.join()的方法可以把多个路径片段拼接为完整的路径字符串 Eg: const fp = path.join(__dirname, ‘/成绩.txt’) path.join([...paths]) 注：__dirname 参数解读： ⚫ ...paths &lt;string&gt; 路径片段的序列 ⚫ 返回值: &lt;string&gt; ​ ●path.basename()的方法，可以从一个文件路径中，获取到文件的名称部分 Eg: const fpath = '/a/b/c/index.html' var fullName = path.basename(fpath)--&gt;index.html var fullName = path.basename(fpath,'.html')--&gt;index ●使用 path.extname() 方法，可以获取路径中的扩展名部分","text":"●path.join()的方法可以把多个路径片段拼接为完整的路径字符串 Eg: const fp = path.join(__dirname, ‘/成绩.txt’) path.join([...paths]) 注：__dirname 参数解读： ⚫ ...paths &lt;string&gt; 路径片段的序列 ⚫ 返回值: &lt;string&gt; ​ ●path.basename()的方法，可以从一个文件路径中，获取到文件的名称部分 Eg: const fpath = '/a/b/c/index.html' var fullName = path.basename(fpath)--&gt;index.html var fullName = path.basename(fpath,'.html')--&gt;index ●使用 path.extname() 方法，可以获取路径中的扩展名部分 Eg: const fpath = '/a/b/c/index.html' const fext = path.extname(fpath)--&gt;.html path.extname(path) 参数解读： ⚫ path &lt;string&gt;必选参数，表示一个路径的字符串 ⚫ 返回: &lt;string&gt; 返回得到的扩展名字符串 引入path路径模块 cosnt fpath = reuire('path') 注：今后反涉及到fs模块操作指定路径的文件都要用__dirname进行路径的拼接，不要使用./或../ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"node","slug":"node","permalink":"http://kisskisso.com/tags/node/"}]},{"title":"fs文件动态路径拼接问题(了解)","slug":"fs文件动态路径拼接问题","date":"2020-03-03T13:41:27.000Z","updated":"2021-01-26T08:58:32.000Z","comments":true,"path":"2020/03/03/fs文件动态路径拼接问题/","link":"","permalink":"http://kisskisso.com/2020/03/03/fs%E6%96%87%E4%BB%B6%E5%8A%A8%E6%80%81%E8%B7%AF%E5%BE%84%E6%8B%BC%E6%8E%A5%E9%97%AE%E9%A2%98/","excerpt":"在使用 fs 模块操作文件时，如果提供的操作路径是以./ 或 ../ 开头的相对路径时，很容易出现路径动态拼接错误的问题。 原因：代码在运行的时候，会以执行node 命令时所处的目录，动态拼接出被操作文件的完整路径。","text":"在使用 fs 模块操作文件时，如果提供的操作路径是以./ 或 ../ 开头的相对路径时，很容易出现路径动态拼接错误的问题。 原因：代码在运行的时候，会以执行node 命令时所处的目录，动态拼接出被操作文件的完整路径。 解决方案：在使用fs 模块操作文件时，直接提供绝对路径，不要提供./ 或 ../ 开头的相对路径，从而防止路径动态拼接的问题。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"node","slug":"node","permalink":"http://kisskisso.com/tags/node/"}]},{"title":"fs文件系统模块","slug":"fs文件系统模块","date":"2020-03-03T12:45:59.000Z","updated":"2021-01-26T08:58:48.000Z","comments":true,"path":"2020/03/03/fs文件系统模块/","link":"","permalink":"http://kisskisso.com/2020/03/03/fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%97/","excerpt":"什么是fs文件系统模块？ fs模块是Node.js官方提供的、用来操作文件的模块 ​ ●fs.readFile()方法,用来读取指定文件中的内容","text":"什么是fs文件系统模块？ fs模块是Node.js官方提供的、用来操作文件的模块 ​ ●fs.readFile()方法,用来读取指定文件中的内容 fs.readFile(path[,options],callback) 参数解读： ⚫参数1：必选参数，指定文件路径的字符串， ⚫参数2：可选参数，什么编码格式读取文件 ⚫参数3：必选参数，文件读取完成后，通过回调函数拿到读取结果 注：箭头函数中(err,data)=&gt;{} err---失败之后的错误对象 data---读取之后的文本 ​ ●fs.writeFile()方法,用来向指定的文件中写入内容 fs.writeFile(file,data[,options],callback) 参数解读： ⚫ 参数1：必选参数，需要指定一个文件路径的字符串，表示要文件的存放路径。 ⚫ 参数2：必选参数，表示要写入的内容。 ⚫ 参数3：可选参数，表示以什么格式写入文件内容，默认值是utf8。 ⚫ 参数4：必选参数，文件写入完成后的回调函数。 导入js模块： const fs = require('fs') 注：const 是常量 ● fs.readdir()方法，可以读取指定目录下所有文件的名称 fs.readdir(path[,options],callback) 参数解读： ⚫ 参数1：必选参数，表示要读取哪个目录下的文件名称列表。 ⚫ 参数2：可选参数，以什么格式读取目录下的文件名称，默认值是utf8。 ⚫ 参数3：必选参数，读取完成以后的回调函数。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"node","slug":"node","permalink":"http://kisskisso.com/tags/node/"}]},{"title":"初始Node","slug":"初始Node","date":"2020-03-03T02:39:35.000Z","updated":"2021-01-26T09:53:28.000Z","comments":true,"path":"2020/03/03/初始Node/","link":"","permalink":"http://kisskisso.com/2020/03/03/%E5%88%9D%E5%A7%8BNode/","excerpt":"什么是Node.js Node.js是一个基于chrome v8引擎的JavaScript运行环境 注：1浏览器是JavaScript的前端运行环境 ​ 2.Node.js是JavaScript的后端运行环境 3.Node.js中无法调用DOM和BOM等浏览器内置API Node.js怎么学： 浏览器中JavaScript学习路径：","text":"什么是Node.js Node.js是一个基于chrome v8引擎的JavaScript运行环境 注：1浏览器是JavaScript的前端运行环境 ​ 2.Node.js是JavaScript的后端运行环境 3.Node.js中无法调用DOM和BOM等浏览器内置API Node.js怎么学： 浏览器中JavaScript学习路径： JavaScript基础语法+浏览器内置API（DOM+BOM）+第三方库(JQuery、art-temloate等) ​ Node.js的学习路径： JavaScript基础语法+Node.js内置API模块（fs、path、http等）+第三方API模块（express、mysql等） 在Node.js环境中执行JavaScript代码方式： 1.REPL中，输入JavaScript代码并执行（了解） 注：命令行不能在REPL环境中使用 2.通过命令行的形式，来执行指定JavaScript文件的代码 命令快捷键： 1.使用↑键，可以快速定位到上一次执行命令 2.使用tab键，能够快速补全全路径 3.使用esc键，能够快速清空当前已输入的命令 4.输入cls命令，可以清空终端 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://kisskisso.com/tags/Node/"}]},{"title":"错误合集","slug":"错误合集","date":"2020-03-01T13:39:42.000Z","updated":"2021-01-26T09:54:48.000Z","comments":true,"path":"2020/03/01/错误合集/","link":"","permalink":"http://kisskisso.com/2020/03/01/%E9%94%99%E8%AF%AF%E5%90%88%E9%9B%86/","excerpt":"1.Uncaught SyntaxError: Unexpected token ‘{‘ 我在引入css文件代码的时候，没注意把js引入当css引入来写了导致报错 2.Failed to load resource: net::ERR_SSL_PROTOCOL_ERROR 请求协议问题需将https换成http【注：插件】 3.Uncaught TypeError: Cannot read property ‘imports’ of undefined date写成data dateFormat写成dataFormat 粗心导致","text":"1.Uncaught SyntaxError: Unexpected token ‘{‘ 我在引入css文件代码的时候，没注意把js引入当css引入来写了导致报错 2.Failed to load resource: net::ERR_SSL_PROTOCOL_ERROR 请求协议问题需将https换成http【注：插件】 3.Uncaught TypeError: Cannot read property ‘imports’ of undefined date写成data dateFormat写成dataFormat 粗心导致 4.TypeError: Cannot read property ‘data’ of undefined stack: “TypeError: Cannot read property ‘cancelToken’ of undefined↵ at throwIfCancellationRequested (webpack-internal:///./node_modules/axios/lib/core/dispatchRequest.js:12:14)↵ at dispatchRequest (webpack-internal:///./node_modules/axios/lib/core/dispatchRequest.js:24:3)” message: “Cannot read property ‘cancelToken’ of undefined” 解决：判断如果当前有token就带token，如果没有反之 我判断了但是还是报错，发现在axios拦截器并没有加返回值也就是return config 5.清理npm缓存 npm cache clean -f document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"错误","slug":"错误","permalink":"http://kisskisso.com/tags/%E9%94%99%E8%AF%AF/"}]},{"title":"axios使用","slug":"axios使用","date":"2020-02-26T06:11:07.000Z","updated":"2021-01-26T08:48:10.000Z","comments":true,"path":"2020/02/26/axios使用/","link":"","permalink":"http://kisskisso.com/2020/02/26/axios%E4%BD%BF%E7%94%A8/","excerpt":"引入axio文件 axios是一个用于进行ajax操作的js库 -体积小，功能独立，除了ajax以外没有其他的额外功能 ​","text":"引入axio文件 axios是一个用于进行ajax操作的js库 -体积小，功能独立，除了ajax以外没有其他的额外功能 ​ ​ 下载地址： ​ - https://unpkg.com/axios@0.19.2/dist/axios.min.js 发送get请求 axios({ method:'get', url:'接口', params:{ name:'jack', age:18, gender:'男' } }).then(function (res){ console.log(res); }); 发送post请求 axios({ method:'post', url:'接口', data:{ name:'rose', age:19, gender:'女' } }).then(function(res){ console.log(res); }); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"axios","slug":"axios","permalink":"http://kisskisso.com/tags/axios/"}]},{"title":"ajax上传进度处理","slug":"ajax上传进度处理","date":"2020-02-26T05:59:32.000Z","updated":"2021-01-26T08:46:52.000Z","comments":true,"path":"2020/02/26/ajax上传进度处理/","link":"","permalink":"http://kisskisso.com/2020/02/26/ajax%E4%B8%8A%E4%BC%A0%E8%BF%9B%E5%BA%A6%E5%A4%84%E7%90%86/","excerpt":"","text":"&nbsp; &lt;!-- 设置文件域和上传按钮 --&gt; &lt;input type=\"file\" id=\"ipt\"&gt; &lt;button id=\"btn\"&gt;按钮&lt;/button&gt; &lt;div class=\"progress\" style=\"width:500px; margin: 10px 0;\"&gt; &lt;div class=\"progress-bar progress-bar-info progress-bar-striped active\" id=\"percent\" style=\"width:0%\"&gt; 0% &lt;/div&gt; &lt;/div&gt; &lt;script src=\"lib/jquery.js\"&gt;&lt;/script&gt; &lt;script&gt; // 按钮点击 $('#btn').on('click', function () { // 获取文件内容 var files = $('#ipt')[0].files; var fd = new FormData(); fd.append('file', files[0]); // 设置原生ajax请求，进行上传进度设置（如果使用jQuery，直接取网上找插件即可） // 1 基本的ajax步骤 var xhr = new XMLHttpRequest(); xhr.open('post', 'http://www.liulongbin.top:3006/api/upload/avatar'); // 2 上传进度检测 // - 上传中，onprogress事件会自动触发多次（具体次数不固定，取决于网速和文件大小） // - 我自己测试的次数： 60k左右的图片，触发3次， 30M左右的视频，触发几十次 xhr.upload.onprogress = function (e) { // - e.lengthComputable 表示是否具有可计算的文件大小 // - 布尔值，true表示文件可以使用 if (e.lengthComputable) { // - e.total 上传文件的总大小 // - e.loaded 已上传大小 // - toFixed() 保留指定位小数 var bili = (e.loaded / e.total * 100).toFixed(2) + '%'; // 根据上传进度，设置具体功能 // - 设置进度条宽度和内容为比例 $('#percent').css('width', bili).text(bili); } }; // 3 上传完毕，修改显示效果 // upload.onload 事件会在上传操作完毕后触发 xhr.upload.onload = function () { $('#percent').removeClass().addClass('progress-bar progress-bar-success'); }; xhr.send(fd); }); &lt;/script&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"http://kisskisso.com/tags/ajax/"}]},{"title":"非同源与http辅助演示","slug":"非同源与http辅助演示","date":"2020-02-25T13:10:14.000Z","updated":"2021-01-26T09:59:12.000Z","comments":true,"path":"2020/02/25/非同源与http辅助演示/","link":"","permalink":"http://kisskisso.com/2020/02/25/%E9%9D%9E%E5%90%8C%E6%BA%90%E4%B8%8Ehttp%E8%BE%85%E5%8A%A9%E6%BC%94%E7%A4%BA/","excerpt":"非同源地址进行跨域请求演示： var xhr = new XMLHttpRequest(); xhr.open('get', '接口'); xhr.send(); http辅助演示文件： http的get请求的请求报文组成演示： ​ 第一行为请求行 GET /api/getbooksid=1&amp;bookname=%E8%A5%BF%E6%B8%B8%E8%AE%B0 HTTP/1.1","text":"非同源地址进行跨域请求演示： var xhr = new XMLHttpRequest(); xhr.open('get', '接口'); xhr.send(); http辅助演示文件： http的get请求的请求报文组成演示： ​ 第一行为请求行 GET /api/getbooksid=1&amp;bookname=%E8%A5%BF%E6%B8%B8%E8%AE%B0 HTTP/1.1 后面的部分为请求头 请求头是本次请求的相关信息 这些信息大部分都是浏览器自动设置的 我们自己设置过一些： Content-Type Host: 接口 Connection: keep-alive Accept: / User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.79Safari/537.36 Origin: null Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 If-None-Match: W/“91-hlrWKV2QmzU6DUa8qes2AyEeCbs” 注：请求体是用来保存请求发送的数据使用的，get请求的请求参数都在url中发送，请求体为空 http的post请求的请求报文组成演示： —-请求行—- POST /api/addbook HTTP/1.1 —-请求头—- Host: 接口 Connection: keep-alive Content-Length: 112 Accept: / User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.79 Safari/537.36 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 Origin: null Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 注：post的请求参数是在请求体中发送的 之前在请求头中设置的Content-Type是用来指定请求体的内容类型的 响应报文演示： —-状态行—– HTTP/1.1 200 OK —-响应头信息—- 响应头保存的是响应的相关信息 X-Powered-By: Express Access-Control-Allow-Origin: Date: Mon, 24 Feb 2020 08:59:57 GMT —响应报文中的Content-Type指的是响应的数据的内容类型— Content-Type: application/json; charset=utf-8 Content-Length: 145 ETag: W/“91-hlrWKV2QmzU6DUa8qes2AyEeCbs” 注：响应体指的是服务器响应给客户端的数据，其实就是我们一直使用的res document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"http","slug":"http","permalink":"http://kisskisso.com/tags/http/"}]},{"title":"JSONP","slug":"JSONP","date":"2020-02-25T12:54:42.000Z","updated":"2021-01-26T09:13:48.000Z","comments":true,"path":"2020/02/25/JSONP/","link":"","permalink":"http://kisskisso.com/2020/02/25/JSONP/","excerpt":"JSONP的跨域方式： 同源策略限制了对非同源地址发送ajax请求 JSONP与ajax无关，而是借助script标签对非同源地址进行请求 步骤： 1 设置script标签 2 将接口地址设置在script标签的src属性中 script接收的所有文字内容都会被自动当作js代码执行 服务器中会响应某个名称的函数调用形式 3 在src的接口地址后，以get请求参数形式，手动设置callback的参数","text":"JSONP的跨域方式： 同源策略限制了对非同源地址发送ajax请求 JSONP与ajax无关，而是借助script标签对非同源地址进行请求 步骤： 1 设置script标签 2 将接口地址设置在script标签的src属性中 script接收的所有文字内容都会被自动当作js代码执行 服务器中会响应某个名称的函数调用形式 3 在src的接口地址后，以get请求参数形式，手动设置callback的参数 callback的值为本次设置的处理函数名称 4 在script之前，设置对应名称的处理函数 并且设置形参，接收服务器真正响应的数据 5 根据需求使用响应的数据即可 &lt;script&gt; function success(res) { console.log(res); 注：不能写在后面 console.log(res.data); } &lt;/script&gt; &lt;script src=\"接口/?callback=success&amp;name=jack&amp;age=18\"&gt;&lt;/script&gt; JQuery发送jsonp请求方式： 注：JSONP和ajax没有任何关联 JQuery为了方便操作，将jsonp的设置方式直接放在$.ajax()中 $.ajax({ type:'get', url:'接口', data:{ name:'jack', age:18 }, // 设置dataType: 'jsonp'表示本次请求采用jsonp方式发送 // 通过调试工具看到，本次请求的type为script，确定是jsonp请求 // 页面中没有用于发送jsonp的script，是因为jQuery在使用完毕后进行了删除操作 dataType:'jsonp', success:function(res){ console.log(res); } }); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"jsonp","slug":"jsonp","permalink":"http://kisskisso.com/tags/jsonp/"}]},{"title":"封装函数ajax添加beforeSend和complete","slug":"封装函数ajax添加beforeSend和complete","date":"2020-02-25T12:16:47.000Z","updated":"2021-01-26T10:00:34.000Z","comments":true,"path":"2020/02/25/封装函数ajax添加beforeSend和complete/","link":"","permalink":"http://kisskisso.com/2020/02/25/%E5%B0%81%E8%A3%85%E5%87%BD%E6%95%B0ajax%E6%B7%BB%E5%8A%A0beforeSend%E5%92%8Ccomplete/","excerpt":"​ 封装一个函数模拟$.ajax()的使用形式 –参数：配置对象形式 –option -type -url -data -success -beforeSend -copmplete 请求方式 请求地址 请求参数 请求成功时触发的回调函数 发送请求前触发的回调 响应完毕（不区分成功失败）时触发的回调 ​","text":"​ 封装一个函数模拟$.ajax()的使用形式 –参数：配置对象形式 –option -type -url -data -success -beforeSend -copmplete 请求方式 请求地址 请求参数 请求成功时触发的回调函数 发送请求前触发的回调 响应完毕（不区分成功失败）时触发的回调 ​ function ajax(option) { 请求触发前操作 option.beforeSend(); 请求发送功能 var xhr = new XMLHttpRequest(); var type = option.type.toLowerCase(); var data = urlencoded(option.data); if (type === 'grt'){ xhr.open('get', option.url + '?' + data); xhr.send(); } else if (type === 'post') { xhr.open('post', option.url); xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.send(data); } // --- 响应处理功能 // 1 设置事件 xhr.onreadystatechange = function () { // 2 检测响应下载完毕 if (xhr.readyState === 4) { // 3 进行成功检测 if (xhr.status === 200) { // 将JSON格式的数据转换为对象 var res = JSON.parse(xhr.responseText); // 4 操作响应的数据，进行成功时的处理 option.success(res); } // --- 此位置确定响应下载完毕，而且不区分成功或失败，执行complete即可 option.complete(); } }; } // 功能测试： /* ajax({ type: 'get', url: 'http://www.liulongbin.top:3006/api/getbooks', data: { id: 1, bookname: '西游记' }, success: function (res) { console.log('成功时接收的响应信息', res); }, beforeSend: function () { console.log('请求开始发送啦'); }, complete: function () { console.log('请求处理完毕啦'); } }); */ ajax({ type: 'post', url: 'http://www.liulongbin.top:3006/api/addbook', data: { bookname: '张三自传', author: '张三', publisher: '张三出版社' }, success: function (res) { console.log(res); }, beforeSend: function () { console.log('请求开始发送啦'); }, complete: function () { console.log('请求处理完毕啦'); } }); // 之前准备的用于将对象转换为urlencoded的函数 function urlencoded(obj) { // 1 遍历对象 var arr = []; for (var key in obj) { // 2 将当前属性拼接为 '名=值' 的格式 arr.push(key + '=' + obj[key]); } // 3 使用数组方法join()用&amp;连接每个元素即可 return arr.join('&amp;'); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"http://kisskisso.com/tags/ajax/"}]},{"title":"Git出现的错误","slug":"Git-出现的错误","date":"2020-02-25T10:37:43.000Z","updated":"2021-01-26T08:59:44.000Z","comments":true,"path":"2020/02/25/Git-出现的错误/","link":"","permalink":"http://kisskisso.com/2020/02/25/Git-%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF/","excerpt":"可能出现的错误： ①git push 出现Everything up-to-date 解决方法 1.可能你没有git.add 和git commit - git add . - git commit -m 'message' - git push origin master","text":"可能出现的错误： ①git push 出现Everything up-to-date 解决方法 1.可能你没有git.add 和git commit - git add . - git commit -m 'message' - git push origin master 2.无法推送远程仓库 ​ error:src refspec master does not match any ||| error:failed to push some refs to ‘仓库地址’ ​ 暂存区没有文件 ​ 解决： git add . git commit -m \"xxxx\" // xxx随意 3.显示没有权限 ​ 可以添加公钥： ssh-keygen -t rsa -C ‘youremail’ 然后一路Enter（回车） 系统盘—&gt;用户—&gt;你的文件—&gt;.ssh文件夹里 —&gt;id_rsa.pub(这是公共秘钥) 注：切记！！！切记！！！切记！！！里面的id_rsa是私人秘钥不能给其它人看 打开github—&gt;点击你的头像settings—&gt;然后在点击SSH and GPG keys—&gt;点击Add deploy key新建一个ssh—&gt;Title随便写—&gt;Key里把id_rsa.pub里面的信息复制进去【注：是公共秘钥不要复制错误】 在git bash中输入ssh -T git@github.com 显示你的用户名就成功了 4.推送远程仓库出现的问题 hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., ‘git pull …’) before pushing again.hint: See the ‘Note about fast-forwards’ in ‘git push –help’ for details. 问题原因： 其他地方向同一远端库推送了代码，导致本地不是最新的 解决方案： 先从远端pull一下，执行：git pull 5.git推送更新出现错误 ! [rejected] master -&gt; master (fetch first)error: failed to push some refs to ‘https://github.com/xxx/xxx.git'hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., ‘git pull …’) before pushing again.hint: See the ‘Note about fast-forwards’ in ‘git push –help’ for details. 解决办法： ​ 如果本地代码无误后进行推送进行强制推送： ​ git push -f origin master 对了不要直接执行上面的命令，别忘了初始化以及add和commotion -m (～￣▽￣)～ 待更新中… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"git","slug":"git","permalink":"http://kisskisso.com/tags/git/"}]},{"title":"Git","slug":"Git","date":"2020-02-25T06:59:41.000Z","updated":"2021-01-26T08:59:24.000Z","comments":true,"path":"2020/02/25/Git/","link":"","permalink":"http://kisskisso.com/2020/02/25/Git/","excerpt":"如何使用Git： ​ 第一步： 连接远程仓库：git remote add [name] [URL仓库地址] ​ 第二步： git init 初始化 【注：隐藏.git 不要动】 ​","text":"如何使用Git： ​ 第一步： 连接远程仓库：git remote add [name] [URL仓库地址] ​ 第二步： git init 初始化 【注：隐藏.git 不要动】 ​ ​ 第三步： git add .将当前目录下所有文件添加 ​ 第四步： git commit -m ‘描述信息’ 【注：初次使用会git会进行身份验证】 ​ git config –global user.email ‘邮箱’ ​ git config –global user.name ‘名字’ 不要问然后呢？没然后了...没有 之后就是git add . git commit -m ......无限循环直到循环到小盒子里||o(*°▽°*)o|Ю [有人吗?] git版本查看和版本穿梭： git log –oneline——查看版本 git reset –hard 版本号 ——进行版本穿梭 有的时候手会滑，把git给关闭了，正好穿梭在旧版本中， 想看更新的版本号，使用git reflog 注：前面的话不重要，重要的是git reflog。 分支： 默认只有主分支 master ​ 一般来讲主分支需要保存的是没问题的，用于上线使用的代码 开发阶段的代码新建其它分支进行，不要在主分支上操作 git branch 查看分支 git branch 【名字】 创建分支 git checkout 【名字】 切换分支 git checkout -b 【名字】 创建并切换 git push origin xxx:xxx 本地分支xxx作为远程xxx分支 git checkout -d 【名字】 删除分支 【注：不要把-b 和-d 搞混…. 切记！！！切记！！！切记！！！】 git clone -b &lt;指定分支名&gt; &lt;远程仓库地址&gt; 克隆分支代码 【杂：这这是删除本地的分支】 如果要查看远程分支则git branch -a即可 git push 库名 –delete 分支名 git merge 【名字】 合并分支 ​ 注：合并，是将指定分支合并到当前所处的分支下 Eg：当前在master，执行git merge dev，表示将dev合并到master中 应该是这样吧或许 合并冲突： 出现的原因：多个分支修改同一个文件的同一块内容，然后进行了合并 根据需要进行删除工作 推送到远程仓库： git push 将代码拉取更新到本地（本地有项目代码时使用）： git pull 也可以用可视化工具（看个人情况） github desktop 软件 vscode插件 Gitlens 如何克隆远程仓库： git clone http://仓库地址 git push 推送（注:第一次推送会输入密码和账号） 如果出现Everything up-to-date 则看 ①解决办法 git add. git commit -m ‘message’ git push origin master 如何连接远程仓库： git remote add [name] [URL仓库地址] 如何删除远程仓库链接 git remote rm origin 如何创建子模块： 添加：git submodule add 仓库地址 路径 删除：要在“.gitmodules”文件中删除相应配置信息。然后，执行“git rm –cached ”命令将子模块所在的文件从git中删除 更新？：git submodule update 如何学习Git： 推荐个网址：猴子都能懂得GIT入门 待更新中… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"git","slug":"git","permalink":"http://kisskisso.com/tags/git/"}]},{"title":"xhr与FormData对象的使用","slug":"xhr与FormData对象的使用","date":"2020-02-24T12:39:47.000Z","updated":"2021-01-26T09:47:56.000Z","comments":true,"path":"2020/02/24/xhr与FormData对象的使用/","link":"","permalink":"http://kisskisso.com/2020/02/24/xhr%E4%B8%8EFormData%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"xhr的timeout和ontimeout和onload： timeout和ontimeout： 注①：-send()方法用于发送http请求，如果是异步请求（默认）则此方法会在请求后立即返回；如果是同步请求，则此方法直到响应到达后才会返回 -语法：XMLHttpRequest.send() 【xhr.send()】","text":"xhr的timeout和ontimeout和onload： timeout和ontimeout： 注①：-send()方法用于发送http请求，如果是异步请求（默认）则此方法会在请求后立即返回；如果是同步请求，则此方法直到响应到达后才会返回 -语法：XMLHttpRequest.send() 【xhr.send()】 发送一个get请求 var xhr =new XMLHttpRequest(); xhr.open('get','接口')； 设置请求超时时间（毫秒单位） -如果超过指定时间，请求会被取消，后续的操作不执行 xhr.timeout = 30000; xhr.ontimeout = function () { alert('超时了') }; xhr.send(); xhr.onreadystatechange = function () { if(xhr.readyState === 4 &amp; xhr.status === 200) { console.log(xhr.responseText); } }; onload: 发送请求 var xhr = new XMLHttpRequest(); xhr.open('get','接口')； xhr.send(); 响应处理： - xhr中提供了onload事件，直接用于表示xhr.readyState为4的情况，用于简化响应处理操作 - 但是还是需要进行xhr.status的判断处理 xhr.onload = function () { if (xhr.status === 200){ console.log(xhr.responseText); } }; FormData对象的使用 使用FormData模拟表单进行自定义数据上传 1创建一个空的FormData对象 var fd = new FormData(); 2给fd添加数据，使用fd的append() fd.append('name','jack'); fd.append('age',18); 注：无法直接输出fd查看数据，需要使用get方法操作 Eg： consol.log(fd.get('name')); 3通过ajax发送给对应接口 -注：FormData数据必须使用post请求方式发送 var xhr = new XMLHttpRequest(); xhr.open('post','端口'); -直接将FormData对象放入到send()参数中即可，也不需要设置requestHeader xhr.send(fd); 使用FormData对表单数据进行处理： html结构： &lt;form id=\"myForm\"&gt; 用户名: &lt;input type=\"text\" name=\"username\"&gt; &lt;br&gt; 密码: &lt;input type=\"password\" name=\"psw\"&gt; &lt;br&gt; 性别: &lt;input type=\"password\" name=\"gender\"&gt; &lt;br&gt; 学校: &lt;input type=\"password\" name=\"school\"&gt; &lt;br&gt; &lt;!-- 为了不产生表单提交效果，将按钮修改为普通按钮即可 --&gt; &lt;button id=\"btn\" type=\"button\"&gt;提交&lt;/button&gt; &lt;/form&gt; js部分： var myForm = document.qureySelector(\"#myForm\"); 1进行按钮操作 document.getElementById('btn').onclick = function () { 2通过FormData对象获取表单所有数据 -给FormData传入参数，参数为form标签/DON对象 var fd = new FormData(mtForm); 注① 希望在表单元素的基础上，再格外上传一些数据，也可以使用append() fd.append('girlFriend','rose'); -delete()删除某天数据 fd.delete('***') 3通过ajax发送 var xhr = new XMLHttpRequest(); xhr.open('post', '接口'); xhr.send(fd); } 文件的上传1：【有form】 &lt;form id=\"myForm\"&gt; &lt;input type=\"text\" name=\"username\"&gt; &lt;input type=\"password\" name=\"pws\"&gt; &lt;textarea name=\"txt\"&gt;&lt;/textarea&gt; &lt;!-- 文件域：用于进行文件选取 --&gt; &lt;input type=\"file\" name=\"avatar\"&gt; &lt;button type=\"button\" id=\"btn\"&gt;按钮&lt;/button&gt; &lt;/form&gt; &lt;!-- 这个img用于显示上传后的线上图片 --&gt; &lt;img src=\"\" alt=\"\" id=\"pic\"&gt; &lt;script&gt; // 1 按钮点击事件 var btn = document.getElementById('btn'); var myForm = document.getElementById('myForm'); var pic = document.getElementById('pic'); btn.onclick = function () { // 2 使用fd管理表单数据 var fd = new FormData(myForm); // 3 将表单提交给服务器（包含了要上传的文件） var xhr = new XMLHttpRequest(); xhr.open('post', '接口'); xhr.send(fd); // 响应内容中具有上传的图片文件的线上地址，可以进行访问 xhr.onload = function () { if (xhr.status === 200) { var res = JSON.parse(xhr.responseText); pic.src = '接口' + res.url; } } }; &lt;/script&gt; 文件上传2：【无form】 &lt;!-- 如果要上传的是一个单独的表单域，没有form结构，需要进行单独处理 --&gt; &lt;input type=\"file\" id=\"ipt\"&gt; &lt;!-- 由于没有form，button就不存在提交的问题 --&gt; &lt;button id=\"btn\"&gt;提交&lt;/button&gt; &lt;img src=\"\" alt=\"\" id=\"pic\"&gt; &lt;script&gt; var btn = document.getElementById('btn'); var ipt = document.getElementById('ipt'); var pic = document.getElementById('pic'); // 1 设置点击按钮事件 btn.onclick = function () { // 2 创建FormData对象 var fd = new FormData(); // 3 根据需求将数据添加到fd中 // - 如何进行文件添加 // - 1 找到文件域中选择的文件 // - ipt.files[0] 代表了要上传的文件 // - ipt.files.length 代表选择文件的个数，如果为0说明没选文件 // - 2 使用append将文件添加到fd中即可 fd.append('fileUpload', ipt.files[0]); // 4 发送请求 var xhr = new XMLHttpRequest(); xhr.open('post', '接口'); xhr.send(fd); // 5 接收响应，可以将线上图片地址进行展示 xhr.onload = function () { if (xhr.status === 200) { pic.src = '接口' + JSON.parse(xhr.responseText).url; } } }; JQuery发送FormData的方式： &lt;!-- 如果要上传的是一个单独的表单域，没有form结构，需要进行单独处理 --&gt; &lt;input type=\"file\" id=\"ipt\"&gt; &lt;!-- 操作按钮 --&gt; &lt;button id=\"btn\"&gt;提交&lt;/button&gt; &lt;!-- 用于展示线上的图片地址 --&gt; &lt;img src=\"\" alt=\"\" id=\"pic\"&gt; &lt;script src=\"./lib/jquery.js\"&gt;&lt;/script&gt; &lt;script&gt; // 1 设置按钮的点击事件 $('#btn').on('click', function () { // 2 获取文件域的文件信息 var files = $('#ipt')[0].files; console.log(files); // 3 检测是否上传了文件 if (files.length === 0) { return; } // 4 创建FormData对象 var fd = new FormData(); fd.append('uploads', files[0]); // 5 通过jQuery的ajax发送这个FormData $.ajax({ type: 'post', url: '接口', // 将fd直接设置给data data: fd, // 如果要发送FormData，必须设置以下属性 contentType: false, // 无需jQuery设置请求参数的内容类型 processData: false, // 无需jQuery进行数据处理 success: function (res) { if (res.status === 200) { $('#pic').prop('src', '接口' + res.url) } } }); }); &lt;/script&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"xhr","slug":"xhr","permalink":"http://kisskisso.com/tags/xhr/"}]},{"title":"JSON在js转换方法","slug":"JSON在js转换方法","date":"2020-02-24T12:23:42.000Z","updated":"2021-01-26T09:14:20.000Z","comments":true,"path":"2020/02/24/JSON在js转换方法/","link":"","permalink":"http://kisskisso.com/2020/02/24/JSON%E5%9C%A8js%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/","excerpt":"JSON.parse()将JSON转换为js对象 JSON.stringify()将js对象转换为JSON 注：JSON的格式 属性名必须使用双引号包裹 字符串类型的值必须使用双引号包裹 JSON 中不允许使用单引号表示字符串 JSON 中不能写注释 JSON 的最外层必须是对象或数组格式 不能使用 undefined 或函数作为 JSON 的值","text":"JSON.parse()将JSON转换为js对象 JSON.stringify()将js对象转换为JSON 注：JSON的格式 属性名必须使用双引号包裹 字符串类型的值必须使用双引号包裹 JSON 中不允许使用单引号表示字符串 JSON 中不能写注释 JSON 的最外层必须是对象或数组格式 不能使用 undefined 或函数作为 JSON 的值 JSON 的作用：在计算机与网络之间存储和传输数据。 JSON 的本质：用字符串来表示 Javascript 对象数据或数组数据 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JSON方法","slug":"JSON方法","permalink":"http://kisskisso.com/tags/JSON%E6%96%B9%E6%B3%95/"}]},{"title":"封装Ajax函数","slug":"封装Ajax函数","date":"2020-02-23T12:08:44.000Z","updated":"2021-01-26T10:00:20.000Z","comments":true,"path":"2020/02/23/封装Ajax函数/","link":"","permalink":"http://kisskisso.com/2020/02/23/%E5%B0%81%E8%A3%85Ajax%E5%87%BD%E6%95%B0/","excerpt":"封装Ajax函数 封装准备工作_封装将对象转换为urlencoded函数 方式1： function urlencoded(obj) { 1 遍历对象obj var str = ''; for (var key in obj) { 2将当前属性拼接为 '名=值' 的格式 str += key + '=' + obj[key] + '&amp;'; } 3将字符串最后多余的&amp;去除 //str = str.slice(0,str.length - 1); str = str.slice(9,-1); 4设置返回值即可 return str; } 方式2：","text":"封装Ajax函数 封装准备工作_封装将对象转换为urlencoded函数 方式1： function urlencoded(obj) { 1 遍历对象obj var str = ''; for (var key in obj) { 2将当前属性拼接为 '名=值' 的格式 str += key + '=' + obj[key] + '&amp;'; } 3将字符串最后多余的&amp;去除 //str = str.slice(0,str.length - 1); str = str.slice(9,-1); 4设置返回值即可 return str; } 方式2： function urlencoded(obj) { 1遍历对象 var arr = []; for (var key in obj) { 2 将当前属性拼接为 '名=值' 的格式 arr.push(key + '=' + obj[key]); } 3 使用数组方法join()用&amp;连接每个元素即可 return arr.join('&amp;'); } 多功能目标的演示： var result = urlencoded({ name: 'jack', age: 18, gender: '男' }); console.log(result); 封装Ajax函数 封装一个函数模拟$.ajax()的使用形式 参数：配置对象形式 - option - type 请求方式 - url 请求地址 - data 请求参数 - success 回调函数 function ajax(option) { ---请求发送功能--- 1初始化 var xhr = new XMLHttpRequest(); 2 由于后续请求发送功能的get和post操作不同，根据请求方式进行分别设置 - 因为请求方式名不区分大小写，可以进行统一转换 - toLowerCase() 用于将字符串中的字母转换为小写 var type = option.type.toLowerCase(); -将data统一转换为urlencoded var data = urlencoded(option.data); if (type === 'get') { 2.1 设置get请求的open和send功能 xhr.open('get',option.url + '?' + data); xhr.send(); } else if (type === 'post') { 2.2 设置post请求的open和send功能 xhr.open('post',option.url); xhr.setRequestHeader('Content-Type','application/x-ww-form-uelencoded'); xhr.send(data); } ---响应处理功能--- 1 设置事件 xhr.onreadystatechange = function () { 2 检测状态 if(xhr.readyState === 4 &amp; xhr.status === 200) { 3 将JSON格式的数据转换为对象 varres = JSON.parse(xhr.responseText); 4 操作响应的数据 option.success(res) } }; } 准备用于将对象转换为urlencoded的函数： function urlencoded(obj) { 1 遍历对象 var arr = []; for (var key in obj) { 2 将当前属性拼接为 '名=值' 的格式 arr.push(key + '=' + obj[key]); } 3 使用数组方法join()用&amp;连接每个元素即可 return arr.join('&amp;'); } // 代码纯属演示： // - 用于说明jQuery的get请求本质与原生操作相同，因为就是基于原生封装的 // - 直接将get参数拼接在url后面一样可以正常发送 $.get(‘网址+?id=1&amp;bookname=西游记’, function (res) { console.log(res); }); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://kisskisso.com/tags/Ajax/"}]},{"title":"get请求与post请求的区别","slug":"get请求与post请求的区别","date":"2020-02-23T11:22:18.000Z","updated":"2021-01-26T08:59:06.000Z","comments":true,"path":"2020/02/23/get请求与post请求的区别/","link":"","permalink":"http://kisskisso.com/2020/02/23/get%E8%AF%B7%E6%B1%82%E4%B8%8Epost%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"总结 get请求与post请求的区别： 1.语义区别: -get -post 请求用于获取数据 请求用于发送数据","text":"总结 get请求与post请求的区别： 1.语义区别: -get -post 请求用于获取数据 请求用于发送数据 2.请求参数的发送位置有区别： -get请求的参数，在URL中传递 -post请求的请求参数，无法看到传递位置 3.可发送数据大小不同 -get请求参数在URL中发送，浏览器限制了URL的长度，不同浏览器限制不同 ​ -可发送数据大小为2k ​ -post请求，理论上没有大小限制（都是由服务器限制） ​ -根据需求进行限制设置 ​ -根据服务器处理能力进行限制设置 4.可发送内容格式不同 ​ -get只能发送文字数据 -post可以发送各种类型数据 get请求参数的形式： 格式为：接口地址？请求参数 ​ 形式为： 请求参数：名=值&amp;名=值&amp;名=值......【注：某个值为中文，中文会自动进行编码处理】 （network-&gt;点击某个get请求-&gt;headers-&gt;Query String Parameters-&gt;可以查看所参数） post请求参数形式： 形式为： ​ URL编码形式urlencoded，只是与get发送位置不同，数据的形式相同 （network-&gt;点击某个post请求-&gt;headers-&gt;Form Data-&gt;可以查看所有参数） 原生的ajax发送get请求的使用： 浏览器提供XMLHttpRequest构造函数，用于创建可以发送ajax对象 —–请求发送功能—– 1创建xhr实例 var xhr = new XMLMLHttpRequest(); 2调用open()用于建立与服务器的链接 -设置请求方式和请求地址 -参数1：请求方式，get或者post -请求地址 xhr.open('get','地址')； 3调用send()，用于将请求发送出去，这一句send()是异步代码 xhr.send(); —–响应处理功能—– 由于send()是异步操作，所有不能直接在send()之后直接写代码获取响应内容 - xhr.readyState 用于表示ajax对象的操作状态 - 0 初始化阶段：创建了xhr实例 - 1 调用open：建立与服务器的连接 - 2 调用send：请求发送了 - 3 下载中 - 4 下载完毕：确定下载完毕，还能使用响应的数据 1设置事件，监测响应的状态 xhr.onreadystatechange = function () { 2检测响应下载完毕，还应当确保本次请求是成功的请求状态，这样响应才有意义 - xhr.status 本次请求的状态码 - 200 成功 404没有找到对应资源 if (xhr.status === 4 &amp;&amp; xhr.status === 200) { 3 获取响应内容 // console.log(xhr.responseText); var data = xhr.responseText; 4 将JSON格式的数据转换为js对象 由于是原生写法，没有人帮我们进行数据类型处理，我们需要自己进行数据处理 data = JSON.parse(data); console.log(data); } }; 发送带有参数的get请求： — 请求发送功能— 1 初始化xhr对象 var xhr = new XMLHttpRequest(); 2 调用open - get请求参数以?连接，拼接在url后面，形式为urlencoded xhr.open('get', 'http://www.liulongbin.top:3006/api/getbooks?id=2&amp;bookname=红楼梦'); 3 调用send xhr.send(); —响应处理— 1 设置事件 xhr.onreadystatechange = function () { 2 检测响应是否下载完毕/请求是否成功 if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) { 3 接收响应内容 var res = xhr.responseText; 4 将JSON转换为js对象 res = JSON.parse(res); console.log(res); } }; 发送post请求： 1 初始化xhr对象 var xhr = new XMLHttpRequest(); 2 调用open xhr.open('POST', 'http://www.liulongbin.top:3006/api/addbook'); 3 设置本次请求发送的内容类型（告诉服务器请求参数的类型） - 设置内容类型为urlencoded即可 - setRequestHeader() 用于设置请求头的信息 - 请求头：是请求发送的一些额外信息，这些额外信息用于确保请求发送的数据可以正确被服务器接收使用 xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); 4 发送请求 - post请求的请求参数为urlencoded形式，传入到send()中即可 xhr.send('bookname=老人与海&amp;author=海明威&amp;publisher=机械工业出版社'); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://kisskisso.com/tags/Ajax/"}]},{"title":"图书管理","slug":"图书管理","date":"2020-02-22T15:00:02.000Z","updated":"2021-01-26T10:32:00.000Z","comments":true,"path":"2020/02/22/图书管理/","link":"","permalink":"http://kisskisso.com/2020/02/22/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86/","excerpt":"html部分： 只是一段代码没注释也不是很多 enter编码13","text":"html部分： 只是一段代码没注释也不是很多 enter编码13 &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"./lib/bootstrap.css\" /&gt; &lt;/head&gt; &lt;body style=\"padding: 15px;\"&gt; &lt;!-- 添加图书的Panel面板 --&gt; &lt;div class=\"panel panel-primary\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h3 class=\"panel-title\"&gt;添加新图书&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"panel-body form-inline\"&gt; &lt;!-- 顶部进行图书新增的结构部分 --&gt; &lt;div class=\"input-group\"&gt; &lt;div class=\"input-group-addon\"&gt;书名&lt;/div&gt; &lt;input type=\"text\" class=\"form-control\" id=\"iptBookname\" placeholder=\"请输入书名\"&gt; &lt;/div&gt; &lt;div class=\"input-group\"&gt; &lt;div class=\"input-group-addon\"&gt;作者&lt;/div&gt; &lt;input type=\"text\" class=\"form-control\" id=\"iptAuthor\" placeholder=\"请输入作者\"&gt; &lt;/div&gt; &lt;div class=\"input-group\"&gt; &lt;div class=\"input-group-addon\"&gt;出版社&lt;/div&gt; &lt;input type=\"text\" class=\"form-control\" id=\"iptPublisher\" placeholder=\"请输入出版社\"&gt; &lt;/div&gt; &lt;!-- 点击添加新图书 --&gt; &lt;button id=\"btnAdd\" class=\"btn btn-primary\"&gt;添加&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 图书的表格 --&gt; &lt;table class=\"table table-bordered table-hover\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;书名&lt;/th&gt; &lt;th&gt;作者&lt;/th&gt; &lt;th&gt;出版社&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id=\"tb\"&gt; &lt;!-- 用于放置图书信息的tbody标签 --&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/body&gt; js部分： &lt;script src=\"./lib/jquery.js\"&gt;&lt;/script&gt; &lt;script&gt; renderBook(); $('#btnAdd').on('click', function() { var val1 = $('#iptBookname').val().trim(); var val2 = $('#iptAuthor').val().trim(); var val3 = $('#iptPublisher').val().trim(); if (val1 === '' || val2 === '' || val3 === '') { alert('请输入完整的数据'); return; } var kids = '添加书的接口addbooks'; $.post(kids, { bookname: val1, author: val2, publisher: val3 }, function(res) { if (res.status === 201) { renderBook(); $('#bookname').val(); $('#author').val(); $('#publisher').val(); } }) }); function renderBook() { var kid = '获取书的接口getbooks'; $.get(kid, function(res) { if (res.status !== 200) { return; }; var data = res.data; console.log(data) var str = ''; $.each(data, function(k, r) { str += ' &lt;tr&gt;\\ &lt;td&gt;' + r.id + '&lt;/td&gt;\\ &lt;td&gt;' + r.bookname + '&lt;/td&gt;\\ &lt;td&gt;' + r.author + '&lt;/td&gt;\\ &lt;td&gt;' + r.publisher + '&lt;/td&gt;\\ &lt;td&gt;&lt;a href=\"javascript:;\"&gt;删除 &lt;/a&gt;&lt;td&gt;\\ &lt;/tr&gt;; ' }); $('#tb').html(str); }); } &lt;/script&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"应用与插件","slug":"应用与插件","permalink":"http://kisskisso.com/categories/%E5%BA%94%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"案例（一）","slug":"案例（一）","permalink":"http://kisskisso.com/tags/%E6%A1%88%E4%BE%8B%EF%BC%88%E4%B8%80%EF%BC%89/"}]},{"title":"Ajax（总结）","slug":"Ajax(总结)","date":"2020-02-22T12:40:42.000Z","updated":"2021-01-26T08:36:42.000Z","comments":true,"path":"2020/02/22/Ajax(总结)/","link":"","permalink":"http://kisskisso.com/2020/02/22/Ajax(%E6%80%BB%E7%BB%93)/","excerpt":"总结 Ajax是一种技术，这种技术通过执行一段js代码就可以实现【Asynchronous JavaScript And XML（也就是异步 JavaScript和XML）】 前端、后端交互的技术也就是【发送请求】与【接受响应结果】","text":"总结 Ajax是一种技术，这种技术通过执行一段js代码就可以实现【Asynchronous JavaScript And XML（也就是异步 JavaScript和XML）】 前端、后端交互的技术也就是【发送请求】与【接受响应结果】 前端需要做的就是写JS代码发送请求、接受服务器返回的结果，并处理【切记接口是后端的事】 关于Ajax代码有两种： 使用工具JQuery： 【别人封装好的，按语法使用】 $.get() $.post() 获取服务器中的资源 用于向服务器发送资源 方式：a标签的href、link/script:src/video…… 发送post请求的方式 $.ajax() 请求操作但不跳转功能； network判断请求资源类型方式； type判断请求资源类型； xhr代表请求ajax | document:请求html页面 jpeg/img…… 使用原生的js： var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { //this.responseTwxt;服务器返回的结果 } xhr.open(); //post方式。注：加请求头 xhr.send(); 模版引擎： 加载： 引入template-web.js 设置模版： type = ‘text/template’ id = ‘xxx’ JS代码 ： 准备数据，实际多数都是服务器返回的数据 调用template函数 ：参数1：模版id 参数2：需要展示的数据 返回值：拼接好一段HTML 模版语法： 【｛｛｝｝英文的花括号】 $data代表template()传入参数2，数据对象 $data可以正常的进行属性访问 如果访问￥data的属性,可以不写$data 填充内容是结构字符串，并且进行结构生成，在内容前书写@ 重点： 1.接口是后端写的，提供接口文档 2.必须按照接口文档来发送请求【注：①接口规定是什么请求方式，必须用该请求方式，哪怕看着不顺眼②接口要什么请求参数，必须给对象的请求参数】 细节： 同步异步： 同步：大多数js功能都是同步任务，会按照代码书写顺序执行。 注:某些任务较为耗时或执行时间不确定，如果采用同步任务，会导致后续的任务等待 异步：异步任务总是在同步任务之后执行，不会导致其它任务进行等待。 --------常见的异步任务有：定时器 / AJAX 请求参数写法： JQuery封装的三个方法 对象形式：{参数:值,参数:值,…} 原生的JS——-参数=值&amp;参数=值&amp;….. 两种请求方式的区别： 意义不同 传递数据大小不同 参数位置不同 接受到服务器返回的数据，如何渲染【模版引擎】 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://kisskisso.com/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"如何有效阅读一本书（六）","slug":"如何有效阅读一本书(六)","date":"2020-01-29T06:45:16.000Z","updated":"2021-01-26T10:24:08.000Z","comments":true,"path":"2020/01/29/如何有效阅读一本书(六)/","link":"","permalink":"http://kisskisso.com/2020/01/29/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6(%E5%85%AD)/","excerpt":"读书笔记是一种升华工具，可以让读书活动完成从生搬硬套到独创思维的飞跃。 固定场景中重读笔记【另一方面要养成重读笔记—量化重读漂频率】 积极输出促进思想内化 杂：我想了一下，好像什么都没记住，我感觉预习也很重要。不不不应该很重要。对没错，是这样。。。哦对了还有一点是切勿眼高手低","text":"读书笔记是一种升华工具，可以让读书活动完成从生搬硬套到独创思维的飞跃。 固定场景中重读笔记【另一方面要养成重读笔记—量化重读漂频率】 积极输出促进思想内化 杂：我想了一下，好像什么都没记住，我感觉预习也很重要。不不不应该很重要。对没错，是这样。。。哦对了还有一点是切勿眼高手低 通过重读为思想增色 1.想要简单回顾是—-重读读书笔记 2.想要回忆起更多时—-参考书中的重点段落 3.想从头开始看起时—–重读原书 等待…. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"阅读","slug":"阅读","permalink":"http://kisskisso.com/tags/%E9%98%85%E8%AF%BB/"}]},{"title":"js 基础（一）","slug":"js-基础（一）","date":"2020-01-21T10:45:18.000Z","updated":"2021-01-26T09:12:14.000Z","comments":true,"path":"2020/01/21/js-基础（一）/","link":"","permalink":"http://kisskisso.com/2020/01/21/js-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"js的语法基础：（ECMASCRIPT） js的书写位置： 内嵌式写法： 外联式写法：【大项目】 eg：参照css的书写位置（1.行内式2.内嵌式3.外联式） 1.最好写在body的后面外联式写法：【大项目】 1.新建js文件（后缀名就是.js）【直接写js 】 通过&lt;script src='js文件路径'&gt;&lt;/script&gt;引用js文件 行内式写法：（了解） 1.点击事件onclick js输出消息：","text":"js的语法基础：（ECMASCRIPT） js的书写位置： 内嵌式写法： 外联式写法：【大项目】 eg：参照css的书写位置（1.行内式2.内嵌式3.外联式） 1.最好写在body的后面外联式写法：【大项目】 1.新建js文件（后缀名就是.js）【直接写js 】 通过&lt;script src='js文件路径'&gt;&lt;/script&gt;引用js文件 行内式写法：（了解） 1.点击事件onclick js输出消息： ●为什么学习js输出消息的方式？ 展示的结果给用户查看 在控制台中输出消息： console．log（） 注意：在程序中遇到的任何一个特殊符号，都必须是英文输入法下的符号。 在浏览器弹出一个新窗口【alert();】 js变量 字面意思： 变量：变化的值 程序角度： 保存数据的一个容器 变量的定义： var 自定义变量名 注意：定义变量必须写 var 变量的赋值： 1.var 变量名 = 值; 2.var 变量名; 变量名 = 值; 注意：'='赋值运算符 将'='右侧的值赋给左侧的变量 备注：如果在程序中输出一个值，如果该值是一个变量，不需要加引号。 备注：程序输出一个值，如果该值是一个变量，不需要加引导。如果不是则需要加。 ​ 一个变量可以重复赋值，但是一个变量只能一个值，而且是最后一次赋值的结果。 备注: ‘=’两边都需要加个空格 变量名的命名规则 1.变量名在合法的时候还要具有一定的语义 2.不能用关键字命名【关键字不能作为变量名】—–关键字—–在js中有特殊含义 3.不能数字开头命名【不能以特殊符号开头，‘_’ ,’$’除外】 4.变量中不能出现空格 5.不能使用汉字定义变量 6.不建议直接使用‘name’作为变量名，容易和属性冲突 7.不建议使用js中的保留字作为变量名————在当前版本没有特殊含义，但是js其它版本或以后版本中具有关键字的作用 练习1: 让用户输入任意的摄氏度,得到对应的华氏度.[华氏度=9/5*摄氏度+32] var kid = prompt('请输入摄氏度...'); var kids = 9/5*kid+32; document.write(kids); 练习2: 交换两个变量的值 水杯问题: var a = 1; var b = 2; var c = a; a=b; b=c; document.write(a,b); 练习3: 求和 var kid = 3; //var kid = '3'; var kids = 2; var kll = kid + kids; console.log(kll); 数据类型 1.简单数据类型【掌握】 ●数字类型number ●字符串类型string ●布尔类型boolean ●undefined类型 2.复杂类型【注】 object document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://kisskisso.com/tags/js/"}]},{"title":"js高级（三）","slug":"js高级（三）","date":"2020-01-17T01:50:23.000Z","updated":"2021-01-26T09:17:06.000Z","comments":true,"path":"2020/01/17/js高级（三）/","link":"","permalink":"http://kisskisso.com/2020/01/17/js%E9%AB%98%E7%BA%A7%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"this的使用： ●this是特殊的标识符，代表某个对象值。取值根据函数的调用方式会发生变化 ●全局中直接访问this，默认window 构造函数中this，默认为实例对象 方法中的this，默认为调用者 自调用函数与模块化 模块：块、部分意思。 模块化：指的是，将没进行 依赖：就是使用的意思 【文件不能划分全局作用域】","text":"this的使用： ●this是特殊的标识符，代表某个对象值。取值根据函数的调用方式会发生变化 ●全局中直接访问this，默认window 构造函数中this，默认为实例对象 方法中的this，默认为调用者 自调用函数与模块化 模块：块、部分意思。 模块化：指的是，将没进行 依赖：就是使用的意思 【文件不能划分全局作用域】 回调函数：作为函数参数使用的函数 forEach():遍历到数组的每个元素 注：return 不能结束 注：qAll的结果为NList伪数组对象具有forEach 数组其它回调函数到方法： map（）every（）some（）reduce（）filter（）find（）findIndex（） 查文档自学上述方法【寒假作业】 mdn 局部变量（私有变量）确保数据安全性 如果将变量设置为私有变量，就可以确保数据安全性，不会被外界操作修改。 ​ → 问题是：不仅不能修改，也无法访问 作用域。。接受返回值（返回值是函数） 确保数据安全性—-闭包函数作用 函数只能返回一个返回值 递归函数： 为什么 5：5？ 【注：06|||||||||||||】 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://kisskisso.com/tags/js/"}]},{"title":"前言","slug":"前言3","date":"2020-01-16T10:37:33.000Z","updated":"2021-01-26T10:20:20.000Z","comments":true,"path":"2020/01/16/前言3/","link":"","permalink":"http://kisskisso.com/2020/01/16/%E5%89%8D%E8%A8%803/","excerpt":"","text":"读书笔记是自己和书的对话，所以不需要别人的观点，但如果在做完读书笔记以后可以重读书评，就可以参考“第三方的观点”，换个角度审视自己的这次读书体验。于是你会发现，原来对自己来说有着某种意义的书，在这个人眼里是这样的。 从某种意义上说，所有的艺术都带有一些自传体性质，你只能唱自己的歌画自己的画；只能做一个由自己的经验，环境和家庭所造成的你。无论好坏都的在生命的交响乐中演奏自己的小乐器。 明白不代表理解，理解不代表会应用，会应用不代表做的对，对不代表省时省力，中间的每一个环节考的就是这两个东西。 😸一个是练习 😸一个是不断总结 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"如何有效阅读一本书（五）","slug":"如何有效阅读一本书（五）","date":"2020-01-16T09:59:11.000Z","updated":"2021-01-26T10:25:00.000Z","comments":true,"path":"2020/01/16/如何有效阅读一本书（五）/","link":"","permalink":"http://kisskisso.com/2020/01/16/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%EF%BC%88%E4%BA%94%EF%BC%89/","excerpt":"如何有效阅读一本书（五） 剪报式读书笔记 复印粘贴以备重读 ps：可能会用不到，因为我大部分都是在kindle里面看 ：） 贴什么？ 抄——-这一页，正是这本书里最具代表性的一页。 ①书腰 ②信息卡片 ③书签 ④其它 引：“如果一个人总是把死亡的觉悟挂在嘴边，总让人感觉有些虚伪。” 杂：一切都会好起来的。不要想太多。","text":"如何有效阅读一本书（五） 剪报式读书笔记 复印粘贴以备重读 ps：可能会用不到，因为我大部分都是在kindle里面看 ：） 贴什么？ 抄——-这一页，正是这本书里最具代表性的一页。 ①书腰 ②信息卡片 ③书签 ④其它 引：“如果一个人总是把死亡的觉悟挂在嘴边，总让人感觉有些虚伪。” 杂：一切都会好起来的。不要想太多。 重读书评以加深思考 ps：不过有些书评简直是惨不忍睹。那也是书评，区分那些是好的那些是坏的。 引：“实际上我们常常因为虚荣心过剩，过度表现自己而苦恼有时候连退一步只做到自爱都就觉得索然无味。” 读书体验比书本身更重要，通过读重读笔记提高自我 【注：笔记—学以致用的读书体验】 概念：吸收精华—-原封不动地吸收书上的知识。 读书体验—以此契机我想到某件事（或如何理解） 杂：感觉有点心烦。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"阶段提问","slug":"阶段提问","date":"2020-01-16T07:12:47.000Z","updated":"2021-01-26T10:08:34.000Z","comments":true,"path":"2020/01/16/阶段提问/","link":"","permalink":"http://kisskisso.com/2020/01/16/%E9%98%B6%E6%AE%B5%E6%8F%90%E9%97%AE/","excerpt":"阶段提问 项目：html css js 动画 移动端 iPad【添加后面的代码】 基础：每日反馈 学历： webapi： js高级： 动画： 矢量图标： 它们的语法格式： innerTxet 和innerHTML的区别？ 移动端的触摸事件： tranform和translate： js中注册事件：","text":"阶段提问 项目：html css js 动画 移动端 iPad【添加后面的代码】 基础：每日反馈 学历： webapi： js高级： 动画： 矢量图标： 它们的语法格式： innerTxet 和innerHTML的区别？ 移动端的触摸事件： tranform和translate： js中注册事件： 事件委托： 冒泡的阻止发法： dom事件的三个阶段： bom？ 什么是视口？ 事件按键： flex布局： 如何定义弹性盒子： 栅格系统（12列） 全局作用域（）；局部作用域 不同事件this指向会发生改变吗? 浏览器的关闭与存储： 让盒子居中： rem适配： 媒体查询： 响应式布局： js事件三个阶段： less的用法：；变量 js数组函数方法？ break与区别？ js中的形参和实参区别？ js遍历方法？ 【forEach】 let与var区别？ js中如何操作元素属性？ 2d转换属性：；3d转化属性 流式布局？ 设置获取本地存储？ 字符串的用法？ less定义变量？ 控制台菜单问题？ 1.对于概念性问题是否深入？ 2.实例对象？构造函数 【注：任何问题在上课先记下，不要研究，避免跟不上思路】 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"问题","slug":"问题","permalink":"http://kisskisso.com/tags/%E9%97%AE%E9%A2%98/"}]},{"title":"防御机制（四）","slug":"心理防御（四）","date":"2020-01-16T07:11:36.000Z","updated":"2021-01-26T10:36:42.000Z","comments":true,"path":"2020/01/16/心理防御（四）/","link":"","permalink":"http://kisskisso.com/2020/01/16/%E5%BF%83%E7%90%86%E9%98%B2%E5%BE%A1%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"就算有一万个做错的理由也不能改变一件做错的事实否则在这个世上千千万万的可怜人是不是都有踏入歧途的正当理由 事到如今，后悔有什么用，时间不会回头，过去也没办法改变，但你还有未来要面对 人，总是要跨出那一步才会真的知道后续的路该怎么走下去","text":"就算有一万个做错的理由也不能改变一件做错的事实否则在这个世上千千万万的可怜人是不是都有踏入歧途的正当理由 事到如今，后悔有什么用，时间不会回头，过去也没办法改变，但你还有未来要面对 人，总是要跨出那一步才会真的知道后续的路该怎么走下去 我们的情绪地图 接纳自己的需求，忍受强烈的情感以及发展出自我价值。就意味着面对并接纳自己的各色情绪，拥有独立的自我与世界，强烈的自尊关乎着快乐与成就，相对的羞耻感，却是我们所知的一种最痛苦的感觉。我们生而为人，就要面对难以回避的诸多情绪。许多人难以承受他们的痛苦体验。承受：忍受特别是不可避免的感受。他们会赶快摆脱自己的感受（哈我想应该是酒与烟吧），分散注意力，甚至欺骗自己，怀疑他们的真实感受—-诉诸各种各样的防御机制。通常致使我们穿上防御盔甲的，正是这些最痛苦的情绪。 基本情感七对相对情绪： 1.愤怒与冷静 2.仇恨与爱 3.恐惧与自信 4.耻辱与无耻 5.感恩与对其的缺失 6.同情与愤慨 7.嫉妒与效法 一些最令我们感到痛苦，可能花一辈子时间都无法应对的情感，恰恰是那些我们初次感受到的情感。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"爱好心理学","slug":"爱好心理学","permalink":"http://kisskisso.com/categories/%E7%88%B1%E5%A5%BD%E5%BF%83%E7%90%86%E5%AD%A6/"}],"tags":[{"name":"防御机制","slug":"防御机制","permalink":"http://kisskisso.com/tags/%E9%98%B2%E5%BE%A1%E6%9C%BA%E5%88%B6/"}]},{"title":"防御机制（三）","slug":"防御机制（三）","date":"2020-01-15T12:28:43.000Z","updated":"2021-01-26T09:58:30.000Z","comments":true,"path":"2020/01/15/防御机制（三）/","link":"","permalink":"http://kisskisso.com/2020/01/15/%E9%98%B2%E5%BE%A1%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"在阅读本书的过程中，随身携带一个笔记本，记录下自己的反应，并将之存放在一个安全的地方，确保除自己以外的任何人都查看不了。【注：尽你所能地对自己诚实，不批判自己，试着知、只将焦点放在事实本身，即你的实际感受，你未经大脑篡改的反应，而不是你认为自己应该采取的回应。不要逼迫自己改变什么。】 练习： 1.不能，并没有在意或并没有发现。人多的时候。 2.有过，不是很好，的确令人不安。 3.没人对我讲起过，但我无意中听到过，确实如此，确实事实。 【注：每个人都在试图回避痛苦真相时用到的方式。】","text":"在阅读本书的过程中，随身携带一个笔记本，记录下自己的反应，并将之存放在一个安全的地方，确保除自己以外的任何人都查看不了。【注：尽你所能地对自己诚实，不批判自己，试着知、只将焦点放在事实本身，即你的实际感受，你未经大脑篡改的反应，而不是你认为自己应该采取的回应。不要逼迫自己改变什么。】 练习： 1.不能，并没有在意或并没有发现。人多的时候。 2.有过，不是很好，的确令人不安。 3.没人对我讲起过，但我无意中听到过，确实如此，确实事实。 【注：每个人都在试图回避痛苦真相时用到的方式。】 要开始学会问自己，那些不愉快的事实是你也不愿面对的。ps：眼睛与心态吧。 需要： 1.将需求与依赖当作关系中必不可少的部分； 2.学习管理自己强烈的情感； 3.培养自尊感（而不是羞耻感或损伤自己的感受） 【学会对自己养成一种如是的诚实————在评估自己的时候，即不要太严苛，也不要太随意——这是解除自己防御的必要步骤，学着尽可能客观地评价自己。】 一下是问题： 想把事情办好就得亲自动手 有时我太依赖他人了 遇到问题时，我总是幻想着别人替我“解决” 似乎我对别人的重视胜过他们对我的重视 我很少生气，从不会发火； 我超级会说话； 我时常尝试新事物，但总是三分钟热度； 我总是担心稍不留意就会有不花哦的事情发生 我经常反应过度，随之又懊悔不已 我希望自己没有情绪上的波动 我容易对自己犯下的错误过分自责 我害怕被人看低 我接受不了批判并对此十分抗拒 我希望自己是另一个人。 【注：这里重点并不是为了把自己归类，而是为了了解你要面对的心理挑战是什么，并作为识别自身防御机制的前奏。这一点尤为重要。切记！！！】 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"爱好心理学","slug":"爱好心理学","permalink":"http://kisskisso.com/categories/%E7%88%B1%E5%A5%BD%E5%BF%83%E7%90%86%E5%AD%A6/"}],"tags":[{"name":"心理学","slug":"心理学","permalink":"http://kisskisso.com/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"}]},{"title":"JavaScript高级（二）","slug":"js高级（二）","date":"2020-01-15T00:24:10.000Z","updated":"2021-01-26T09:15:58.000Z","comments":true,"path":"2020/01/15/js高级（二）/","link":"","permalink":"http://kisskisso.com/2020/01/15/js%E9%AB%98%E7%BA%A7%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"三个对象： 1.构造函数2.原型对象3.实例对象 三者关系小结： 1.构造函数：都是prototype属性，就是原型对象 2.实例对象：都是有_ _ proto _ _属性，也是原型对象 3.原型对象：具有constructor属性，也就是构造函数 注：两个对象同名不覆盖、不冲突 对象访问规则： 对象进行属性访问，先查找自身，如果没有再找opsiodfoa,并一直重复此过程","text":"三个对象： 1.构造函数2.原型对象3.实例对象 三者关系小结： 1.构造函数：都是prototype属性，就是原型对象 2.实例对象：都是有_ _ proto _ _属性，也是原型对象 3.原型对象：具有constructor属性，也就是构造函数 注：两个对象同名不覆盖、不冲突 对象访问规则： 对象进行属性访问，先查找自身，如果没有再找opsiodfoa,并一直重复此过程 查找ob.pro中如果还没有结果为undefined 这种由多个-型组成的结构，称为原型链 原型链的终点为Object.prototype 简单的说：就是 沿原型链查找【】 构造函数的继承操作： 创建子类、同时继承父类 ●使用构造函数进行集成时，属性和原型方法需要分别处理 继承父类属性： xx.call（this）的部分是固定形式，后面的参数按需修改 还可以进行新的属性设置，而且新的属性设置和继承操作没有顺序要求 2.继承父类原型的方法 由于原型继承操作是通过覆盖方式实现的，导致xxx.prototype自身不具有constructor 为了避免问题，自己添加个constructor；属性即可 设置原型方法时，必须在继承操作之后设置，否则也会被覆盖，相对于没写 多态设置： 构造函数进行多态设置，只能进行覆盖设置，无法像class一样对父类功能进行扩展 …….. 观察class与构造函数的关系： class操作的结果还是通过原型prototype进行处理的 只不过语法更简单 给内置对象添加功能的方式 内置方法的使用方式： 内置对象和我们之前的自定义对象设置方式相同，都是将方法设置在原型中 如果希望给内置对象设置新方法，设置在原型中即可 书写方式arr.xxx() 注：可读性更强 函数进阶内容： 【this可以复用】 1.函数的属性和方法（属性了解，使用方法重点） 2.函数的其它使用方式 ●自调用函数（立即执行函数） ●回调函数 ●闭包函数 ●递归函数 2.函数方法 1.call（）【用于调用函数，并设置本次掉用中的this】 ●参数1：要设置的this值，对象结构 ●后续参数：表示传入的实参，个数不限 书写方式：xx.类名.（｛｝，x，x，x） 2.apply（） apply用于调用函数，可以设置函数中的this ●参数1：用来设置函数中的this ●参数2：数组，用来保存实参 书写方式：xx.apply({},[]); 3.bind（） bind含义为绑定。 call和apply可以设置this，但都是临时设置，只有本次调用有效 如果 希望this长期被设置为某个对象，可以通过bind方法进行操作 ●参数1：需要绑定的this、值，对象 ●后续参数：需要绑定的实参值 ●返回值：绑定了this或实参的函数副本 function fun（a,b,c){ consloe.log(this); consloe.log(a,b,c); } //调用bind后，需要对返回的函数副本进行操作 var f1 = fun.bind({name:'啥啥啥'}); f1（）； f1.call({}) //绑定的实参如果与形参个数不同，进行调用时的传入方式也不一样 绑定this和实参用返回值（ 后续参数：需要绑定实参值 返回值：绑定了this或实参的函数副本 数组借用Math方法 call 和apply区别： call–传入实参是单个传入方式 apply–传入实参采用数组整体传入方式 函数的声明方式： 1.函数声明语句 2.函数表达式 两种声明方式的区别： 1.参与预解析时规则不同 2.函数声明语句对使用位置有一些要求（特殊环境不推荐使用） 不推荐在if语句中进行函数声明语句的设置（不同浏览器对这个操作的域解析结果不同） 自调用函数 自调用函数、立即执行函数 效果：在当前位置执行一次后结束 作用： ●将大功能分成小部分，每部分代码包裹一个自调用函数，可以形成独立的作用域 ●可以避免多个功能的代码出现冲突（变量命名重复导致修改的问题）【多人开发时名称冲突的问题】 书写注意点：每个自调用函数后的分号，必须加，否则，多个自调用函数连起来书写会报错 Eg：;(function(){ })(); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://kisskisso.com/tags/js/"}]},{"title":"防御机制（二）","slug":"心理学（二）","date":"2020-01-14T12:01:32.000Z","updated":"2021-01-26T10:37:16.000Z","comments":true,"path":"2020/01/14/心理学（二）/","link":"","permalink":"http://kisskisso.com/2020/01/14/%E5%BF%83%E7%90%86%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"​ 当我们拒绝接纳自身大部分的情感经历时，我们会消耗自己，同时消弱自己面对这个世界的力量与能力。当你封闭了对自己需求的觉知，你就不肯能与TA人发展出真正的亲密关系。 注：abwehr指译为“避开”或“抵挡”要比“防御”更准确。就其本质而言，一切防御机制都是我们逃避痛苦而向自己撒的谎。 防御机制只顾眼下一刻，而不计后果，是一个人思虑不周的反射性行为，只是为了规避当下一刻的痛苦，却不考虑由此带来的长期损失。注：人类是受习惯约束的动物，这样一来，改变便显得尤其困难。一般来说我们极容易养成自己特有的或习惯性的防御模式，而这些规避痛苦的惯用方法则会对我们性格的塑造产生影响。一个人的个性或者’全部的性格特征都可以称为浓缩版的防御机制‘【人的应为举止，说话走路方式等】","text":"​ 当我们拒绝接纳自身大部分的情感经历时，我们会消耗自己，同时消弱自己面对这个世界的力量与能力。当你封闭了对自己需求的觉知，你就不肯能与TA人发展出真正的亲密关系。 注：abwehr指译为“避开”或“抵挡”要比“防御”更准确。就其本质而言，一切防御机制都是我们逃避痛苦而向自己撒的谎。 防御机制只顾眼下一刻，而不计后果，是一个人思虑不周的反射性行为，只是为了规避当下一刻的痛苦，却不考虑由此带来的长期损失。注：人类是受习惯约束的动物，这样一来，改变便显得尤其困难。一般来说我们极容易养成自己特有的或习惯性的防御模式，而这些规避痛苦的惯用方法则会对我们性格的塑造产生影响。一个人的个性或者’全部的性格特征都可以称为浓缩版的防御机制‘【人的应为举止，说话走路方式等】 当某一种人格障碍被大众所熟悉时，却也定义了一个人的性格，框定了他/她的人际关系。 根据自身采取的防御机制，将会塑造我们的个性。也会影响人际关系。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"爱好心理学","slug":"爱好心理学","permalink":"http://kisskisso.com/categories/%E7%88%B1%E5%A5%BD%E5%BF%83%E7%90%86%E5%AD%A6/"}],"tags":[{"name":"防御机制","slug":"防御机制","permalink":"http://kisskisso.com/tags/%E9%98%B2%E5%BE%A1%E6%9C%BA%E5%88%B6/"}]},{"title":"扩展","slug":"扩展","date":"2020-01-14T03:22:17.000Z","updated":"2021-01-26T10:11:04.000Z","comments":true,"path":"2020/01/14/扩展/","link":"","permalink":"http://kisskisso.com/2020/01/14/%E6%89%A9%E5%B1%95/","excerpt":"","text":"for(in):?【重要 】concat:?slice:? var/let（过年后会讲）/const：？ 严格模式：？【没人用】 块级作用域：？ dom：进程减少次数 事件委托： 减少事件的个数 动态处理？ _ _ proto _ _: | 什么constructor原型 &lt;——&gt;people 先找自己后找内部？？？？ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"JavaScript高级（一）","slug":"JavaScript高级","date":"2020-01-14T00:56:56.000Z","updated":"2021-01-26T09:07:02.000Z","comments":true,"path":"2020/01/14/JavaScript高级/","link":"","permalink":"http://kisskisso.com/2020/01/14/JavaScript%E9%AB%98%E7%BA%A7/","excerpt":"JavaScript高级（基础） 注：浏览器展示的小问题： 复杂类型在控制台输出是，进行展看操作后，会读取的最新值 浏览器重要组成部分： 内核（渲染引擎）： html /css—webAPI(DOM/BOM) W3C规范 js解析器（Javascript引擎）： ECMScript","text":"JavaScript高级（基础） 注：浏览器展示的小问题： 复杂类型在控制台输出是，进行展看操作后，会读取的最新值 浏览器重要组成部分： 内核（渲染引擎）： html /css—webAPI(DOM/BOM) W3C规范 js解析器（Javascript引擎）： ECMScript ECMA规范 执行过程： 域解析：全局、函数 基本类型： 字符串类型 数值类型 布尔类型 未定义类型——–undefined默认的，用来表示存储区域未使用 空类型 null———主动设置，清除存储区域 复杂类型： objrct对象 array数组 date日期 functiion函数———代码重复使用【存储代码】 循环—-某个地方执行 math数学 基本和复杂区别： 存储个数不同 内存存储方式不同 ​ ●基本—内存单元中存储是具体值 ​ ●复杂—内存单元中存储的地址 复制方式不同： ​ ●基本——赋值=方式复制 ​ ●复杂——-遍历拷贝（内置对象方法） 复杂类型进行比较：（== /===） 都是地址比较 注：两个复杂类型长得一样不一定相等/全等 包装对象：string number boolean 狭义（单个）： 【任意对象都可以】 构造函数（需要复用）： 对象字面量： 数据存储 面向对象与面向过程 面向对象【分装功能使用方法调用】 注：面向对象和面向过程没有可比性 封装性: ●将面向过程的代码根据大功能划分后，封装多个函数，再将多个函数封装到对象中即可。 ●将功能封装为对象。 继承性： ●继承操作，进行功能复用 多态性： 某个功能被不同对象使用是的功能性不同，称多态【增强功能的灵活】 面向对象操作： class（重点） ———es6 【】 首字母大写 class 类名 ｛ constructor（需要参数）｛ this.属性名 = 属性值； ｝ 方法名（）｛ ｝ ｝ var 实名类 = new 类（） 注：如果设置的子类方法与父类方法同名，会 class 子类 extends person｛ constructor（）｛ super（） this. ｝ 方法（）； ｝ var 变量 = new 。。。（）； class继承 class Person { constructor() { this. = ; this. = ; } 名字() { console.log('' + this.)； } } class xxx extends Person{ constructor( xxx) { super(xxx); this.xxx = xxx; this.xxx = xxx; } 覆盖方法： super.名字（）；【1.多态方法做扩展2.调】 构造函数：——-函数名大写 多个实例对象设置的方法值不是同一个函数，将匿名函数设置为命名函数 统一对象的存储方式，可以减少在全局作用域名称数量 原型： prototype原型对象———-函数优化 constructor除了可以检测自定义实例对象的类型检测，也可以内置对象进行类型检测。【作用：类型确定功能】 typeof检测复杂类型只能得到object。。。。。。。。使用。。。。。。即可 零落满玉尘，霜打清浮册，墨染成瀑，清飞寒酥雪。忽沥薄阳起白风，展书一卷，读不尽满目苍凉 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://kisskisso.com/tags/js/"}]},{"title":"前言","slug":"前言","date":"2020-01-13T14:13:15.000Z","updated":"2021-01-26T10:19:24.000Z","comments":true,"path":"2020/01/13/前言/","link":"","permalink":"http://kisskisso.com/2020/01/13/%E5%89%8D%E8%A8%80/","excerpt":"","text":"​ 巴纳姆效应，巴纳姆效应是1948年由心理学家伯特伦·富勒通过试验证明的一种心理学现象，以杂技师巴纳姆的名字命名，认为每个人都会很容易相信一个笼统的、一般性的人格描述特别适合他。即使这种描述十分空洞，仍然认为反映了自己的人格面貌，哪怕自己根本不是这种人。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"爱好心理学","slug":"爱好心理学","permalink":"http://kisskisso.com/categories/%E7%88%B1%E5%A5%BD%E5%BF%83%E7%90%86%E5%AD%A6/"}],"tags":[{"name":"心理学","slug":"心理学","permalink":"http://kisskisso.com/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"}]},{"title":"防御机制（一）","slug":"防御机制","date":"2020-01-13T13:42:02.000Z","updated":"2021-01-26T09:57:56.000Z","comments":true,"path":"2020/01/13/防御机制/","link":"","permalink":"http://kisskisso.com/2020/01/13/%E9%98%B2%E5%BE%A1%E6%9C%BA%E5%88%B6/","excerpt":"一切防御机制都是我们为逃避痛苦而向自己撒的谎 注：阅读前请花几分钟阅读一下前言 我们的内外一致性越高，对自我判断也就会越准确，越能抵消落差感，心理也就越成熟、越健康，提升自尊，增强自己面对这个世界的能力。真正的成长发生在一言一行之间，通常要在很长一段时间后才有质的飞跃，虽然在感受到威胁时勇往直前很重要，但也不要太过逼迫自己，或过高要求自己。再微小的自我觉知，再小的进步，都有其价值所在。","text":"一切防御机制都是我们为逃避痛苦而向自己撒的谎 注：阅读前请花几分钟阅读一下前言 我们的内外一致性越高，对自我判断也就会越准确，越能抵消落差感，心理也就越成熟、越健康，提升自尊，增强自己面对这个世界的能力。真正的成长发生在一言一行之间，通常要在很长一段时间后才有质的飞跃，虽然在感受到威胁时勇往直前很重要，但也不要太过逼迫自己，或过高要求自己。再微小的自我觉知，再小的进步，都有其价值所在。 缺少自知之明：那个不认识的自己 人类通常终其一生都会认为那个拥有意识体验的TA们就是真实的自己，事实上，我们依旧对重要的情感世界所知不多。讲话人出现的口误，其实泄露的是Ta自己潜意识里的真实意愿。“忘记”：事实上并不是那个人故意疏忽不去兑现说过的承诺，忘记这一行为本身泄露了Ta自始至终就不愿去做那件事。 当我们无法看清自己，而Ta人却看得清清楚楚时，这对多数人而言时一件非常不越快的体验。如果被朋友说中了，我们会坚持称自己的口误（有时候一时的口误也当真别无他意）为语言故障，没有任何意义。 疏忽和出错往往揭露了一些事实，也就就是我们未能意识到，甚至对自己都不愿坦诚的真相。 心理防御机制都是一些无形的应对方式，通过它们，我们得以将那些无法接受的想法与感受排除在外。但它会以微妙的方式扭曲我们对现实的看法，这也包括人际关系和内心的情感领域 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"爱好心理学","slug":"爱好心理学","permalink":"http://kisskisso.com/categories/%E7%88%B1%E5%A5%BD%E5%BF%83%E7%90%86%E5%AD%A6/"}],"tags":[{"name":"心理学","slug":"心理学","permalink":"http://kisskisso.com/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"}]},{"title":"循环结构","slug":"循环结构","date":"2020-01-13T10:18:12.000Z","updated":"2021-01-26T10:38:56.000Z","comments":true,"path":"2020/01/13/循环结构/","link":"","permalink":"http://kisskisso.com/2020/01/13/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/","excerpt":"","text":"循环语句 for-in循环———-知道循环几次用 while循环————构造不知道循环次数的循环结构 使用while循环 while循环能产生或转出bool值来表达控制循环，即True循环继续False循环结束。 range（）【函数】 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"语言与Linux","slug":"语言与Linux","permalink":"http://kisskisso.com/categories/%E8%AF%AD%E8%A8%80%E4%B8%8ELinux/"}],"tags":[{"name":"python","slug":"python","permalink":"http://kisskisso.com/tags/python/"}]},{"title":"分支结构","slug":"分支结构","date":"2020-01-12T14:15:23.000Z","updated":"2021-01-26T09:59:56.000Z","comments":true,"path":"2020/01/12/分支结构/","link":"","permalink":"http://kisskisso.com/2020/01/12/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/","excerpt":"分支结构 if语句的使用【构造分支结构的关键字】 ①if ②elif ③else 注：和c/c++、Java等语言不同，Python中没有花括号构造代码而是使用了缩进的方式来设置的层次结构【连续的代码如果保持了相同的缩进那么它们属于同 一个代码块，相当于是一个执行的整体】。 构造跟多的分支则：【if…elif…else】结构。 练习1：英制单位英寸与公制单位厘米互换。","text":"分支结构 if语句的使用【构造分支结构的关键字】 ①if ②elif ③else 注：和c/c++、Java等语言不同，Python中没有花括号构造代码而是使用了缩进的方式来设置的层次结构【连续的代码如果保持了相同的缩进那么它们属于同 一个代码块，相当于是一个执行的整体】。 构造跟多的分支则：【if…elif…else】结构。 练习1：英制单位英寸与公制单位厘米互换。 kid = float（input（'请输入长度：'）） kids = input（‘请输入单位：’） if kids ==‘in’ or kid ==‘英寸’： print（’%f英寸 =%f厘米‘ % （kid，kid*2.54）） else kids ==‘cm’ or kids ==‘厘米’： print（‘%f厘米=%f英寸’%（kid，kid/2.54）） else： print（‘请输入有效单位’） 练习2：百分制成绩转换为等级制成绩。 要求：如果输入的成绩在90分以上（含90分）输出A；80分-90分（不含90分）输出B；70分-80分（不含80分）输出C；60分-70分（不含70分）输出D；60分以下输出E。 kid = input（'请输入成绩。。。'）； if kid &gt;= 90: kids = 'A' elif kid &gt;= 80 and kid &lt; 90: kids='B' elif kid &gt;= 70 and kid &lt; 80: kids='C' elif kid &gt;= 60 and kid &lt; 70: kids='D' ekse: kids='E' print('对应等级是：'，kids) 练习3：输入三条边长，如果能构成三角形就计算周长和面积。 a = float(input('a=')) b = float(input('b=')) c = float(input('c')) if a+b&gt;c and a+c&gt;b and b+c&gt;a: print('周长：%.2f' % (a+b+c)) p =(a+b+c)/2 area =(p*(p-a)*(p-b)*(p-c))**0.5 //海伦公式 print('面积：%.2f' % (area)) else: print('不能构成三角形') document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"语言与Linux","slug":"语言与Linux","permalink":"http://kisskisso.com/categories/%E8%AF%AD%E8%A8%80%E4%B8%8ELinux/"}],"tags":[{"name":"python","slug":"python","permalink":"http://kisskisso.com/tags/python/"}]},{"title":"回顾 + BOM模型最后一部分","slug":"回顾","date":"2020-01-12T14:11:00.000Z","updated":"2021-01-26T10:06:18.000Z","comments":true,"path":"2020/01/12/回顾/","link":"","permalink":"http://kisskisso.com/2020/01/12/%E5%9B%9E%E9%A1%BE/","excerpt":"回顾 xx元素.style.left = - 200 * i + ‘px’ xx元素.style.left=’translateX( - ‘ + 24*i + ‘ % )’ 定时器设置全局变量以防反复创建 assign（url） localStorage.setlten对象 sessionStorage对象","text":"回顾 xx元素.style.left = - 200 * i + ‘px’ xx元素.style.left=’translateX( - ‘ + 24*i + ‘ % )’ 定时器设置全局变量以防反复创建 assign（url） localStorage.setlten对象 sessionStorage对象 history对象： 【了解：浏览器历史记录】 history.back:后退一步 .forward():前进一步 .go(n)：后退（n为负时）或前进（n为正时）n步 navigator对象： 【了解：浏览器的名字版本号。。。。。】 使用：navigator.userAgent：获取到浏览器的信息（字符串） ocalStorage对象 localStorage.setItem( ‘key名称’, ‘值’ )以给定的键（key）存储一个数据【只能存字符串】 localStorage.getItem( ‘key名称’ )获取指定键（key）对应的数据 localStorage.removeItem( ‘key名称’ )删除（key）对应的数据 client系列：（不属于html属性？div？） 除了：scrollTop 和scrollLeft——只读不可修改 xx元素.clientWidth: 盒子padding范围（含padding）的宽度 xx元素.clientHeight:盒子padding范围（含padding）的高度 xx元素.clientLeft: offset系列：（不可修改？） scroll系列： top（有用，定位用。滑块位置没有单位） 移动端 原生： touchstart： 触摸开始事件 touchmove： 触摸移动事件 touchend： 触摸结束事件 【不会用到】 移动端事件绑定推荐用addEventListener（）方式 ’使用第三方封装‘ 触摸点信息的途径或方式： 事件处理函数传入参数（event）event.触摸点[i]【是个伪数组】 三个触摸集合： e.touches:代表所有触摸点，是一个集合 e.targetTouches:代表当前绑定事件的某个元素（对象）上的所有触摸点，是一个集合。 e.changedTouches: 代表当前变换了的触摸点 总结： 关于移动端获取事件的信息的基本对象层级结构： event对象》》触摸点集合》》触摸点》》触摸点属性 封装tap事件 tap事件的特征是：x坐标和y坐标的差值，都足够小 左划事件: x y 差值，&lt; - 15; 右划事件：x y 差值 &gt; 15; 触摸开始 触摸接触 transitionend（过渡完成）事件： 过渡：表示过渡效果执行完成的那个时刻。 xx元素.children.length图片个数长度 swiper轮播插件： https://www.swiper.com.cn document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"回顾","slug":"回顾","permalink":"http://kisskisso.com/tags/%E5%9B%9E%E9%A1%BE/"}]},{"title":"语言元素","slug":"语言元素","date":"2020-01-12T07:35:41.000Z","updated":"2021-01-26T10:41:18.000Z","comments":true,"path":"2020/01/12/语言元素/","link":"","permalink":"http://kisskisso.com/2020/01/12/%E8%AF%AD%E8%A8%80%E5%85%83%E7%B4%A0/","excerpt":"语言元素 整数元素： 浮点类型： 字符串型： 布尔型： 复数型： int float str true /false 3+4j（不常用） 变量命名： 硬性规则： 1.字母数字和下划线构成（数字不能开头） 2.大小写的敏感 3.关键字","text":"语言元素 整数元素： 浮点类型： 字符串型： 布尔型： 复数型： int float str true /false 3+4j（不常用） 变量命名： 硬性规则： 1.字母数字和下划线构成（数字不能开头） 2.大小写的敏感 3.关键字 PEP 8要求： 1.用小字母拼写 命名书见名知意 变量的使用： 输出：type int():将一个数值或字符串转换成整数，可以制定进制 float():将一个字符串转换成浮点数。 str()：将指定的对象转换成字符串形式，可以指定编码 chr():将整数转换成该编码对应的字符串（一个字符）。 ord():将字符串（一个字符）转换成对应的编码（整数）。 输出的字符串是占位符语法 ①%d–整数 ② %f–浮点数 ③%%–表示百分比【注：字符串之后%的变量会替换掉占位符】 运算符象html中一样除了【is ，is not（身份运算符）】【in，not in（成员运算符）】 【not，or，and（逻辑运算符）】 练习1：华氏温度装换为摄氏温度 k = int(input('')); n = (k-32)/1.8 print('%d=%d',(k,n)) //缩进问题 练习2：输入圆的半径计算周长和面积 import math gh=flost(input('')); io=math.pi*gh; kl= math*gh*gh; print('周长：%.2f % io‘) print('面积：%.2f % kl') 练习3：输入年份判断是不是闰年。 year=int(input('')); yu=(year % 4 == 0 and year % 100 !=0) or( year % 400 == 0 ) print(yu); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"语言与Linux","slug":"语言与Linux","permalink":"http://kisskisso.com/categories/%E8%AF%AD%E8%A8%80%E4%B8%8ELinux/"}],"tags":[{"name":"python","slug":"python","permalink":"http://kisskisso.com/tags/python/"}]},{"title":"回顾知识点","slug":"核心点","date":"2020-01-11T13:15:26.000Z","updated":"2021-01-26T10:02:22.000Z","comments":true,"path":"2020/01/11/核心点/","link":"","permalink":"http://kisskisso.com/2020/01/11/%E6%A0%B8%E5%BF%83%E7%82%B9/","excerpt":"回顾 1.事件的三要素 2.BOM核心【window对象】 xx元素.onxx事件=function（）｛….｝ 增 删 查 改 xx元素.addEventListener(’xx事件‘，function（）｛｝) 1.可以多次绑定 2.可以设定冒泡或捕获【基本用不到】两种形式的事件。","text":"回顾 1.事件的三要素 2.BOM核心【window对象】 xx元素.onxx事件=function（）｛….｝ 增 删 查 改 xx元素.addEventListener(’xx事件‘，function（）｛｝) 1.可以多次绑定 2.可以设定冒泡或捕获【基本用不到】两种形式的事件。 this绑定【形式】元素的本身 event是一个对象，存储了事件发生的那个时候的有些信息（属性） e.target e.type keyCode【按键代码】 e.clientX/Y e.pageX/Y e.preventDefault() a 表单 e.stopPropagation() 阻止冒泡？ 事件的委托： 作用： 1.简化绑定行为，节省内存消耗 2.可以对页面初始不存在的元素去设定事件绑定 遗留的问题： 1.排他思想 2、window.alert() .confirm() .prompt()? 3.如何解决定时器会反复创建的问题？ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"知识点","slug":"知识点","permalink":"http://kisskisso.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"梦","slug":"梦","date":"2020-01-11T12:41:22.000Z","updated":"2021-01-26T10:15:58.000Z","comments":true,"path":"2020/01/11/梦/","link":"","permalink":"http://kisskisso.com/2020/01/11/%E6%A2%A6/","excerpt":"梦 ​ 做梦就是在保护我们的生活模式不被现实和常识的要求所威胁。也就是说，如果一个人在现实生活中不想用公知的常理去解决某个问题，那么他就会在梦中表现出来，引起某个让他坚持自己想法的感觉。梦主要是由隐喻和象征构成的。梦的目的在于自欺欺人，让我们自己陶醉其中。一般人在梦中的目标和白天的目标是一致的，就像人在梦中也在努力追求白天追求的优越感一样，梦是我们生命意义的另一种表达方式，同时也有利于我们生命意义的塑造和达成。","text":"梦 ​ 做梦就是在保护我们的生活模式不被现实和常识的要求所威胁。也就是说，如果一个人在现实生活中不想用公知的常理去解决某个问题，那么他就会在梦中表现出来，引起某个让他坚持自己想法的感觉。梦主要是由隐喻和象征构成的。梦的目的在于自欺欺人，让我们自己陶醉其中。一般人在梦中的目标和白天的目标是一致的，就像人在梦中也在努力追求白天追求的优越感一样，梦是我们生命意义的另一种表达方式，同时也有利于我们生命意义的塑造和达成。 ​ 每一个梦我们都是在自我陶醉、自我催眠。它的目的就是引起我们某种感觉，这中感觉能为我们清醒状态时候想要解决问题的方法提供支持。 隐喻是能让人充满想象的，但是必须注意：对于一个在生命意义方面已经偏差了的人来说，运用隐喻和符号来解决问题是一件很危险的事。对于梦的解释都是属于个人的，我们不可能用公式来解释符号和隐喻，因为梦是生活模式的产品。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"爱好心理学","slug":"爱好心理学","permalink":"http://kisskisso.com/categories/%E7%88%B1%E5%A5%BD%E5%BF%83%E7%90%86%E5%AD%A6/"}],"tags":[{"name":"心理学","slug":"心理学","permalink":"http://kisskisso.com/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"}]},{"title":"如何有效阅读一本书（四）","slug":"如何有效阅读一本书（四）","date":"2020-01-10T07:24:27.000Z","updated":"2021-01-26T10:24:36.000Z","comments":true,"path":"2020/01/10/如何有效阅读一本书（四）/","link":"","permalink":"http://kisskisso.com/2020/01/10/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"如何有效阅读一本书（四） 利用书签边读边写 ☞三枚书签—————-①通读书签②重读书签③标记书签 ☞巧用标记区分对象 Eg：普通直线、波浪线、圆圈等。（注：笔记本上尽量少画线，避免重读的时候影响心情）ps：好像有点前后矛盾╮（╯＿╰）╭ ps：需要分清一开始写与后来补充的 三项信息 = 写读书笔记的日期 + 书名 + 作者名 【ps：想起读什么书、理解成度】 ↑（摘抄 + 评论） 引：“摘抄对自己来说很重要的文章” “写主观评论” 摘抄：①促进、加深对书的记忆②加深理解【注：二次理解】","text":"如何有效阅读一本书（四） 利用书签边读边写 ☞三枚书签—————-①通读书签②重读书签③标记书签 ☞巧用标记区分对象 Eg：普通直线、波浪线、圆圈等。（注：笔记本上尽量少画线，避免重读的时候影响心情）ps：好像有点前后矛盾╮（╯＿╰）╭ ps：需要分清一开始写与后来补充的 三项信息 = 写读书笔记的日期 + 书名 + 作者名 【ps：想起读什么书、理解成度】 ↑（摘抄 + 评论） 引：“摘抄对自己来说很重要的文章” “写主观评论” 摘抄：①促进、加深对书的记忆②加深理解【注：二次理解】 R：抄写是要尽量减少视点的移动，避免在视线转移的过程中逐渐忘记自己要写的内容。人话：减少分神时间 读过一本书以后，对书中内容感同身受固然让人心情愉悦，但这也代表这次读书没有给你带来新的东西。相反，如果一篇文章颠覆了你之前的想法，使你的认识发生动摇，在抄写和重读的过程中仍然会让人信服或感觉震撼，这中文章才是值得摘抄的。 ☞最能代表这次读书体验的语句———中心句【ps：如何有效阅读一本书 :-D】 杂：自己当下的想法最重要。 ps：读书时获得的感想正是原创思考的源泉。【深与浅】 ⊙葱鲔火锅式 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://kisskisso.com/tags/%E8%AF%BB%E4%B9%A6/"}]},{"title":"事件流","slug":"event方法","date":"2020-01-09T12:00:56.000Z","updated":"2021-01-26T08:57:42.000Z","comments":true,"path":"2020/01/09/event方法/","link":"","permalink":"http://kisskisso.com/2020/01/09/event%E6%96%B9%E6%B3%95/","excerpt":"事件流 a标签的链接 【】 form标签的提交 【】 return false——–其它做法 event事件: 属性:target,type,clientX/Y,pageX/Y,keyCode","text":"事件流 a标签的链接 【】 form标签的提交 【】 return false——–其它做法 event事件: 属性:target,type,clientX/Y,pageX/Y,keyCode 方法:preventDefault(),stopPropagation() 事件绑定方式: //只能绑定一次,而且只能是冒泡事件 元素.onxx事件 = function(){} //可以绑定多次,也可以绑定捕获或冒泡事件 元素.addEventListener(‘xx事件’,function(){}true/false)//true为捕获.false为冒泡 阻止事件默认行为: ​ e.preventDefault() 阻止事件传播: e.stopPropagation() 某个节点.modeType 1.代表元素 2.代表书序 节点属性: node.nodeType ​ name[元素节点的nodename也就是元素的标签名,而且必然是大写] Value/ 事件委托: event.target获取当前触发事件的对象 keyCode获取键盘码 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"事件","slug":"事件","permalink":"http://kisskisso.com/tags/%E4%BA%8B%E4%BB%B6/"}]},{"title":"BOM模型","slug":"BOM模型","date":"2020-01-09T12:00:56.000Z","updated":"2021-01-26T08:48:38.000Z","comments":true,"path":"2020/01/09/BOM模型/","link":"","permalink":"http://kisskisso.com/2020/01/09/BOM%E6%A8%A1%E5%9E%8B/","excerpt":"BOM模型 全局变量 全局函数 var v1 = 10是全局变量,则v1 === window.v1为真 function fn1 = function(){...}是全局函数,则fn1 === window.fn1为真 注:可以不使用window.前缀","text":"BOM模型 全局变量 全局函数 var v1 = 10是全局变量,则v1 === window.v1为真 function fn1 = function(){...}是全局函数,则fn1 === window.fn1为真 注:可以不使用window.前缀 直接使用要删除这个元素的关系来删除该元素 toDeleteObj.parentNode.removeChild(); 使用一次性定时器 创建一次性定时器: var 名字=window.setTimeout(要调用的函数,等待的时间) 等待时间单位是毫秒 该时间后执行一次 清除一次性定时器: window.clearTimeout(名字) 使用重复性定时器 var 名字 = window.setlnterval(要调用的函数,间隔的时间); 每间隔该时间,都会执行一次所指定的函数 window.clearlnterval(名字) property 属性 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"BOM模型","slug":"BOM模型","permalink":"http://kisskisso.com/tags/BOM%E6%A8%A1%E5%9E%8B/"}]},{"title":"事件处理","slug":"事件处理","date":"2020-01-08T10:57:45.000Z","updated":"2021-01-26T10:28:10.000Z","comments":true,"path":"2020/01/08/事件处理/","link":"","permalink":"http://kisskisso.com/2020/01/08/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/","excerpt":"事件处理 事件源：事件类型：事件处理函数： 事件三要素其实就是设定某个元素上发生了某个时间后要做什么事 事件绑定（事件注册） 常用事件概览（on） 鼠标事件： click，dblclick mouseover：鼠标进入某个盒子范围的那个时刻 mouseout：离开 mousemove：鼠标移动事件，通常是一个持续时间。","text":"事件处理 事件源：事件类型：事件处理函数： 事件三要素其实就是设定某个元素上发生了某个时间后要做什么事 事件绑定（事件注册） 常用事件概览（on） 鼠标事件： click，dblclick mouseover：鼠标进入某个盒子范围的那个时刻 mouseout：离开 mousemove：鼠标移动事件，通常是一个持续时间。 mouseenter：(盒子范围)跟over几乎一样，但是更好用 mouseleave： （离开盒子范围）out一样， 键盘事件： keydown：按钮按下去的时刻发生 keyup：抬起 keypress：按键一次 表单事件： submit：表单提交事件 change：表单项的数据被改变的时刻（光标离开后） input：输入时刻 focus：获得焦点。。。 blur：失去焦点。。。（空字符串） 其它事件： load：加载成功事件（网页加载） 事件绑定 标签属性绑定———过时，不推荐 语法：&lt;div on事件=”xx函数();”&gt;…&lt;/div.&gt;（调用函数） 移除方式: ●xx元素.onxx事件=null ●直接在html中删除该事件绑定代码(ps:不过这就不是js的工作) 对象属性绑定———简洁、常用，满足绝大数使用 ☞xx元素.onxx事件 = 函数名； //函数名后不带括号 移除方式: ●xx元素.onxx事件=null ☞xx元素.onxx事件=function(){…}; //这里是匿名函数 （注：等号后面是一个函数名，;不是调用函数） 对象方法绑定———更好的可控性 语法：xx元素.addEventListener(‘xx事件’,xx事件处理函数); 第2个参数是事件处理函数,可以是匿名函数,也可以是一个函数名 对应删除: ●xx元素.removeEventListenter(‘xx事件’,xx事件处理函数); ●==特别注意:绑定后如果=需要再移除,则使用同样的函数名,且第1参数也要求一样== 函数中的this 提示：在对象属性绑定和通过对象方法绑定的事件处理函数中，都可以直接使用this关键词。但通过元素标签属性的形式绑定的事件处理函数中不可以直接使用。 排他思想（特例）： 排他思想的基本代码模式： 1， 设定若干同类元素相同表现 2， 设定当前某个特殊元素的特殊表现（通常都会需要用到 this ) /*先设定所有一致（所有都同样）*/ /*给当前设置特殊*/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"API","slug":"API","permalink":"http://kisskisso.com/tags/API/"}]},{"title":"伸缩布局","slug":"伸缩布局","date":"2020-01-08T10:02:45.000Z","updated":"2021-01-26T10:27:34.000Z","comments":true,"path":"2020/01/08/伸缩布局/","link":"","permalink":"http://kisskisso.com/2020/01/08/%E4%BC%B8%E7%BC%A9%E5%B8%83%E5%B1%80/","excerpt":"伸缩布局 什么时候使用伸缩布局: 1.如果在在网页中希望让元素一行显示,并且元素随着父元素的宽度改变布局方式不会受影响 2.使用了伸缩布局以后,还可以使用浮动,定位,margin,padding 3.伸缩布局只是一个新的布局方式,不要把伸缩布局看的太重或者太难 核心知识点 1.伸缩盒子设置 2.设置伸缩盒子主轴","text":"伸缩布局 什么时候使用伸缩布局: 1.如果在在网页中希望让元素一行显示,并且元素随着父元素的宽度改变布局方式不会受影响 2.使用了伸缩布局以后,还可以使用浮动,定位,margin,padding 3.伸缩布局只是一个新的布局方式,不要把伸缩布局看的太重或者太难 核心知识点 1.伸缩盒子设置 2.设置伸缩盒子主轴 3.设置伸缩盒子主轴对齐方式 4.设置伸缩盒子侧轴对齐方式 5.设置伸缩盒子伸缩比例 6.less基本语法及使用 伸缩布局两个步骤: ​ ●给父元素设置的属性 display:flex; /*设置为伸缩盒子(弹性盒子)*/ 注:一定给父级!!!一定给父级!!!一定给父级!!! justify-content/*设置元素在主轴对齐*/ justify-content:flex- start; /*默认*/ justify-content:flex-end; /*结束*/ justify-concent:center; /*居中*/ justify-content:space-between;/* 两端对齐中间自适应 */ justify-content: space-around; /* 环绕 */ flex-direction: /*设置主轴的方向*/ row(默认,水平) | column(竖显示) | row-reverse(横-右到左) | column-reverse(纵-右到左) align-items; /*设置元素相对侧轴对齐方式*/ stretch(默认,拉伸效果) | flex-start(起点对齐) | flex-end(终点对齐) | center(中心) | baseline(第一行文字的基线对齐) flex-wrap:/*设置伸缩盒子中元素是否换行显示*/ nowrap 默认不换行 | wrap 换行 align-content:/*当元素换行后的一种对齐方式*/ stretch(默认) 注:如果要设置align-content必须要保证元素是换行的 ​ 注: flex-flow复合属性 ===flex- direction和flex- wrap ●给子元素设置的属性 flex:/*设置元素占父元素剩余宽度的一个比例*/'也就是1份' 注: 1.flex 属性是给子元素设置的 2.剩余宽度:如果父元素中固定宽度的盒子,那么flex所占的比例是父元素整个的宽度-固定宽度后的比例 ​ ● 伸缩盒子中-子元素排序 order:值; /*设置元素排序*/ 特点: 1.值越大元素越靠后显示 2.在排序时候,完全不用修改html结构 伸缩盒子的特点: ​ 1.伸缩盒子中的所有元素都是一行显示的 ​ 2.解释为什么伸缩盒子中的元素默认会一行显示? ​ ✖在伸缩盒子中元素都是按照主轴显示的 ​ ✖在伸缩盒子中有一条主轴,主轴的默认水平显示 ​ 3.在伸缩盒子中还有一条轴,叫侧轴.(侧轴始终要垂直于主轴,侧轴的方向是随着儿主轴的方向发生改变的) ​ 4.在伸缩盒子中,如果子元素的宽度超出父元素的宽度,那么元素也不会换行 注: 在伸缩盒子中元素一行显示,与脱标没有任何关系 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"伸缩","slug":"伸缩","permalink":"http://kisskisso.com/tags/%E4%BC%B8%E7%BC%A9/"}]},{"title":"如何有效阅读一本书（三）","slug":"如何有效阅读一本书(三)","date":"2020-01-08T09:51:45.000Z","updated":"2021-01-26T10:24:18.000Z","comments":true,"path":"2020/01/08/如何有效阅读一本书(三)/","link":"","permalink":"http://kisskisso.com/2020/01/08/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6(%E4%B8%89)/","excerpt":"如何有效的阅读一本书(三) 1.从一句话开始 ps：凡事一句话搞定？ (^ ^)v 2.对自己很重要的事情 ps：有很多先做哪一个 :D 读书的目的是用自己的方式学习，而不是模仿评论家的做法，学习、吸收对自己真正有用的智慧和语句才是最重要的。 杂：如果别人的学习方式比你的要好，是否还要坚持自己的学习方式？一味的模仿固然不对，但要怎么’避免‘【模仿与学习】？ —————————— 注：学会变通 “这不是语文考试，没必要去拼命思考笔者（作者）想要传达什么。只要关注相关注的内容就好了”**———————-注：一般来说只要思想不滑坡，就不会想偏。**","text":"如何有效的阅读一本书(三) 1.从一句话开始 ps：凡事一句话搞定？ (^ ^)v 2.对自己很重要的事情 ps：有很多先做哪一个 :D 读书的目的是用自己的方式学习，而不是模仿评论家的做法，学习、吸收对自己真正有用的智慧和语句才是最重要的。 杂：如果别人的学习方式比你的要好，是否还要坚持自己的学习方式？一味的模仿固然不对，但要怎么’避免‘【模仿与学习】？ —————————— 注：学会变通 “这不是语文考试，没必要去拼命思考笔者（作者）想要传达什么。只要关注相关注的内容就好了”**———————-注：一般来说只要思想不滑坡，就不会想偏。** 【杂：只留下应有的想法即可】 千万不要为了坚持写读书笔记而走形式主义，不管采用什么方式，都要脚踏实地地写读书笔记，并真正理解书的内容。 ps：经历吗？对于不长出门的人来说，有些困难 巩固印象的**笔记** ——–加深记忆 注：反复理解内容与修改想法 R：读书是一项“对重要内容进行提炼的工序” ps：大脑会反复加工这一重要的内容 筛选程序： ① 通过一边阅读一边把觉得有价值的呢一也折角 ② 重读（ps：反复阅读） ③ 标记…… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"我的读书笔记","slug":"我的读书笔记","permalink":"http://kisskisso.com/tags/%E6%88%91%E7%9A%84%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"练习案例","slug":"练习案例","date":"2020-01-07T12:25:54.000Z","updated":"2021-01-26T10:13:28.000Z","comments":true,"path":"2020/01/07/练习案例/","link":"","permalink":"http://kisskisso.com/2020/01/07/%E7%BB%83%E4%B9%A0%E6%A1%88%E4%BE%8B/","excerpt":"节点关系获取元素 ==演示==： 使用元素的一些关系属性获取元素。 准备的素材：一个有id的无序列表。通过children找出第2个li，然后据此演示使用其他一些关系以获取元素。","text":"节点关系获取元素 ==演示==： 使用元素的一些关系属性获取元素。 准备的素材：一个有id的无序列表。通过children找出第2个li，然后据此演示使用其他一些关系以获取元素。 &lt;ul id=\"list\"&gt; &lt;li&gt;项目1&lt;/li&gt; &lt;li&gt;项目2&lt;/li&gt; &lt;li&gt;项目3&lt;/li&gt; &lt;li&gt;项目4&lt;/li&gt; &lt;li&gt;项目5&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var ul = document.getElementByid('list'); var li = document.getElementsByTagName('li'); var iu = li[0].parentNode; var op = ul.children; var ki = ul.firstElementChild; var hi = ul.lastElementChild; console.log(iu); console.log(op); console.log(ki); console.log(hi); &lt;/script&gt; 根据特征信息获取元素 ==演示==： ​ 使用get系列方法和query系列方法获取元素。 ​ 准备的素材：一个设定了id和class的div。 &lt;div id=\"box1\" class=\"msg\"&gt;sha&lt;/div&gt; &lt;script&gt; var box1 = document.getElementById('box1'); var msg = document.getElementsByClassName('.msg'); console.log('msg') &lt;/script&gt; 开关灯案例 ==案例3（介绍开关思想）==： 网页上有一按钮，点击按钮，使整个页面能够在“关灯/开灯”之间切换。 所谓关灯/开灯，就是让网页的整体背景为黑色和白色。 &lt;input type=\"button\" value=\"开关\" id=\"op\"&gt; &lt;script&gt; var body = document.body; var yi = true; var op = document.querySelector('#op'); op.onclick = function () { if (yi == true) { body.style.backgroundColor = 'black'; op.value = '关灯'; yi = false; } else { body.style.backgroundColor = 'white'; op.value = '开灯'; yi = true; } } &lt;/script&gt; 添加元素案例（一） &lt;button id=\"ll\"&gt;点一下&lt;/button&gt; &lt;ul id=\"po\"&gt;&lt;/ul&gt; &lt;script&gt; var bon = document.querySelector('#ll'); var ul = document.querySelector('#po'); // var bon = document.getElementsByTagName('button'); // var ul = document.getElementsByTagName('ul');这个不显示 bon.onclick = function () { var ki = document.createElement('li'); ul.appendChild(ki); } &lt;/script&gt; 添加元素案例（二） 在一个无序列表中实现如下需求： 1，点击按钮1，创建一个div放入第一个li中， 2，点击按钮2，克隆第一个li，并放到该列表的倒数第2个的位置（即最后一个的前面），, 3，点击按钮3，将最后一个li替换为一个新创建的li。 &lt;body&gt; &lt;button id=\"btn1\"&gt;添加一个div到第1个li&lt;/button&gt; &lt;button id=\"btn2\"&gt;克隆第1个li并放入倒数第2个位置&lt;/button&gt; &lt;button id=\"btn3\"&gt;替换最后1个li&lt;/button&gt; &lt;button id=\"btn4\"&gt;删除最后一个li&lt;/button&gt; &lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; &lt;li&gt;列表项4&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var btn1 = document.querySelector('#btn1'); var ul = document.querySelector('ul'); btn1.onclick = function () { var div = document.createElement('div'); var fist = ul.children[0]; fist.appendChild(div); } var btn2 = document.querySelector('#btn2'); btn2.onclick = function () { var li = ul.children[0].cloneNode(true); var kj = ul.lastElementChild; ul.insertBefore(li, kj) } var btn3 = document.querySelector('#btn3'); btn3.onclick = function () { var li = document.createElement('li') var kl = ul.lastElementChild; ul.replaceChild(li, kl) } var btn4 = document.querySelector('#btn4') btn4.onclick = function () { // var yi =ul.children[3]; var li = ul.lastElementChild; ul.removeChild(li); } &lt;/script&gt; 修改原生的HTML属性案例（一） ==案例1==： 页面上有两个按钮，一张图片。每点击一次按钮1，使图片变大20像素，每点击一次按钮2，使图片变小20像素。 &lt;button id=\"btn1\"&gt;放大&lt;/button&gt; &lt;button id=\"btn2\"&gt;缩小&lt;/button&gt; &lt;br&gt; &lt;img src=\"gl.jpg\" alt=\"\" width=\"100\"&gt; &lt;script&gt; var btn1 = document.querySelector('#btn1'); var img = document.querySelector('img'); var fn = img.width; btn1.onclick = function () { fn += 20; img.width = fn; } var btn2 = document.querySelector('#btn2'); btn2.onclick = function () { fn -= 20; img.width = fn; } &lt;/script&gt; 修改原生的HTML属性案例（二） ==案例2==： 购买数量的增减操作 &lt;body&gt; &lt;style&gt; div { width: 80px; } input[type=\"text\"] { width: 50px; height: 44px; outline: none; border: 1px solid #ccc; text-align: center; } input[type=\"button\"] { height: 24px; width: 22px; } input { float: left; } &lt;/style&gt; &lt;div&gt; &lt;input type=\"text\" id=\"total\" value=\"1\" readonly&gt; &lt;input type=\"button\" value=\"+\" id=\"add\"&gt; &lt;input type=\"button\" value=\"-\" id=\"reduce\" disabled&gt; &lt;/div&gt; &lt;script&gt; var ddf = document.querySelector('#total'); var add = document.querySelector('#add'); var naa = document.querySelector('#reduce'); add.onclick = function () { var ui = ddf.value; ui++; ddf.value = ui; naa.disabled = false; } naa.onclick = function () { var ul = ddf.value; ul--; if (ul &lt;= 0) { ul = 1; naa.disabled = true; } ddf.value = ul; } &lt;/script&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"练习","slug":"练习","permalink":"http://kisskisso.com/tags/%E7%BB%83%E4%B9%A0/"}]},{"title":"知识点（二）","slug":"知识点2","date":"2020-01-06T14:35:45.000Z","updated":"2021-01-26T10:44:52.000Z","comments":true,"path":"2020/01/06/知识点2/","link":"","permalink":"http://kisskisso.com/2020/01/06/%E7%9F%A5%E8%AF%86%E7%82%B92/","excerpt":"","text":"知识点 ​ 1.display:none *与visitibility:hidden 前者不保留位置,后者保留位置 ​ 2.额外标签法 overflow 伪元素法 ​ 3.css3盒子模型border-box中,盒子的width包含了conter+border+padding(实际宽高) ​ 4.vertical-align:middle vertical-align:top vertical-align:bottom css三种引入方式:行内式,内嵌式外联时 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"知识点（二）","slug":"知识点（二）","permalink":"http://kisskisso.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%EF%BC%89/"}]},{"title":"如何有效阅读一本书（二）","slug":"如何有效阅读一本书(二)","date":"2020-01-06T14:23:45.000Z","updated":"2021-01-26T10:23:50.000Z","comments":true,"path":"2020/01/06/如何有效阅读一本书(二)/","link":"","permalink":"http://kisskisso.com/2020/01/06/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6(%E4%BA%8C)/","excerpt":"如何阅读一本有效的书(二) 1.熟读书评 ps：书评两级分化严重该怎么解决？ 2.坚持做笔记 ps:大多数时间，都在走神与胡思乱想 :） 作用: 图书都是有重点的,没有必要从头到尾详读.重要的是不管篇幅多少,都要下点功夫让自己对读过的书有印象.即使只记下这本书的作者、书名,阅读时的情景或是做些摘抄都好,要坚持写读书笔记,这是最有效的读书方法. ps:不管怎么说还是坚持、用心好点或正确的对待写读书笔记这件事. R:读书笔记改变读书方法可以理解为不要漫无目的的读书.","text":"如何阅读一本有效的书(二) 1.熟读书评 ps：书评两级分化严重该怎么解决？ 2.坚持做笔记 ps:大多数时间，都在走神与胡思乱想 :） 作用: 图书都是有重点的,没有必要从头到尾详读.重要的是不管篇幅多少,都要下点功夫让自己对读过的书有印象.即使只记下这本书的作者、书名,阅读时的情景或是做些摘抄都好,要坚持写读书笔记,这是最有效的读书方法. ps:不管怎么说还是坚持、用心好点或正确的对待写读书笔记这件事. R:读书笔记改变读书方法可以理解为不要漫无目的的读书. 引:”为了写出精炼而深刻的读书笔记,你应该在读完一本书以后认真回想需要摘抄那一页哪一行,思考怎样撰写读书笔记,然后严格的筛选需要摘抄的内容,尽量提炼自己的感想,争取用最短的语句表达深刻的含义” (注:以思想输出为前提) ps:想法很重要,有什么一闪而过想法最好写下来.避免被忘掉,从而错过有趣(重要)的想法. 杂:对于书中所说’速度’与’跳读’,我到是并不建议’跳读’ 一是会错过有趣的故事、人物关系 二是会记忆混乱，看的一头雾水. K:要注意读书的重心,要放在你读书为了什么或者为什么要读书.而不是单单是读过就好或者为了应付什么 杂:还是有必要说一下不要钻牛角尖,不要死读书,把握好时间与节奏. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"我的读书笔记","slug":"我的读书笔记","permalink":"http://kisskisso.com/tags/%E6%88%91%E7%9A%84%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"HTML基础（一）","slug":"HTML基础第一天","date":"2020-01-06T10:59:45.000Z","updated":"2021-01-26T09:03:10.000Z","comments":true,"path":"2020/01/06/HTML基础第一天/","link":"","permalink":"http://kisskisso.com/2020/01/06/HTML%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E5%A4%A9/","excerpt":"第一天 1.ctrl+s 保存 Lorem 乱数假文 2.英文下的 ！+Tab 注：（vs code） 3.字符集—–避免乱码(utf- 8) 注:不区分大小写 4.语言的种类—–避免编译器乱码 eg: en 、zh-CN 5.关于h1 网页只有一个标题","text":"第一天 1.ctrl+s 保存 Lorem 乱数假文 2.英文下的 ！+Tab 注：（vs code） 3.字符集—–避免乱码(utf- 8) 注:不区分大小写 4.语言的种类—–避免编译器乱码 eg: en 、zh-CN 5.关于h1 网页只有一个标题 小图标图片 —— b i u s 段落与文字 ——- strong 加粗 em 倾斜 ins 下划线 del 删除线 文本格式化 ( 注:vs code 需要下载汉化插件与Open In Default Browser) 相对路径: ./同一级 /下一级 ../上一级 绝对路径: 盘符与网页图片 a href:**链接可以下载文件 放入链接 图片等等 **[注:下载需要打包(压缩文件)] 加入空链接 # 锚点定位 ——-#”类id” eg:”#ygsts” 注释快捷键 ctrl + / document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML(一)","slug":"HTML-一","permalink":"http://kisskisso.com/tags/HTML-%E4%B8%80/"}]},{"title":"移动回顾","slug":"移动回顾","date":"2020-01-06T10:15:45.000Z","updated":"2021-01-26T10:39:52.000Z","comments":true,"path":"2020/01/06/移动回顾/","link":"","permalink":"http://kisskisso.com/2020/01/06/%E7%A7%BB%E5%8A%A8%E5%9B%9E%E9%A1%BE/","excerpt":"移动回顾 1.流式布局 2.伸缩布局———–[修改主轴的方向,设置元素在主轴方向的对齐,元素在侧轴的对齐方式] 3.响应式布局———–[解决了同一个网页在不同设备中布局显示效果不同] 核心知识点———-媒体查询 页面适配 rem适配 ——-相对html中的文字大小","text":"移动回顾 1.流式布局 2.伸缩布局———–[修改主轴的方向,设置元素在主轴方向的对齐,元素在侧轴的对齐方式] 3.响应式布局———–[解决了同一个网页在不同设备中布局显示效果不同] 核心知识点———-媒体查询 页面适配 rem适配 ——-相对html中的文字大小 1.要设置html中文字的大小 = 设备的宽度/缩放的倍数 2.测量元素转化为 rem = 当前元素测量的大小rem / (UI图宽度/缩放的倍数) 备注: 640px UI图一般 缩放 20倍 750px UI 图一般缩放 25倍 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://kisskisso.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}]},{"title":"流式布局","slug":"流式布局笔记","date":"2020-01-06T10:15:45.000Z","updated":"2021-01-26T10:14:06.000Z","comments":true,"path":"2020/01/06/流式布局笔记/","link":"","permalink":"http://kisskisso.com/2020/01/06/%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80%E7%AC%94%E8%AE%B0/","excerpt":"流式布局 1.ppi 像素密度(越高画质越好,相反)—–没用[设备像素] 2.dpr物理像素比(具体不能改变的比例关系–作用–适配) [硬件] 视口(viewport) 1.禁止——水平滚动—页面缩放 2.视口—–pc[浏览器的大小]—-移动[移动设备的大小] 视口的设置 &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; 移动设备宽 ←↑ ↑→ 忘了 注: 左右固定—中自适应 **注:**精灵图—-向上向左","text":"流式布局 1.ppi 像素密度(越高画质越好,相反)—–没用[设备像素] 2.dpr物理像素比(具体不能改变的比例关系–作用–适配) [硬件] 视口(viewport) 1.禁止——水平滚动—页面缩放 2.视口—–pc[浏览器的大小]—-移动[移动设备的大小] 视口的设置 &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; 移动设备宽 ←↑ ↑→ 忘了 注: 左右固定—中自适应 **注:**精灵图—-向上向左 **注:**转元素转块元素、行内元素 ​ ♦行内块元素是一个非标准的元素 ​ ♦ 行内块元素默认都会找基线对齐—(底部多3像素空白) ​ ♦’’图片是行内块元素转化为块元素 (加浮动=转化块=)—-[清除浮动]’ ‘ ∮ 盒子之间用padding值撑开,切记不要用margin值 多行文字显示省略号 /* 实现多行文字溢出显示省略号 */ overflow: hidden; /* 文字溢出显示省略号：单行文字 */ text-overflow: ellipsis; /* 辅助属性：兼容性 */ -webkit-line-clamp: 2; /* 文字就要垂直显示 */ -webkit-box-orient: vertical; /* 还需要设置一个弹性盒子 */ display: -webkit-box; 防止汉字自动换行(默认) /*解决让文字不在特殊符号(空格,特殊符号)位置处换行*/ word-break:break-all; ​ 网页的步骤 页面样式初始化 任何的一个项目都要单独的在一个文件夹中 任何文件的命名都不能出现汉字 html的步骤 1.一般情况下,在网页中先设置一个大盒子 ​ ▶如果是一个最外层的大盒子,设置宽度100%( 重要) ​ ▶如果盒子的高度可以直接测量出来,可以设置高度,反之让内容撑开 2.在最外层大盒子中划分其它盒子 ​ ▶搜索盒子(宽度与设备一宽,要设置高度,设置背景颜色,固定定位盒子,以及内[三个盒子]) ​ ▶搜索盒子中要实现 [两端固定大小,中间[设置padding值]自适应效果] {为了防止padding撑大盒子设置! !初始化(最好用一个写一个,以防..以防..[ps：想不起来用什么词了…])’} 注: [初始化] /*实际开发不写*/ *{ padding:0; margin:0; } /*真确写法*/ body,p,h1,h2,h3,h4,h5,h6,ul,ol,dl,dd{ margin:0; padding:0; list-style:none; font-size:14px; font-familt:'宋体'; } a{ /*清除下划线*/ text-decoration:none; } img,input{ vertical-align:middle; /*去掉边框*/ border:0; /*轮廓线*/ outline:none; padding:0; } /*清除浮动*/ .clearfix::after{ content:\"\"; display:block; height:0; visibility:hidden; clear:both; } .clearfix{ *zoom:1; } 例外 问题: ♣背景图片:当页面中的标签某个图标效果,或者图片只是一个衬托效果(给高宽) ♣img图片:图片角色很重要[广告,商品] 重要: 选择器层级不要太高,类选择器不要超过3个[权限会很高] 扩展知识点: ♠定位 ——♪当一个元素加了定位有层级关系(后来居上原则)[z-index:*;] ​ ♪定位脱标元素盒子居中 transform:translate(-50%);[后期会讲,先记住] ♠盒子模型 —— ♪max-width---最大宽度 ♪min-width-----最小宽度 ♠其它内部属性 div{ position:absolute; left:0; top:0; width:**px; height:**px; font-size:**px; /*字的大小颜色(背景)对齐方式*/ text-align:****; } 底部的固定定位:需要加padding-bottom撑开 名:没有固定的宽或高 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"视口","slug":"视口","permalink":"http://kisskisso.com/tags/%E8%A7%86%E5%8F%A3/"}]},{"title":"响应式布局","slug":"响应式布局","date":"2020-01-06T10:15:45.000Z","updated":"2021-01-26T10:34:20.000Z","comments":true,"path":"2020/01/06/响应式布局/","link":"","permalink":"http://kisskisso.com/2020/01/06/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/","excerpt":"响应式布局写对位置 1.(同一个网页在不同设备中[布局]呈现的效果) 核心知识 ◎媒体查询 媒体查询 liagn-height 可以不用加px (一倍) @media only screen and (width:**/*不加分号*/) { /* 加空格*/ div { 宽 高 背景颜色 } } 1.媒体查询就是响应式布局实现的原理 2.总结:可以让css代码在满足某些条件的情况下才去执行","text":"响应式布局写对位置 1.(同一个网页在不同设备中[布局]呈现的效果) 核心知识 ◎媒体查询 媒体查询 liagn-height 可以不用加px (一倍) @media only screen and (width:**/*不加分号*/) { /* 加空格*/ div { 宽 高 背景颜色 } } 1.媒体查询就是响应式布局实现的原理 2.总结:可以让css代码在满足某些条件的情况下才去执行 ◎boostrap框架 ◎栅格系统 注:一旦涉及行内元素都需要转化为块元素 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"媒体查询","slug":"媒体查询","permalink":"http://kisskisso.com/tags/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/"}]},{"title":"修改元素内容和属性","slug":"容器元素","date":"2020-01-06T03:12:16.000Z","updated":"2021-01-26T10:21:08.000Z","comments":true,"path":"2020/01/06/容器元素/","link":"","permalink":"http://kisskisso.com/2020/01/06/%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0/","excerpt":"修改元素内容和属性 原生html属性操作： 取值：console.log（xx元素.src） 赋值：xx元素.alt = ‘abc’; js不带单位 自定义属性 设置一个属性的值 ​ xx元素.setAttribite(‘属性名’，’属性名’)","text":"修改元素内容和属性 原生html属性操作： 取值：console.log（xx元素.src） 赋值：xx元素.alt = ‘abc’; js不带单位 自定义属性 设置一个属性的值 ​ xx元素.setAttribite(‘属性名’，’属性名’) 获取给定属性的值 ​ xx元素.getAttribute(‘属性名’) 移除一个属性 ​ xx元素.removeAttribute(‘属性名’) html特殊属性 布尔值 1.checked属性 用于单选或多选 true（选中） false 2.selected属性 下拉框 3.disable属性 禁用 容器盒子的内容属性 1.innerHTML 2.innerText style操作样式属性 局限性： 样式值都是字符串类型的值 通过style读取和设置的都只能是行内样式。 样式属性名的写法跟css有所出入，必须使用“小驼峰”命名法，类似这样：xxxYyyZzz className操作属性 js读取———–var v1 = xx元素.className js中设置 ———- xx元素.—–=‘类名’ 注：如果元素有多个类名，则用空格隔开进行赋值 classList 操作class属性 1.添加一个类（class）： xx元素.classList.add（‘类名’） 2.移除一个类（class）： xx元素.classList.remove( ‘类名’ ) 3.切换一个类（class）： xx元素.classList.toggle( ‘类名’ ) 注： 切换的意思是： 有就移除，没有就添加。 通过className来操作类，和通过classList来操作类，有什么区别？ 1.className设置的类，是会完整覆盖一个元素的calss属性的值 2.classList.add（）设置的类，会保留原来的class，并且加上新的这个 获取非行内样式的值 1.使用xx元素.style.样式名 只能获取行内样式的值 2.getcomputedstyle（xx元素）可以获取到一个元素的所有style样式，结果是一个对象 var style = getcomputedstyle（xx元素）【兼容性】 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"api（二）","slug":"api（二）","permalink":"http://kisskisso.com/tags/api%EF%BC%88%E4%BA%8C%EF%BC%89/"}]},{"title":"WebPAI案例(一)","slug":"WebAPI案例","date":"2020-01-06T01:09:27.000Z","updated":"2021-01-26T09:47:10.000Z","comments":true,"path":"2020/01/06/WebAPI案例/","link":"","permalink":"http://kisskisso.com/2020/01/06/WebAPI%E6%A1%88%E4%BE%8B/","excerpt":"WebPAI案例(一) 放大与缩小案例 &lt;button id='jkl'&gt;放大&lt;/button&gt; &lt;button id='kjl'&gt;缩小&lt;/button&gt; &lt;br&gt; &lt;img src=\"gl.jpg\" alt=\"\" width=\"100\"&gt; &lt;script&gt; var img = document.querySelector('img'); var kids = img.width; var jkl = document.querySelector('#jkl'); var kjl = document.querySekector('#kjl'); jkl.onclick = function(){ kids += 20； img.width = kids； } kjl.onclick = function（）｛ kids -= 20； img.width = kids； ｝ &lt;/script&gt;","text":"WebPAI案例(一) 放大与缩小案例 &lt;button id='jkl'&gt;放大&lt;/button&gt; &lt;button id='kjl'&gt;缩小&lt;/button&gt; &lt;br&gt; &lt;img src=\"gl.jpg\" alt=\"\" width=\"100\"&gt; &lt;script&gt; var img = document.querySelector('img'); var kids = img.width; var jkl = document.querySelector('#jkl'); var kjl = document.querySekector('#kjl'); jkl.onclick = function(){ kids += 20； img.width = kids； } kjl.onclick = function（）｛ kids -= 20； img.width = kids； ｝ &lt;/script&gt; 特殊属性的运用案例 加与减 &lt;style&gt; div { width: 80px; } input[type=\"text\"] { width: 50px; height: 44px; outline: none; border:1px solid #ccc; text-align: center; } input[type=\"button\"] { height: 24px; width: 22px; } input { float: left; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;input type=\"text\" id=\"total\" value=\"1\" readonly&gt; &lt;input type=\"button\" value=\"+\" id=\"add\"&gt; &lt;input type=\"button\" value=\"-\" id=\"reduce\" &gt; &lt;script&gt; var total = document.querySelector('#total') var add = document.querySelector('#add') var reduce = document.querySelector('#reduce') add.onclick = function(){ // 获取到输入框中现有的值 var v1 = total.value; v1++; // 在将该变化了值赋值回输入框 total.value = v1; // 加上去之后，值至少已经是2 了，所以，“-”按钮要重新设置为可用状态： reduce.disabled = false; } reduce.onclick = function(){ // 获取到输入框中现有的值 var v1 = total.value; v1--; if( v1 &lt;= 0) { v1 = 1; // 此时，还需要去禁用“-”这个按钮 // reduce.disable = \"disabled\";// 发现这种写法无效！！！ reduce.disabled = true; } // 在将该变化了值赋值回输入框 total.value = v1; } &lt;/script&gt; &lt;/div&gt; 开关灯案例（开关思想） 注：如何获取body元素（标签）？|document.body| &lt;input type=\"button\" value=\"关灯\" id=\"kids\"&gt; &lt;script&gt; var kids = document.quertSelector('#kids'); var kid = true; kids.onlick = function () { if(kid == true){ kids.value = '开灯'； kid = true； var body = document.body; body.style.backgroundColor = 'black'; }else{ kids.value = '关灯'； kid = false； var body = document.body; body.style.backgroundColor = 'while'; } } &lt;/script&gt; 批量删除案例 &lt;input type=\"button\" id=\"btn1\" disabled value=\"批量删除\"&gt; &lt;table border=\"1\" cellspacing=\"0\" id=\"table1\" width=\"200\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th align=\"left\"&gt; &lt;input type=\"checkbox\" id=\"selectAllBtn\"&gt;全选 &lt;/th&gt; &lt;th&gt;标题&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\"&gt;&lt;/td&gt; &lt;td&gt;标题啦啦啦1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\"&gt;&lt;/td&gt; &lt;td&gt;标题啦啦啦2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\"&gt;&lt;/td&gt; &lt;td&gt;标题啦啦啦3&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;script&gt; var kids = document.querySelector('#btn1'); var kid = document.querySelector('#selectAllBtn'); var lii = document.querySelectorAll('#table1 tbody input'); kid.onclick = function () { var mnu = kid.checked; for (var i = 0; i &lt; lii.lenkgth; i++) { lii[i].checked = mnu; } btn1.disabled = !mnu; } &lt;/script&gt; innerHtml和 innerText复制的区别【经典案例】 &lt;button id=\"btn1\"&gt;复制html&lt;/button&gt; &lt;button id=\"btn2\"&gt;复制text&lt;/button&gt; &lt;div id=\"box1\"&gt; &lt;ul &gt; &lt;li&gt;项目1&lt;/li&gt; &lt;li&gt;项目2&lt;/li&gt; &lt;li&gt;项目3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id=\"box2\"&gt;&lt;/div&gt; &lt;script&gt; var btn1 = document.querySelector('#btn1'); var btn2 = document.querySelector('#btn2'); var box1 = document.querySelector('#box1'); var box2 = document.querySelector('#box2'); btn1.onclick = function(){ var str = box1.innerHTML; console.log(str); box2.innerHTML = str; } btn2.onclick = function(){ var str = box1.innerText; console.log(str); box2.innerText = str; } &lt;/script&gt; 对比innerHTML和createElement()创建元素的效率: &lt;button id=\"btn1\"&gt;使用innerHTML&lt;/button&gt; &lt;button id=\"btn2\"&gt;使用createElement&lt;/button&gt; &lt;ul id=\"list\"&gt;&lt;/ul&gt; &lt;script&gt; var btn1 = document.querySelector('#btn1') var btn2 = document.querySelector('#btn2') var list = document.querySelector('#list') btn1.onclick = function(){ // 先将ul中的所有内容（元素）清掉 list.innerHTML = ''; var str = ''; // 这个变量用于存储 html 代码 var start = new Date(); // 开始时间 // 意图放入1000个li标签到ul中 for(var i = 0; i &lt; 1000; i++) { str += \"&lt;li&gt;\" + Math.random() + \"&lt;/li&gt;\"; list.innerHTML = str; } var end = new Date(); // 结束事件 console.log('耗时：' + (end - start)); } btn2.onclick = function(){ // 先将ul中的所有内容（元素）清掉 list.innerHTML = ''; var start = new Date(); // 开始时间 // 意图放入1000个li标签到ul中 for(var i = 0; i &lt; 1000; i++) { var li = document.createElement('li'); li.innerText = Math.random(); list.appendChild( li ); } var end = new Date(); // 结束事件 console.log('耗时：' + (end - start)); } &lt;/script&gt; 打折案例 &lt;button id=\"btn1\"&gt;打8折！&lt;/button&gt; &lt;ul id=\"list1\"&gt; &lt;li oldPrice=\"222\"&gt;&lt;span&gt;产品1&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/li&gt; &lt;li oldPrice=\"414\"&gt;&lt;span&gt;产品2&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/li&gt; &lt;li oldPrice=\"244\"&gt;&lt;span&gt;产品3&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/li&gt; &lt;li oldPrice=\"513\"&gt;&lt;span&gt;产品4&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/li&gt; &lt;li oldPrice=\"144\"&gt;&lt;span&gt;产品5&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var btn1 = document.querySelector('#btn1'); var ul= document.querySelector('#list1'); var lii = ul.children; //获取ul里面的li //1.初始显示原价 for(var i = 0;i &lt; lii.length;i++){ var oldPrice = list[i].getAttribute('oldPrice'); // 当前 li 中的第2个span var span2 = list[i].children[1]; span2.innerHTML = \"，原价 &lt;del&gt;¥\" + oldPrice + \"&lt;/del&gt;\"; } btn1.onclick = function(){ for(var i = 0; i &lt; list.length; i++){ // 先取出当前li的oldPrice这个自定义属性的值（原价） var oldPrice = list[i].getAttribute('oldPrice'); // 当前 li 中的第3个span var span3 = list[i].children[2]; span3.innerHTML = \"，折后价 &lt;del&gt;¥\" + (oldPrice*0.8).toFixed(2) + \"&lt;/del&gt;\"; } } } &lt;/script&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"案例","slug":"案例","permalink":"http://kisskisso.com/tags/%E6%A1%88%E4%BE%8B/"}]},{"title":"js基础(argment)","slug":"js基础一","date":"2020-01-04T15:12:02.000Z","updated":"2021-01-26T09:18:12.000Z","comments":true,"path":"2020/01/04/js基础一/","link":"","permalink":"http://kisskisso.com/2020/01/04/js%E5%9F%BA%E7%A1%80%E4%B8%80/","excerpt":"**1.argment:**在函数中获取参数的信息———-[个数、值] (注:无法确定用argment,明确用形参(ps:缩写) ps: 本质上是个函数 **全局变量: ** 局部变量: 作用域链 可以在任何作用域使用 可以用return返回值(达到全局) 连接两个作用域链 获取对象中的值: 1.对象名.属性名 2.对象名[‘属性名’]","text":"**1.argment:**在函数中获取参数的信息———-[个数、值] (注:无法确定用argment,明确用形参(ps:缩写) ps: 本质上是个函数 **全局变量: ** 局部变量: 作用域链 可以在任何作用域使用 可以用return返回值(达到全局) 连接两个作用域链 获取对象中的值: 1.对象名.属性名 2.对象名[‘属性名’] 执行对象方法: 1.对象名.方法名 2.对相名 [‘ ‘] () new关键字: new就是调用构造函数,创建对象. 代码的预读: 变量提升 和 函数提升(不包含调用函数). [注:预解析后:先提升函数在提升变量] 4种创造对象的方式 Object:对象 ——–操作对象(取值、赋值)对象是个容器. 组成: 1.属性 2.方法 ☞ 字面量—创造单个 var 对象名 = { 属性 : 值 , (最后一个值不加逗号.) 方法 : 自定义 : function() { ('_') } } ☞ js内置的构造函数— 创造单个 var 对象名 = new Object(); [注:Object():js中内置好的函数] ☞ 工厂方式— 适用于批量创建 function fn(name) { var 对象名 = new Object(); 对象名.属性; return 对象名 } ​ ☞ 自定义构造函数创造—-批量创建 function fn () { this.属性名= 值 } [注:首字母大写] document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"argment","slug":"argment","permalink":"http://kisskisso.com/tags/argment/"}]},{"title":"事件对象event属性","slug":"事件对象exent属性","date":"2020-01-04T14:35:45.000Z","updated":"2021-01-26T10:28:38.000Z","comments":true,"path":"2020/01/04/事件对象exent属性/","link":"","permalink":"http://kisskisso.com/2020/01/04/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1exent%E5%B1%9E%E6%80%A7/","excerpt":"事件对象event属性 事件对象的使用方法 处理函数定义是作为函数的第一个形参,就代表event对象: enter编码13 xx元素.onxx事件 = function(e){ //在此函数中,e就代表event对象 } 或 xx元素.addEventListener('xx事件',function(e)){ //在此函数中,e就代表event对象 } 或","text":"事件对象event属性 事件对象的使用方法 处理函数定义是作为函数的第一个形参,就代表event对象: enter编码13 xx元素.onxx事件 = function(e){ //在此函数中,e就代表event对象 } 或 xx元素.addEventListener('xx事件',function(e)){ //在此函数中,e就代表event对象 } 或 xx元素.onxx事件= func1; xx元素.addEventListener('xx事件',func1);//特别注意:这里只要写也只能写函数名称 function funcl1(e){ // 在此函数中， e 就代表 event对象 } 事件对象event的属性 event.target ++- 代表当前直接触发事件的元素本身 this对比： 代表事件发生时绑定了当前事件的元素 ●event.type 代表当前事件类型,其实就是事件的名称, ●event.clientX,event.clientY 代表事件发生时鼠标在当前窗口可视范围的位置 仅仅只对鼠标事件有效 ●event.pageX,ebent.pageY 代表事件发生时鼠标在页面文档范围的位置 仅仅对鼠标事件有效 ●event.keyCode() 代表键盘事件ain发生是所按下的按键的按键码,是一个数字 仅仅对键盘事件有效 事件对象event的方法 ●even.preventDefault() 取消事件的默认行为, 所谓默认行为，是指一个元素发生某个事件时，默认会产生的结果（行为）。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"event","slug":"event","permalink":"http://kisskisso.com/tags/event/"}]},{"title":"HTML基础（二）","slug":"HTML基础第二天","date":"2020-01-04T14:35:45.000Z","updated":"2021-01-26T09:02:46.000Z","comments":true,"path":"2020/01/04/HTML基础第二天/","link":"","permalink":"http://kisskisso.com/2020/01/04/HTML%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%BA%8C%E5%A4%A9/","excerpt":"第二天 json 更改 表格:跨行(rowspan)是竖着[从上往下夸] 跨列(colspan)横着 ctrl f 查找ctrl s 保存auto rename tag 插件按住滚轮往下b","text":"第二天 json 更改 表格:跨行(rowspan)是竖着[从上往下夸] 跨列(colspan)横着 ctrl f 查找ctrl s 保存auto rename tag 插件按住滚轮往下b dl 自定义列表 dt 文字类标签 dd 并列 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML（二）","slug":"HTML（二）","permalink":"http://kisskisso.com/tags/HTML%EF%BC%88%E4%BA%8C%EF%BC%89/"}]},{"title":"DOM模型","slug":"DOM模型","date":"2020-01-04T14:35:45.000Z","updated":"2021-01-26T08:55:14.000Z","comments":true,"path":"2020/01/04/DOM模型/","link":"","permalink":"http://kisskisso.com/2020/01/04/DOM%E6%A8%A1%E5%9E%8B/","excerpt":"DOM模型 JavaScript由以下三部分构成 1.ECMAScript 2.Bom（浏览器对象） 3.Dom（文档对象） 注：&lt;script&gt;放在body的最后面","text":"DOM模型 JavaScript由以下三部分构成 1.ECMAScript 2.Bom（浏览器对象） 3.Dom（文档对象） 注：&lt;script&gt;放在body的最后面 术语 1.文档（document） 注：1.语法 2.注意大小写3.样式不加-4.多加或少加单引号'' 2.节点（了解） 构成网页的所有组成部分，在js中都被成为节点。 节点类型：①标签节点②属性节点③文本节点 节点属性：①nodeType节点类型②nodeName节点类型③nodeValue节点值 注：节点本身就是对象。 元素节 == 标签名 属性节 == 属性名 文本节 == #text value == null(空) 3.元素 就是html中的标签，在js中称为元素或对象，是节点的一种，也称为元素节点 Dom编程的基本理解 在js代码中获取到网页中的有关标签（元素），并对其进行某种操作。 DOM模型 如何获取元素 根据ID名获取元素 ------document.getElementByid（'id名'）【结果是该id所对应的元素（对象/节点）】 根据标签获取元素 ------document.getElementsByTagName（'标签名'）【结果是一个'集合'（伪数组）】 |注意：标签获取即使只获取一个元素，也是一个伪数组，也是集合，也要用下标去获取| 根据类名获取元素 ------document.getElementsByClassName（'类名'）【结果是一个'集合'（伪数组）】 ------document.querySelector('选择器')【结果是该选择器所对应的第一个元素（对象/节点）】 根据选择器获取元素 ------document.querySelectorAll('选择器')【结果是一个'集合'（伪数组）】 元素（节点）关系获取元素 xx元素.parentNode--------【获取到某元素的父元素】 xx元素.children---------【获取到某元素的所有子元素，是一个集合】 xx元素.firstElementChild--------【获取到某个元素的第一个子元素】 xx元素.lastElementChild--------【获取到某个元素的最后一个子元素】 xx元素.nextElementSibing-------【获取到某个元素的后一个兄弟元素】 xx元素.previousElementSibing------【获取到某个元素的前一个兄弟元素】 添加元素 创建元素-----var 变量 = document.createElement（'标签名'） |注：创建的元素以内存变量的形式，未放入页面中| 克隆元素-----var 变量 = xx元素.cloneNode（true/false）【true表示同时克隆该元素的所有内部内容。false表示不克隆该元素的内部内容】 添加元素到父元素中的最后位置------xx父元素.appendChild（xx要添加的元素）【结果该新添加的元素成为了父元素的最后一个子元素】 添加元素到父元素中的某个元素之前-----xx父元素.insertBefore（xx要添加的元素，xx现有的元素）【结果该新添加的元素成为了父元素的一个子元素，并在指定的子元素前】 替换某个现有元素------xx父元素.replaceChild（xx新，xx旧）【结果就是新的元素替换了所给定的现有子元素】 删除元素 父元素.removeChild（子元素） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"API","slug":"API","permalink":"http://kisskisso.com/tags/API/"}]},{"title":"less补充","slug":"less补充","date":"2020-01-04T14:35:45.000Z","updated":"2021-01-26T09:22:14.000Z","comments":true,"path":"2020/01/04/less补充/","link":"","permalink":"http://kisskisso.com/2020/01/04/less%E8%A1%A5%E5%85%85/","excerpt":"","text":"less补充 引入less: 1.通过link引入less文件 Eg: &lt;link rel=\"stylesheet/less\" href=\"css/less\" &gt; 2.需要在网页中引入less.js文件 Eg:&lt;script src=\"less.js\"&gt; &lt;script&gt; 3.需要在服务器环境下执行 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"less","slug":"less","permalink":"http://kisskisso.com/tags/less/"}]},{"title":"CSS高级用法","slug":"CSS高级用法","date":"2020-01-04T14:35:45.000Z","updated":"2021-01-26T08:51:30.000Z","comments":true,"path":"2020/01/04/CSS高级用法/","link":"","permalink":"http://kisskisso.com/2020/01/04/CSS%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/","excerpt":"CSS高级用法 核心知识点 2D转化及相关属性[重要]","text":"CSS高级用法 核心知识点 2D转化及相关属性[重要] 基本语法: transition:all .5;[过度动画] 旋转: transform:rotate(deg/*度*/) 正顺负逆默中心 tranform-origin/*改变旋转中心点*/ 绕点旋转 具体坐标 | 缩放: tranform:scale(x (w), y (h)); 倍数 scale()中设置的值表示的是一个倍数,没单位 scale()中设置的值如果大于0且小于1, 缩小 scale()中设置的值大于1, 放大 scale()中设置的值等于1, 不变 scale()中设置的值等于0,该宽高等于0 scale()中设置的值可以设置一个,宽和高的倍数 scale()中不能设置负数 注:如果页面中元素要同时设置多个tranform属性的时候,tranform属性要合写[防层叠] 位移: x轴:水平,左向右为正 y轴:垂直,上向下为正 tranform:tranlate(x,y); 中第一个值代表水平方向位移,第二个值代表垂直方向位移 补充:线性渐变 background-image: linear-gradient( /* 渐变的方向 */ to right, #34c2aa, #6cd557 /* 使用角度的方式渐变 */ /* 135deg, red, blue */ ); 3D转换 语法: tranform:tranlateX(值) /*x必须大写*/可以设置百分比 tranlateX只能让元素沿着水平方向位移 可以设置负数,沿水平相反的方向位移(从右往左) 可以设置百分比,百分比是相对于当前元素的宽度 Y Z prespective: 透视在浏览器中出现近大远小的效果 (透视:推荐值--&gt;600--1000) prespective属性设置:给tranform属性的父元素添加 总结: 旋转: 加个坐标轴 x 正往我这边 Y 正往右 开门 z 于2d转换效果一样 总结:如果元素沿着x轴旋转,x轴默认中间位置 3d改旋转轴 tranSform-origin tranSform-origin:left;轴 缩放: tranSporfm: scale() 转化样式平面转立体 transform-style:preserve-3d; animation属性 animation–动画自动播放 ,动画次数可以无限次执行 transition— 动画需用户动作,动画随着用户动作的取消 @keyframes name { /*设置动画在开始时候的样式*/ from { } /* 动画开始后的一个效果 */ to { } } animation-name:调用动画名称 animation-dyration:设置动画时间 animation-iteraton-count:设置动画次数 infinite;无限次执行 animation-direction:alternate; 逆播 animation-timing-function:;速度默认值ease | linear匀速 ease-in 加速 | ease-out 减速 |ease-in-out animation-fill-mode:forwards;让动画在结束位置停止[条件不能设置无限次数] animation-delay:设置动画延迟时间 animation复合属性: 1.设置 animation -name 2 设置 animation-duration document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"css高级","slug":"css高级","permalink":"http://kisskisso.com/tags/css%E9%AB%98%E7%BA%A7/"}]},{"title":"less","slug":"less","date":"2020-01-04T14:35:45.000Z","updated":"2021-01-26T09:21:42.000Z","comments":true,"path":"2020/01/04/less/","link":"","permalink":"http://kisskisso.com/2020/01/04/less/","excerpt":"less less.bootcss.com/# less去写css代码优势: 1.less中可以进行数字运算 2.less中可以支持选择器中嵌套选择器 less使用步骤: 1.新建less文件 ​ ☂ 文件名以less结尾 2.less按照css语法编写 ​ ☂ less文件中完全可以使用css原生的语法去写","text":"less less.bootcss.com/# less去写css代码优势: 1.less中可以进行数字运算 2.less中可以支持选择器中嵌套选择器 less使用步骤: 1.新建less文件 ​ ☂ 文件名以less结尾 2.less按照css语法编写 ​ ☂ less文件中完全可以使用css原生的语法去写 3.less语法 ​ ☂ less嵌套语法(只适用嵌套结构的标签) .nav{ li{ } } ​ ☞支持数学运算 ​ ☞支持变量的设置(如果某个值是一个变化的值,那么就可以将改制保存到变量中) @div_width: ***; ​ ☞less混合写法 //less中的函数 [类似于css中的公共样式] #abc(){ color:red; font-size:20px; } 例如: .public(){ width:300px; height:300px; background-color:skyblue; } .one{ color:red; .public() } .two{ color:black; .public() } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"less","slug":"less","permalink":"http://kisskisso.com/tags/less/"}]},{"title":"bootstrap框架","slug":"bootstrap框架","date":"2020-01-04T14:35:45.000Z","updated":"2021-01-26T08:49:14.000Z","comments":true,"path":"2020/01/04/bootstrap框架/","link":"","permalink":"http://kisskisso.com/2020/01/04/bootstrap%E6%A1%86%E6%9E%B6/","excerpt":"bootstrap框架 1.为了快速实现响应式布局和移动端页面为主. 2.全局样式[网页中常见标签的基本样式设置] 栅格系统[为实现响应式布局的]——-媒体查询","text":"bootstrap框架 1.为了快速实现响应式布局和移动端页面为主. 2.全局样式[网页中常见标签的基本样式设置] 栅格系统[为实现响应式布局的]——-媒体查询 ☞下载(css文件) 生产环境:压缩,快速开发,并不适合学习 源码:手写,没压缩 使用—引用 语义标签—–(忘了) 全局标签(最好刚刚不要使用…) 标题标签(可以直接写标签名字 | 对应类名) 表示超小文字(可以使用small标签 | 对应的类名) text-capitallizr //*首个字母大小 .text-capitalize 栅格系统 odd奇数 even偶数 作用:用来实现响应式布局,通过将设备(视口)分为12列 使用: 1.引用bootstrap.css文件 [用一个就行] 2.给父元素容器设置container[固定居中]或者container-fluid[满屏] 3.只要给盒子设置了****或者***类名后就会分为12列 4.通过栅格参数实现响应式布 .col-md ----&gt;适配电脑屏幕 .col-sm ----&gt;适配平板设备 .col-xs ----&gt;适配手机设备 .col-lg ----&gt;适配大屏幕设备 2000px(或者1200px)?忘了 可以给 *加边框,也可以加padding值 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://kisskisso.com/tags/bootstrap/"}]},{"title":"如何有效阅读一本书（一）","slug":"如何有效阅读一本书(一)","date":"2020-01-04T14:35:45.000Z","updated":"2021-01-26T10:25:16.000Z","comments":true,"path":"2020/01/04/如何有效阅读一本书(一)/","link":"","permalink":"http://kisskisso.com/2020/01/04/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6(%E4%B8%80)/","excerpt":"如何有效阅读一本书（一） 1.随想笔记:记录平时的感悟,这与日后的选书息息相关. 【注:a.可以书写任何内容 b.按时间顺序书写 c.附上日期 d.灵活运用速记或略记 e.可以粘贴 】 2.购书清单:找到真正想读的书. [注:选书.购书.读书和活用才是读书的完整流程] (归档…..) ​ |书名、作者与出版社名.| 标注:所谓读书的动机或目的性,就好比照片的’焦点’.即使拍摄同样的场景,聚焦于面前的花朵和聚焦于远处的建筑,得到的效果完全不同.读书也一样,抱着不同的目的阅读同一本书,也会产生截然不同的效果. 3.各种报道的剪报:尽情的收录感兴趣的内容. 4.读书笔记:将读后感转变成文字保存下来.","text":"如何有效阅读一本书（一） 1.随想笔记:记录平时的感悟,这与日后的选书息息相关. 【注:a.可以书写任何内容 b.按时间顺序书写 c.附上日期 d.灵活运用速记或略记 e.可以粘贴 】 2.购书清单:找到真正想读的书. [注:选书.购书.读书和活用才是读书的完整流程] (归档…..) ​ |书名、作者与出版社名.| 标注:所谓读书的动机或目的性,就好比照片的’焦点’.即使拍摄同样的场景,聚焦于面前的花朵和聚焦于远处的建筑,得到的效果完全不同.读书也一样,抱着不同的目的阅读同一本书,也会产生截然不同的效果. 3.各种报道的剪报:尽情的收录感兴趣的内容. 4.读书笔记:将读后感转变成文字保存下来. 5.养成习惯 6.放大读书笔记的作用. 7.创造别具一格的记录方式 8.信息一元化(读书一元化) 【注:①简单易懂.人人都能做到 ②更容易坚持. ③自由度高,可自行设置 ④信息'存在'于同一个地方 ⑤直接记录.参考.不易混肴. ⑥因为'杂乱无章',所以便于活用】 杂:绫辻行人的钟表馆事件.远宁的八声甘州以及岛田庄司系列和江户川乱步系列. –新星出版社– ps:听说他们家的纸不是很好 :） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"我的读书笔记","slug":"我的读书笔记","permalink":"http://kisskisso.com/tags/%E6%88%91%E7%9A%84%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"rem适配","slug":"rem","date":"2020-01-04T14:35:45.000Z","updated":"2021-01-26T09:32:58.000Z","comments":true,"path":"2020/01/04/rem/","link":"","permalink":"http://kisskisso.com/2020/01/04/rem/","excerpt":"rem适配 [vw] 移动端方式 补:opacity: 透明颜色; 1.流式布局(百分比布局)**2.**伸缩布局(弹性布局)**3.**响应式布局(媒体查询) 4.**rem适配:**让元素(内容)随着设备的宽度改变,自己发生大小的改变 计算移动端中根标签[html]文字大小=当前设备宽度(动态获取)/缩放的倍数 媒体查询----定义一个变量 计算ui图片中测量元素的rem值=测量大小/(ui图大小/缩放倍数) rem值是根据根(html)标签的文字大小来设置的 ​ 注: UI 图中缩放的倍数必须和设备中缩放的倍数统一 @size是什么?","text":"rem适配 [vw] 移动端方式 补:opacity: 透明颜色; 1.流式布局(百分比布局)**2.**伸缩布局(弹性布局)**3.**响应式布局(媒体查询) 4.**rem适配:**让元素(内容)随着设备的宽度改变,自己发生大小的改变 计算移动端中根标签[html]文字大小=当前设备宽度(动态获取)/缩放的倍数 媒体查询----定义一个变量 计算ui图片中测量元素的rem值=测量大小/(ui图大小/缩放倍数) rem值是根据根(html)标签的文字大小来设置的 ​ 注: UI 图中缩放的倍数必须和设备中缩放的倍数统一 @size是什么? 补充: 为什么页面适配要使用rem而不是em? 1.rem在适配的时候是相对html中的文字大小 2.html中的文字大小不会影响某个具体标签中的文字大小(继承的权重为0) 3.rem适配最重要的一步就是要保证html中设置文字的大小 **注:**保证当前标签中文字大小是30px 又要保证当前标签的宽度是400px UI 640px —-20倍 750px—-25倍 **em:**相对单位,em是相对当前标签中文字大小 **rem:**相对单位,r(root),rem单位是相对html根标签中文字的大小 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"rem适配","slug":"rem适配","permalink":"http://kisskisso.com/tags/rem%E9%80%82%E9%85%8D/"}]},{"title":"js（一）","slug":"js一","date":"2019-12-27T01:06:45.000Z","updated":"2021-01-26T09:19:24.000Z","comments":true,"path":"2019/12/27/js一/","link":"","permalink":"http://kisskisso.com/2019/12/27/js%E4%B8%80/","excerpt":"js 行内式: 学习阶段 1.先准备一个html 2.在html页面中任何一个位置,添加一个&lt;script&gt;&lt;/script&gt;标签 3.对应代码 外联式: 大项目 1.单独一个js文件 .js 2.在js文件直接写对应的js代码 3.通过&lt;script src=\"js文件路径\"&gt; &lt;/script&gt;----引用js文件 当前一个值是变量不需要加单引号.... console.log('要展示的信息');控制台 注意: 1.在程序中遇到的任何一个特殊符号,都必须是英文输入法的符号 2. 9.alert('新窗口'); 弹出窗口 3.document.write('展示信息');网页 4. 获取用户输入信息 prompt('提示用户要输入的信息'); 变量:","text":"js 行内式: 学习阶段 1.先准备一个html 2.在html页面中任何一个位置,添加一个&lt;script&gt;&lt;/script&gt;标签 3.对应代码 外联式: 大项目 1.单独一个js文件 .js 2.在js文件直接写对应的js代码 3.通过&lt;script src=\"js文件路径\"&gt; &lt;/script&gt;----引用js文件 当前一个值是变量不需要加单引号.... console.log('要展示的信息');控制台 注意: 1.在程序中遇到的任何一个特殊符号,都必须是英文输入法的符号 2. 9.alert('新窗口'); 弹出窗口 3.document.write('展示信息');网页 4. 获取用户输入信息 prompt('提示用户要输入的信息'); 变量: 作用:在程序中保存数据的一个容器 var 自定义变量名 注: 1.定义必须写var 写法: var 变量名 = 值; 注意: '=' 叫赋值运算 '=' 右侧的结果 赋值给 左侧变量 var kid = prompt ('请输入摄氏度') alert () 变量的命名规范: .变量名在合法的时候一定的语义 字符必须是字母、 数字或下划线 .不能用的(var变量名—关键字不能作为变量名) (数字不能作为变量名) (变量中间不能出现空格) (汉字不能作为变量名) (不建议直接使用name) (不建议使用js的保留字) Number—-&gt;数字 ​ 1.arseInt—&gt;整数类型 2,parseFloat —&gt;浮点类型 boonlen类型 string 类型 如果布尔类型的false转化为数字类型后数字是0 ​ true 转化为1 undefined类型 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://kisskisso.com/tags/js/"}]},{"title":"HTML+CSS+JS代码规范","slug":"前端代码规范","date":"2019-12-20T09:46:43.000Z","updated":"2021-01-26T10:18:04.000Z","comments":true,"path":"2019/12/20/前端代码规范/","link":"","permalink":"http://kisskisso.com/2019/12/20/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/","excerpt":"HTML+CSS+JS代码格式规范 1.为什么要按照规范写代码 ☞代码规则 编译器在编译时就会报错，这个规定叫作规则 ☞代码规范 有一种规定，它是一种人为的、约定成俗的，即使不按照那种规定也不会出错，这种规定就叫作规范 ☞代码规范化的好处 规范的代码可以减少bug处理，规范的代码可以降低维护成本，规范的代码有助于代码审查。","text":"HTML+CSS+JS代码格式规范 1.为什么要按照规范写代码 ☞代码规则 编译器在编译时就会报错，这个规定叫作规则 ☞代码规范 有一种规定，它是一种人为的、约定成俗的，即使不按照那种规定也不会出错，这种规定就叫作规范 ☞代码规范化的好处 规范的代码可以减少bug处理，规范的代码可以降低维护成本，规范的代码有助于代码审查。 2. HTML代码规范介绍 1.嵌套元素应当缩进一次（即两个空格） &lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; 2.对于属性的定义，确保全部使用双引号，不要使用单引号。 &lt;div class=\"username\"&gt;&lt;/div&gt; 3.单标签中不要添加‘/’结束 &lt;br&gt; 备注： html5中提示可以加可以不加 4.不能省略双标签的结束的标签 &lt;div&gt;&lt;/div&gt; 5.在引入CSS文件和JS文件时候，不需要指定type属性 &lt;style&gt;&lt;/style&gt; &lt;script&gt;&lt;/script&gt; 备注：type属性属于以上标签的默认值 6.标签使用过程中，要遵循标签的语义化 7.标签设置属性的时候，要按照顺序依次设置，保证代码易读性 &lt;div class=\"\" id=\"\" name=\"\"&gt;&lt;/div&gt; 3.CSS代码规范介绍 1. 为了代码的易读性，在每个声明块的左花括号前添加一个空格，且单独成行 选择器 { } 2.每条声明语句的：后应该插入一个空格,且以封号结束 选择器 { color: red; } 3.避免为 0 值指定单位 选择器 { margin: 0; } 4. 声明顺序 1. 定位 2. 盒子模型 3. 其他内部属性 例如： div { position: absolute; left: 0; top: 0; width: 200px; height: 200px; font-size: 12px; text-align: center; } 5. 选择器 1.优先选择类选择器，有利于渲染性能优化 2.选择器层级不能太高，最多不要超过3个 4.js语法规范 ☞定义变量后要空行,在定义变量的同时初始化该变量 var num = 123; ☞函数名之后不要留空格 function fn() { } ☞单目运算符 !、~、++、－－、－、*、&amp; 等前后不加空格 ☞声明数组使用[] var ary = []; ☞通常能用CSS实现的效果要避免使用JS来实现 ☞变量要使用驼峰命名法，使用名词结构 var userName = 'zs' 备注： 1. 首字母小写，后面单词首字母大写 ☞构造函数使用帕斯卡命名法 function Person() {} 备注： 1. 所有单词都以大写字母开始 ☞对象属性命名必须唯一 var obj { age: 12, height: 170 } ☞在同一个作用域下，变量名和方法名不要重复 var fn = 12; function fn() {} ☞每一个方法之间空一行 function fn() {} function fn1() {} ☞运算符前后需要添加空格 var a; var b = a; ☞紧挨着圆括号内不需要加空格 for(var i = 1; i &lt;= 10; i++) {} ☞三目运算符用来进行条件性的赋值，不要用来当做简写的 if 语句使用。 var a = a &gt;= 10? a : 10; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"代码规范","slug":"代码规范","permalink":"http://kisskisso.com/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}]},{"title":"1.1","slug":"左边的侧边栏","date":"2019-12-12T01:46:45.000Z","updated":"2021-01-26T10:47:58.000Z","comments":true,"path":"2019/12/12/左边的侧边栏/","link":"","permalink":"http://kisskisso.com/2019/12/12/%E5%B7%A6%E8%BE%B9%E7%9A%84%E4%BE%A7%E8%BE%B9%E6%A0%8F/","excerpt":"","text":"1.1 左侧边栏出来的话需要在同级别下 common.css(公共样式{模块化} ) 注:先引入初始化后引入公共样式 关于三大标签的SEO的优化: titile标题 description网站说明(meta name=””content=””) keywoeds(关键字) 字体不一样不要给li设置宽高（关于竖线的需要单独的小li） 关于字体图标的用法 logo SEO : logo盒子 然后是h1 然后是a链接 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"1.1","slug":"1-1","permalink":"http://kisskisso.com/tags/1-1/"}]}],"categories":[{"name":"笔记","slug":"笔记","permalink":"http://kisskisso.com/categories/%E7%AC%94%E8%AE%B0/"},{"name":"应用与插件","slug":"应用与插件","permalink":"http://kisskisso.com/categories/%E5%BA%94%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6/"},{"name":"语言与Linux","slug":"语言与Linux","permalink":"http://kisskisso.com/categories/%E8%AF%AD%E8%A8%80%E4%B8%8ELinux/"},{"name":"生活与话","slug":"生活与话","permalink":"http://kisskisso.com/categories/%E7%94%9F%E6%B4%BB%E4%B8%8E%E8%AF%9D/"},{"name":"Web前端","slug":"Web前端","permalink":"http://kisskisso.com/categories/Web%E5%89%8D%E7%AB%AF/"},{"name":"爱好心理学","slug":"爱好心理学","permalink":"http://kisskisso.com/categories/%E7%88%B1%E5%A5%BD%E5%BF%83%E7%90%86%E5%AD%A6/"},{"name":"算法与面试题","slug":"算法与面试题","permalink":"http://kisskisso.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"WSL","slug":"WSL","permalink":"http://kisskisso.com/tags/WSL/"},{"name":"RSS","slug":"RSS","permalink":"http://kisskisso.com/tags/RSS/"},{"name":"omz","slug":"omz","permalink":"http://kisskisso.com/tags/omz/"},{"name":"终端","slug":"终端","permalink":"http://kisskisso.com/tags/%E7%BB%88%E7%AB%AF/"},{"name":"软件","slug":"软件","permalink":"http://kisskisso.com/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"Gittalk","slug":"Gittalk","permalink":"http://kisskisso.com/tags/Gittalk/"},{"name":"插件","slug":"插件","permalink":"http://kisskisso.com/tags/%E6%8F%92%E4%BB%B6/"},{"name":"SSH","slug":"SSH","permalink":"http://kisskisso.com/tags/SSH/"},{"name":"CSS","slug":"CSS","permalink":"http://kisskisso.com/tags/CSS/"},{"name":"vue","slug":"vue","permalink":"http://kisskisso.com/tags/vue/"},{"name":"http重定向","slug":"http重定向","permalink":"http://kisskisso.com/tags/http%E9%87%8D%E5%AE%9A%E5%90%91/"},{"name":"vuepress","slug":"vuepress","permalink":"http://kisskisso.com/tags/vuepress/"},{"name":"Cygwin","slug":"Cygwin","permalink":"http://kisskisso.com/tags/Cygwin/"},{"name":"沙盒","slug":"沙盒","permalink":"http://kisskisso.com/tags/%E6%B2%99%E7%9B%92/"},{"name":"EndNote","slug":"EndNote","permalink":"http://kisskisso.com/tags/EndNote/"},{"name":"心理学","slug":"心理学","permalink":"http://kisskisso.com/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"},{"name":"react","slug":"react","permalink":"http://kisskisso.com/tags/react/"},{"name":"画","slug":"画","permalink":"http://kisskisso.com/tags/%E7%94%BB/"},{"name":"Krita","slug":"Krita","permalink":"http://kisskisso.com/tags/Krita/"},{"name":"知识","slug":"知识","permalink":"http://kisskisso.com/tags/%E7%9F%A5%E8%AF%86/"},{"name":"读书","slug":"读书","permalink":"http://kisskisso.com/tags/%E8%AF%BB%E4%B9%A6/"},{"name":"图床","slug":"图床","permalink":"http://kisskisso.com/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"面试题","slug":"面试题","permalink":"http://kisskisso.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"C","slug":"C","permalink":"http://kisskisso.com/tags/C/"},{"name":"Git命令","slug":"Git命令","permalink":"http://kisskisso.com/tags/Git%E5%91%BD%E4%BB%A4/"},{"name":"话","slug":"话","permalink":"http://kisskisso.com/tags/%E8%AF%9D/"},{"name":"美化","slug":"美化","permalink":"http://kisskisso.com/tags/%E7%BE%8E%E5%8C%96/"},{"name":"c语言","slug":"c语言","permalink":"http://kisskisso.com/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"复习题","slug":"复习题","permalink":"http://kisskisso.com/tags/%E5%A4%8D%E4%B9%A0%E9%A2%98/"},{"name":"代码片段","slug":"代码片段","permalink":"http://kisskisso.com/tags/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"},{"name":"js","slug":"js","permalink":"http://kisskisso.com/tags/js/"},{"name":"错误","slug":"错误","permalink":"http://kisskisso.com/tags/%E9%94%99%E8%AF%AF/"},{"name":"findIndex","slug":"findIndex","permalink":"http://kisskisso.com/tags/findIndex/"},{"name":"排序","slug":"排序","permalink":"http://kisskisso.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"ESLint","slug":"ESLint","permalink":"http://kisskisso.com/tags/ESLint/"},{"name":"输入法","slug":"输入法","permalink":"http://kisskisso.com/tags/%E8%BE%93%E5%85%A5%E6%B3%95/"},{"name":"ECS6","slug":"ECS6","permalink":"http://kisskisso.com/tags/ECS6/"},{"name":"Atom","slug":"Atom","permalink":"http://kisskisso.com/tags/Atom/"},{"name":"Linux命令","slug":"Linux命令","permalink":"http://kisskisso.com/tags/Linux%E5%91%BD%E4%BB%A4/"},{"name":"css","slug":"css","permalink":"http://kisskisso.com/tags/css/"},{"name":"zsh","slug":"zsh","permalink":"http://kisskisso.com/tags/zsh/"},{"name":"问题","slug":"问题","permalink":"http://kisskisso.com/tags/%E9%97%AE%E9%A2%98/"},{"name":"知识点（一）","slug":"知识点（一）","permalink":"http://kisskisso.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89/"},{"name":"404","slug":"404","permalink":"http://kisskisso.com/tags/404/"},{"name":"JQ","slug":"JQ","permalink":"http://kisskisso.com/tags/JQ/"},{"name":"数组","slug":"数组","permalink":"http://kisskisso.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"心流","slug":"心流","permalink":"http://kisskisso.com/tags/%E5%BF%83%E6%B5%81/"},{"name":"typora","slug":"typora","permalink":"http://kisskisso.com/tags/typora/"},{"name":"cmder","slug":"cmder","permalink":"http://kisskisso.com/tags/cmder/"},{"name":"JS进阶","slug":"JS进阶","permalink":"http://kisskisso.com/tags/JS%E8%BF%9B%E9%98%B6/"},{"name":"思维","slug":"思维","permalink":"http://kisskisso.com/tags/%E6%80%9D%E7%BB%B4/"},{"name":"token","slug":"token","permalink":"http://kisskisso.com/tags/token/"},{"name":"节流与防抖","slug":"节流与防抖","permalink":"http://kisskisso.com/tags/%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/"},{"name":"组件","slug":"组件","permalink":"http://kisskisso.com/tags/%E7%BB%84%E4%BB%B6/"},{"name":"vuex","slug":"vuex","permalink":"http://kisskisso.com/tags/vuex/"},{"name":"css属性","slug":"css属性","permalink":"http://kisskisso.com/tags/css%E5%B1%9E%E6%80%A7/"},{"name":"vue-router","slug":"vue-router","permalink":"http://kisskisso.com/tags/vue-router/"},{"name":"概念","slug":"概念","permalink":"http://kisskisso.com/tags/%E6%A6%82%E5%BF%B5/"},{"name":"模块","slug":"模块","permalink":"http://kisskisso.com/tags/%E6%A8%A1%E5%9D%97/"},{"name":"SQL","slug":"SQL","permalink":"http://kisskisso.com/tags/SQL/"},{"name":"npm包","slug":"npm包","permalink":"http://kisskisso.com/tags/npm%E5%8C%85/"},{"name":"npm命令","slug":"npm命令","permalink":"http://kisskisso.com/tags/npm%E5%91%BD%E4%BB%A4/"},{"name":"npm","slug":"npm","permalink":"http://kisskisso.com/tags/npm/"},{"name":"node","slug":"node","permalink":"http://kisskisso.com/tags/node/"},{"name":"模块化","slug":"模块化","permalink":"http://kisskisso.com/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"Node","slug":"Node","permalink":"http://kisskisso.com/tags/Node/"},{"name":"axios","slug":"axios","permalink":"http://kisskisso.com/tags/axios/"},{"name":"ajax","slug":"ajax","permalink":"http://kisskisso.com/tags/ajax/"},{"name":"http","slug":"http","permalink":"http://kisskisso.com/tags/http/"},{"name":"jsonp","slug":"jsonp","permalink":"http://kisskisso.com/tags/jsonp/"},{"name":"git","slug":"git","permalink":"http://kisskisso.com/tags/git/"},{"name":"xhr","slug":"xhr","permalink":"http://kisskisso.com/tags/xhr/"},{"name":"JSON方法","slug":"JSON方法","permalink":"http://kisskisso.com/tags/JSON%E6%96%B9%E6%B3%95/"},{"name":"Ajax","slug":"Ajax","permalink":"http://kisskisso.com/tags/Ajax/"},{"name":"案例（一）","slug":"案例（一）","permalink":"http://kisskisso.com/tags/%E6%A1%88%E4%BE%8B%EF%BC%88%E4%B8%80%EF%BC%89/"},{"name":"总结","slug":"总结","permalink":"http://kisskisso.com/tags/%E6%80%BB%E7%BB%93/"},{"name":"阅读","slug":"阅读","permalink":"http://kisskisso.com/tags/%E9%98%85%E8%AF%BB/"},{"name":"防御机制","slug":"防御机制","permalink":"http://kisskisso.com/tags/%E9%98%B2%E5%BE%A1%E6%9C%BA%E5%88%B6/"},{"name":"python","slug":"python","permalink":"http://kisskisso.com/tags/python/"},{"name":"回顾","slug":"回顾","permalink":"http://kisskisso.com/tags/%E5%9B%9E%E9%A1%BE/"},{"name":"知识点","slug":"知识点","permalink":"http://kisskisso.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"事件","slug":"事件","permalink":"http://kisskisso.com/tags/%E4%BA%8B%E4%BB%B6/"},{"name":"BOM模型","slug":"BOM模型","permalink":"http://kisskisso.com/tags/BOM%E6%A8%A1%E5%9E%8B/"},{"name":"API","slug":"API","permalink":"http://kisskisso.com/tags/API/"},{"name":"伸缩","slug":"伸缩","permalink":"http://kisskisso.com/tags/%E4%BC%B8%E7%BC%A9/"},{"name":"我的读书笔记","slug":"我的读书笔记","permalink":"http://kisskisso.com/tags/%E6%88%91%E7%9A%84%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"练习","slug":"练习","permalink":"http://kisskisso.com/tags/%E7%BB%83%E4%B9%A0/"},{"name":"知识点（二）","slug":"知识点（二）","permalink":"http://kisskisso.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"name":"HTML(一)","slug":"HTML-一","permalink":"http://kisskisso.com/tags/HTML-%E4%B8%80/"},{"name":"移动端","slug":"移动端","permalink":"http://kisskisso.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"视口","slug":"视口","permalink":"http://kisskisso.com/tags/%E8%A7%86%E5%8F%A3/"},{"name":"媒体查询","slug":"媒体查询","permalink":"http://kisskisso.com/tags/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/"},{"name":"api（二）","slug":"api（二）","permalink":"http://kisskisso.com/tags/api%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"name":"案例","slug":"案例","permalink":"http://kisskisso.com/tags/%E6%A1%88%E4%BE%8B/"},{"name":"argment","slug":"argment","permalink":"http://kisskisso.com/tags/argment/"},{"name":"event","slug":"event","permalink":"http://kisskisso.com/tags/event/"},{"name":"HTML（二）","slug":"HTML（二）","permalink":"http://kisskisso.com/tags/HTML%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"name":"less","slug":"less","permalink":"http://kisskisso.com/tags/less/"},{"name":"css高级","slug":"css高级","permalink":"http://kisskisso.com/tags/css%E9%AB%98%E7%BA%A7/"},{"name":"bootstrap","slug":"bootstrap","permalink":"http://kisskisso.com/tags/bootstrap/"},{"name":"rem适配","slug":"rem适配","permalink":"http://kisskisso.com/tags/rem%E9%80%82%E9%85%8D/"},{"name":"代码规范","slug":"代码规范","permalink":"http://kisskisso.com/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"1.1","slug":"1-1","permalink":"http://kisskisso.com/tags/1-1/"}]}